DUNFIELD 8085 ASSEMBLER: T_ADDR                                       PAGE: 1

0000                         1  *#cpu 8085
0000                         2  *
0000                         3  * DDS MICRO-C 8080/85/Z80 Startup Code and Runtime library
0000                         4  *
0000                         5  * Copyright 1991-2005 Dave Dunfield
0000                         6  * All rights reserved.
0000                         7  *
0000                         8  	ORG	$0		Place code in memory here
0000  00                     9  	NOP
0001  00                    10  	NOP
0002  00                    11  	NOP
0003  31 00 20              12  	LXI	SP,$2000	Initial stack goes here
0006  AF                    13  	XRA	A		Get a ZERO
0007  32 DC 01              14  	STA	?heap		Initialize the heap
000A  CD 85 01              15  	CALL	main		Execute user program
000D                        16  * Get byte from stack variable: L = [SP+i]
000D  E1                    17  ?gstkbi	POP	H		HL = Stack
000E  7E                    18  	MOV	A,M		Get value
000F  23                    19  	INX	H		Skip
0010  E5                    20  	PUSH	H		Restore stack
0011  6F                    21  	MOV	L,A		L = low address
0012  26 00                 22  	MVI	H,0		Zero high
0014                        23  * Get byte from stack variable: L = [SP+HL]
0014  39                    24  ?gstkb	DAD	SP		Offset to stack
0015  6E                    25  	MOV	L,M		Get data byte
0016  C9                    26  	RET
0017                        27  * Put byte into stack variable: [SP+i] = L
0017  E3                    28  ?pstkbi	XTHL			HL = immediate address
0018  4E                    29  	MOV	C,M		Get value
0019  23                    30  	INX	H		Skip
001A  E3                    31  	XTHL			Restore stack
001B  06 00                 32  	MVI	B,0		Zero high
001D                        33  * Put byte into stack variable: [SP+BC] = L
001D  E5                    34  ?pstkb	PUSH	H		Save value
001E  60                    35  	MOV	H,B		Get high offset
001F  69                    36  	MOV	L,C		Get low offset
0020  C1                    37  	POP	B		Get return value
0021  39                    38  	DAD	SP		Offset to variable
0022  71                    39  	MOV	M,C		Write high byte
0023  60                    40  	MOV	H,B		Restore high
0024  69                    41  	MOV	L,C		Restore low
0025  C9                    42  	RET
0026                        43  * Get word from stack variable: HL = [SP+i]
0026  E1                    44  ?gstkwi	POP	H		Get address
0027  7E                    45  	MOV	A,M		Get value
0028  23                    46  	INX	H		Skip
0029  E5                    47  	PUSH	H		Restore stack
002A  26 00                 48  	MVI	H,0		Zero high
002C                        49  * Get word from stack variable: HL = [SP+HL]
002C  39                    50  ?gstkw	DAD	SP		Offset to stack
002D  7E                    51  	MOV	A,M		Get low data byte
002E  23                    52  	INX	H		Offset to next
002F  66                    53  	MOV	H,M		Get high data byte
0030  6F                    54  	MOV	L,A		Include low byte
0031  C9                    55  	RET
0032                        56  * Put work into stack variable: [SP+i] = HL
0032  E3                    57  ?pstkwi	XTHL			Get address
0033  4E                    58  	MOV	C,M		Get value
DUNFIELD 8085 ASSEMBLER: T_ADDR                                       PAGE: 2

0034  23                    59  	INX	H		Skip
0035  E3                    60  	XTHL			Restore stack
0036  06 00                 61  	MVI	B,0		Zero high
0038                        62  * Put word into stack variable: [SP+BC] = HL
0038  E5                    63  ?pstkw	PUSH	H		Save value
0039  60                    64  	MOV	H,B		Get high offset
003A  69                    65  	MOV	L,C		Get low offset
003B  C1                    66  	POP	B		Restore value
003C  39                    67  	DAD	SP		Offset to variable
003D  71                    68  	MOV	M,C		Write low byte
003E  23                    69  	INX	H		Advance
003F  70                    70  	MOV	M,B		Write high byte
0040  60                    71  	MOV	H,B		Restore high
0041  69                    72  	MOV	L,C		Restore low
0042  C9                    73  	RET
0043                        74  * Get a 16 bit value indirect through index: HL = [DE]
0043  EB                    75  ?gind_d	XCHG			HL = Index register
0044  5E                    76  	MOV	E,M		Get low byte
0045  23                    77  	INX	H		Advance to next
0046  56                    78  	MOV	D,M		Get high byte
0047  2B                    79  	DCX	H		Restore index
0048  EB                    80  	XCHG			Swap back
0049  C9                    81  	RET
004A                        82  * Put a 16 bit value indirect through index: [DE] = HL
004A  EB                    83  ?pind_d	XCHG			Swap
004B  73                    84  	MOV	M,E		Write low byte
004C  23                    85  	INX	H		Advance to next
004D  72                    86  	MOV	M,D		Write high byte
004E  2B                    87  	DCX	H		Restore index
004F  EB                    88  	XCHG			Swap back
0050  C9                    89  	RET
0051                        90  * Get a 16 bit value indirect through HL: HL = [HL]
0051  7E                    91  ?gind_h	MOV	A,M		Get low byte
0052  23                    92  	INX	H		Advance
0053  66                    93  	MOV	H,M		Get high byte
0054  6F                    94  	MOV	L,A		Include low byte
0055  C9                    95  	RET
0056                        96  * Put a 16 bit value indirect through BC: [BC] = HL
0056  7D                    97  ?pind_b	MOV	A,L		Get low byte
0057  02                    98  	STAX	B		Write it
0058  03                    99  	INX	B		Advance it
0059  7C                   100  	MOV	A,H		Get high byte
005A  02                   101  	STAX	B		Write it
005B  C9                   102  	RET
005C                       103  * Sign extend L into H
005C  7D                   104  ?sign	MOV	A,L		Get character value
005D  07                   105  	RLC			Set 'C' if A < 0
005E  9F                   106  	SBB	A		Get sign extension
005F  67                   107  	MOV	H,A		Set high value
0060  C9                   108  nargs	RET
0061                       109  * Perform a switch statement
0061  EB                   110  ?switch	XCHG			HL=Table address, DE=Switch value
0062  4E                   111  ?swit1	MOV	C,M		Get low address
0063  23                   112  	INX	H		Advance to next
0064  46                   113  	MOV	B,M		Get high address
0065  23                   114  	INX	H		Advance to next
0066  78                   115  	MOV	A,B		Test for zero
0067  B1                   116  	ORA	C		End of table?
DUNFIELD 8085 ASSEMBLER: T_ADDR                                       PAGE: 3

0068  CA 79 00             117  	JZ	?swit3		Yes, use default
006B  7E                   118  	MOV	A,M		Get low value
006C  23                   119  	INX	H		Advance to next
006D  BB                   120  	CMP	E		Does it match?
006E  C2 73 00             121  	JNZ	?swit2		No, skip to next
0071  7E                   122  	MOV	A,M		Get high value
0072  BA                   123  	CMP	D		Does it match?
0073  23                   124  ?swit2	INX	H		Advance to next
0074  C2 62 00             125  	JNZ	?swit1		No try next
0077                       126  ** Value found, jump to label
0077  C5                   127  	PUSH	B		Save on stack
0078  C9                   128  	RET			Jump [SP++]
0079                       129  ** Value not found, use default
0079  7E                   130  ?swit3	MOV	A,M		Get low address
007A  23                   131  	INX	H		Advance to next
007B  66                   132  	MOV	H,M		Get high address
007C  6F                   133  	MOV	L,A		Include low address
007D  E9                   134  ?idcall	PCHL			Perform jump
007E                       135  * Negate: HL = -HL
007E  2B                   136  ?neg	DCX	H		Decrement for negate
007F                       137  * Complement: HL = ~HL
007F  7C                   138  ?com	MOV	A,H		Get high
0080  2F                   139  	CMA			Complement
0081  67                   140  	MOV	H,A		Replace value
0082  7D                   141  	MOV	A,L		Get low
0083  2F                   142  	CMA			Complement
0084  6F                   143  	MOV	L,A		Replace value
0085  C9                   144  	RET
0086                       145  * Logical NOT: HL = !HL
0086  7C                   146  ?not	MOV	A,H		Get high
0087  B5                   147  	ORA	L		Test for zero
0088  21 00 00             148  	LXI	H,0		Assume FALSE
008B  C0                   149  	RNZ			Yes, exit
008C  23                   150  	INX	H		Convert to TRUE
008D  C9                   151  	RET
008E                       152  * Subtract: HL = BC - HL
008E  79                   153  ?sub	MOV	A,C		Get low source
008F  95                   154  	SUB	L		Subtract low dest
0090  6F                   155  	MOV	L,A		And replace
0091  78                   156  	MOV	A,B		Get high source
0092  9C                   157  	SBB	H		Subtract high dest
0093  67                   158  	MOV	H,A		And replace
0094  C9                   159  	RET
0095                       160  * 16 bit multiply: HL = BC * HL
0095  D5                   161  ?mul	PUSH	D		Save index
0096  EB                   162  	XCHG			D = Dest
0097  21 00 00             163  	LXI	H,0		Begin with zero
009A  7B                   164  ?mul1	MOV	A,E		Get low dest
009B  0F                   165  	RRC			Test for odd value
009C  D2 A0 00             166  	JNC	?mul2		Not odd
009F  09                   167  	DAD	B		+ dest
00A0  A7                   168  ?mul2	ANA	A		Clear carry
00A1  7A                   169  	MOV	A,D		Get high dest
00A2  1F                   170  	RAR			/ 2
00A3  57                   171  	MOV	D,A		Replace
00A4  7B                   172  	MOV	A,E		Get low dest
00A5  1F                   173  	RAR			/ 2
00A6  5F                   174  	MOV	E,A		Replace
DUNFIELD 8085 ASSEMBLER: T_ADDR                                       PAGE: 4

00A7  B2                   175  	ORA	D		All done (zero)?
00A8  CA B5 00             176  	JZ	?mul3		Yes, exit
00AB  79                   177  	MOV	A,C		Get low source
00AC  17                   178  	RAL			* 2
00AD  4F                   179  	MOV	C,A		Replace
00AE  78                   180  	MOV	A,B		Get high source
00AF  17                   181  	RAL			* 2
00B0  47                   182  	MOV	B,A		Replace
00B1  B1                   183  	ORA	C		All done (zero)?
00B2  C2 9A 00             184  	JNZ	?mul1		No, keep going
00B5  D1                   185  ?mul3	POP	D		Restore index
00B6  C9                   186  	RET
00B7                       187  * 16 bit division: HL = BC / HL
00B7                       188  ?sdiv	EQU	*		Entry point for signed division
00B7  CD BD 00             189  ?div	CALL	?mod		Main calculation
00BA  60                   190  	MOV	H,B		Get high result
00BB  69                   191  	MOV	L,C		Get low result
00BC  C9                   192  	RET
00BD                       193  * 16 bit modulus: HL = BC % HL, BC = BC / HL
00BD                       194  ?smod	EQU	*		Entry point for signed modulus
00BD  D5                   195  ?mod	PUSH	D		Save index
00BE  EB                   196  	XCHG			DE = P1
00BF  21 00 00             197  	LXI	H,0		Begin with zero
00C2  3E 11                198  	MVI	A,17		16+1 bit shift
00C4  32 DA 01             199  	STA	?temp		Save for later
00C7  A7                   200  ?mod1	ANA	A		No carry in
00C8  79                   201  ?mod2	MOV	A,C		Get low source
00C9  17                   202  	RAL			Shift
00CA  4F                   203  	MOV	C,A		Replace
00CB  78                   204  	MOV	A,B		Get high source
00CC  17                   205  	RAL			16 bit Shift
00CD  47                   206  	MOV	B,A		Replace
00CE  3A DA 01             207  	LDA	?temp		Restore count
00D1  3D                   208  	DCR	A		Reduce count
00D2  CA F3 00             209  	JZ	?mod4		Finished, exit
00D5  32 DA 01             210  	STA	?temp		Resave count
00D8  7D                   211  	MOV	A,L		Get low dest
00D9  17                   212  	RAL			Shift in bit, result *2
00DA  6F                   213  	MOV	L,A		Replace
00DB  7C                   214  	MOV	A,H		Get high dest
00DC  17                   215  	RAL			16 bit shift
00DD  67                   216  	MOV	H,A		Replace
00DE  BA                   217  	CMP	D		Lower?
00DF  DA C7 00             218  	JC	?mod1		Yes, do again
00E2  7D                   219  	MOV	A,L		Lower?
00E3  C2 EA 00             220  	JNZ	?mod3		Higher, don't test low
00E6  BB                   221  	CMP	E		Yes, do again
00E7  DA C7 00             222  	JC	?mod1		Lower, go round again
00EA  93                   223  ?mod3	SUB	E		Subtract p1
00EB  6F                   224  	MOV	L,A		Resave
00EC  7C                   225  	MOV	A,H		Get high
00ED  9A                   226  	SBB	D		16 bit subtract
00EE  67                   227  	MOV	H,A		Resave
00EF  37                   228  	STC			Insure carry set
00F0  C3 C8 00             229  	JMP	?mod2		and proceed
00F3  D1                   230  ?mod4	POP	D		Restore index
00F4  C9                   231  	RET
00F5                       232  * Logical AND: HL = BC & HL
DUNFIELD 8085 ASSEMBLER: T_ADDR                                       PAGE: 5

00F5  79                   233  ?and	MOV	A,C		Get low source
00F6  A5                   234  	ANA	L		And with dest
00F7  6F                   235  	MOV	L,A		Replace
00F8  78                   236  	MOV	A,B		Get high source
00F9  A4                   237  	ANA	H		And with dest
00FA  67                   238  	MOV	H,A		Replace
00FB  C9                   239  	RET
00FC                       240  * Logical OR: HL = BC | HL
00FC  79                   241  ?or	MOV	A,C		Get low source
00FD  B5                   242  	ORA	L		Or with dest
00FE  6F                   243  	MOV	L,A		Replace
00FF  78                   244  	MOV	A,B		Get high source
0100  B4                   245  	ORA	H		Or with dest
0101  67                   246  	MOV	H,A		Replace
0102  C9                   247  	RET
0103                       248  * Exclusive OR: HL = BC ^ HL
0103  79                   249  ?xor	MOV	A,C		Get low source
0104  AD                   250  	XRA	L		Xor with dest
0105  6F                   251  	MOV	L,A		Replace
0106  78                   252  	MOV	A,B		Get high source
0107  AC                   253  	XRA	H		Xor with dest
0108  67                   254  	MOV	H,A		Replace
0109  C9                   255  	RET
010A                       256  * Shift right: HL = BC >> HL
010A  7C                   257  ?shr	MOV	A,H		Get value
010B  B5                   258  	ORA	L		Test for zero (special case)
010C  CA 1A 01             259  	JZ	?shr2		zero, exit
010F  A7                   260  ?shr1	ANA	A		Clear carry
0110  78                   261  	MOV	A,B		Get high
0111  1F                   262  	RAR			Shift it
0112  47                   263  	MOV	B,A		Replace
0113  79                   264  	MOV	A,C		Get low
0114  1F                   265  	RAR			Shift it
0115  4F                   266  	MOV	C,A		Replace
0116  2D                   267  	DCR	L		Reduce count
0117  C2 0F 01             268  	JNZ	?shr1		Do them all
011A  60                   269  ?shr2	MOV	H,B		Copy it
011B  69                   270  	MOV	L,C		Over
011C  C9                   271  	RET
011D                       272  * Shift left: HL = BC << HL
011D  7C                   273  ?shl	MOV	A,H		Get value
011E  B5                   274  	ORA	L		Test for zero (special case)
011F  CA 2D 01             275  	JZ	?shl2		zero, exit
0122  A7                   276  ?shl1	ANA	A		Clear carry
0123  79                   277  	MOV	A,C		Get high
0124  17                   278  	RAL			Shift it
0125  4F                   279  	MOV	C,A		Replace
0126  78                   280  	MOV	A,B		Get low
0127  17                   281  	RAL			Shift it
0128  47                   282  	MOV	B,A		Replace
0129  2D                   283  	DCR	L		Reduce count
012A  C2 22 01             284  	JNZ	?shl1		Do them all
012D  60                   285  ?shl2	MOV	H,B		Copy it
012E  69                   286  	MOV	L,C		Over
012F  C9                   287  	RET
0130                       288  * Conditional operators
0130  CD 7A 01             289  ?eq	CALL	?ucomp		BC == HL
0133  C8                   290  	RZ
DUNFIELD 8085 ASSEMBLER: T_ADDR                                       PAGE: 6

0134  2B                   291  	DCX	H
0135  C9                   292  	RET
0136  CD 7A 01             293  ?ne	CALL	?ucomp		BC != HL
0139  C0                   294  	RNZ
013A  2B                   295  	DCX	H
013B  C9                   296  	RET
013C  E5                   297  ?gt	PUSH	H		BC > HL (signed)
013D  60                   298  	MOV	H,B
013E  69                   299  	MOV	L,C
013F  C1                   300  	POP	B
0140  CD 6A 01             301  ?lt	CALL	?scomp		BC < HL (signed)
0143  D8                   302  	RC
0144  2B                   303  	DCX	H
0145  C9                   304  	RET
0146  CD 6A 01             305  ?le	CALL	?scomp		BC <= HL (signed)
0149  D8                   306  	RC
014A  C8                   307  	RZ
014B  2B                   308  	DCX	H
014C  C9                   309  	RET
014D  CD 6A 01             310  ?ge	CALL	?scomp		BC >= HL (signed)
0150  D0                   311  	RNC
0151  2B                   312  	DCX	H
0152  C9                   313  	RET
0153  E5                   314  ?ugt	PUSH	H		BC > HL (unsigned)
0154  60                   315  	MOV	H,B
0155  69                   316  	MOV	L,C
0156  C1                   317  	POP	B
0157  CD 7A 01             318  ?ult	CALL	?ucomp		BC < HL (unsigned)
015A  D8                   319  	RC
015B  2B                   320  	DCX	H
015C  C9                   321  	RET
015D  CD 7A 01             322  ?ule	CALL	?ucomp		BC <= HL (unsigned)
0160  D8                   323  	RC
0161  C8                   324  	RZ
0162  2B                   325  	DCX	H
0163  C9                   326  	RET
0164  CD 7A 01             327  ?uge	CALL	?ucomp		BC >= HL (unsigned)
0167  D0                   328  	RNC
0168  2B                   329  	DCX	H
0169  C9                   330  	RET
016A                       331  * Signed compare of BC & HL
016A  78                   332  ?scomp	MOV	A,B		Get HIGH #1
016B  AC                   333  	XRA	H		Sign same as #2?
016C  F2 7A 01             334  	JP	?ucomp		Handle as unsigned
016F  21 01 00             335  	LXI	H,1		Assume TRUE
0172  A0                   336  	ANA	B		Get sign #1
0173  FA 78 01             337  	JM	?scomp1		Less than #2
0176  B5                   338  	ORA	L		Clear 'C' and 'Z', greater than
0177  C9                   339  	RET
0178  37                   340  ?scomp1	STC			Set 'C', indicate less than
0179  C9                   341  	RET
017A                       342  * Unsigned compare of BC & HL
017A  78                   343  ?ucomp	MOV	A,B		Get high
017B  BC                   344  	CMP	H		Match?
017C  C2 81 01             345  	JNZ	?ucomp1		No, exit
017F  79                   346  	MOV	A,C		Get low
0180  BD                   347  	CMP	L		Set flags
0181  21 01 00             348  ?ucomp1	LXI	H,1		Assume TRUE
DUNFIELD 8085 ASSEMBLER: T_ADDR                                       PAGE: 7

0184  C9                   349  	RET
0185                       350  * Temporary location used by compiler and "?mod"
0185  C5                   351  main PUSH B
0186  C5                   352   PUSH B
0187  C5                   353   PUSH B
0188  C5                   354   PUSH B
0189  21 CE BE             355   LXI H,-16690
018C  01 02 00             356   LXI B,2
018F  CD 38 00             357   CALL ?pstkw
0192  21 AD FD             358   LXI H,-595
0195  01 04 00             359   LXI B,4
0198  CD 38 00             360   CALL ?pstkw
019B  21 00 80             361   LXI H,-32768
019E  01 06 00             362   LXI B,6
01A1  CD 38 00             363   CALL ?pstkw
01A4  21 02 80             364   LXI H,-32766
01A7  01 08 00             365   LXI B,8
01AA  CD 38 00             366   CALL ?pstkw
01AD  EB                   367   XCHG
01AE  21 06 00             368   LXI H,6
01B1  CD 2C 00             369   CALL ?gstkw
01B4  EB                   370   XCHG
01B5  21 02 00             371   LXI H,2
01B8  CD 2C 00             372   CALL ?gstkw
01BB  CD 4A 00             373   CALL ?pind_d
01BE  EB                   374   XCHG
01BF  21 08 00             375   LXI H,8
01C2  CD 2C 00             376   CALL ?gstkw
01C5  EB                   377   XCHG
01C6  21 04 00             378   LXI H,4
01C9  CD 2C 00             379   CALL ?gstkw
01CC  CD 4A 00             380   CALL ?pind_d
01CF                       381  ?AB1 EQU *
01CF  C3 CF 01             382   JMP ?AB1
01D2                       383  ?AB2 EQU *
01D2  21 00 00             384   LXI H,0
01D5                       385  ?AB3 EQU *
01D5  C1                   386   POP B
01D6  C1                   387   POP B
01D7  C1                   388   POP B
01D8  C1                   389   POP B
01D9  C9                   390   RET
01DA                       391  *#map1 Set address of un-initialized variables
01DA                       392  * If you are compiling for ROM, uncomment the following ORG statement,
01DA                       393  * and adjust its address to the beginning of available RAM.
01DA                       394  *	ORG	$xxxx		RAM begins here
01DA                       395  ?temp DS 2
01DC                       396  * Begin the system heap following all other & data
01DC                       397  ?heap	EQU	*
