DDS MICRO-C 8085 Runtime Library is currently configured as follows:

(Demo system is MMT-85 Single Board Computer from Midwest Micro-Tek)

MEMORY:
	RAM ONLY: Starting at $4000 and ending at $5FFF
	To change start address, modify 'ORG' at beginning of 8085RLP.ASM
	To change ending address, modify 'LXI SP' at beginning of 8085RLP.ASM

	To set up for split ROM/RAM operation, set 'ORG' in 8085RLP.ASM to
	beginning of ROM, and 'LXI SP' to end of RAM. Then modify 8085RLM.ASM
	to contain an 'ORG' to the beginning of RAM. See 'Compiling for ROM'
	in the MICRO-C Technical manual.

CONSOLE:
	External 8251 uart device, baudrate clock is generated by TIMER2 of
	an 8254 counter/timer chip.
		8251: Data=$80, Control/Status=$81
		8254: Timer0=$88, Timer1=$89, Timer2=$8A, Control=$8B
	All addresses are I/O mapped (IN/OUT instructions).
	For other device types, replace the code in SERINIT.ASM, SERIO.ASM,
	and RAWIO.ASM

If you are using INTERRUPTS, check out the 8085RL*.ASM file(s) to make sure
that space is available for the interrupt vectors. Also, see the file
8085INT.H for information on defining interrupt handling functions in C.
Make sure you READ THE COMMENTS in this file carefully, and understand how
it works. Note that you may have to modify the interrupt vector addresses
passed to the INTERRUPT macro when compiling for a debug system or a "raw"
system.

***IMPORTANT*** If you edit the .LIB file(s) directly, MAKE SURE that you
(or your editor) do not remove the trailing space from any line beginning
with '$'. Many 3rd party editors automatically remove trailing spaces. If
in doubt, use my EDT or DDSIDE (included with this package).

NOTE: A useful exercise to help understand the compiler/linkers usage of
memory is to compile the following program with the -CL options, and view
the resulting .LST file:

To gain a better understanding of the source linker and it's directives,
compile the program again with the -AC options, and look at the segment
directives in the .ASM output file, matching the output with the final
code in the first listing.

------------------------------ CUT HERE ----------------------------------
char init_global[5] = { 1, 2, 3, 4, 5 };
char uninit_global[5];

// Compilers for CPU's with on-chip internal memory use "register" to force
// a global (or static) variable to be allocated therein. For other CPU's,
// this will be treated the same as any uninitialized global.
register char register_global[5];

main()
{
	unsigned local_auto;
	static unsigned local_static;

	// Access locals to identify, as symbol names are lost in listing
	local_auto;
	local_static;

	// Call a library function to demonstrate linking of library
	putstr("Hello world");
}
