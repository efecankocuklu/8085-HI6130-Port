###############################################################################
#                                                                             #
#                                                       05/Jun/2012  15:22:01 #
# IAR ANSI C/C++ Compiler V6.21.1.32794/W32 KICKSTART for ARM                 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Program Files\IAR Systems\Embedded Workbench 6.0      #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\613x_bc.c                        #
#    Command line =  "C:\Program Files\IAR Systems\Embedded Workbench 6.0     #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\613x_bc.c" -D at91sam3u4 -D      #
#                    flash -D TRACE_LEVEL=4 -D BC_ena=1 -D RT2_ena=1 -D       #
#                    RT1_ena=1 -D SMT_ena=1 -D IMT_ena=0 -lC "C:\Program      #
#                    Files\IAR Systems\Embedded Workbench 6.0                 #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\ewp\BC_SMT_RT\List\" --remarks   #
#                    --diag_suppress Pe826,Pe1375,Pe068 -o "C:\Program        #
#                    Files\IAR Systems\Embedded Workbench 6.0                 #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\ewp\BC_SMT_RT\Obj\" --no_cse     #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench 6.0                 #
#                    Kickstart_2\arm\INC\c\DLib_Config_Full.h" -I             #
#                    "C:\Program Files\IAR Systems\Embedded Workbench 6.0     #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\ewp\..\..\..\at91lib/peripherals #
#                    \" -I "C:\Program Files\IAR Systems\Embedded Workbench   #
#                    6.0 Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt    #
#                    HI-6130-40 EBI Demo 2_0\ewp\..\..\..\at91lib/components\ #
#                    " -I "C:\Program Files\IAR Systems\Embedded Workbench    #
#                    6.0 Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt    #
#                    HI-6130-40 EBI Demo 2_0\ewp\..\..\..\at91lib\" -I        #
#                    "C:\Program Files\IAR Systems\Embedded Workbench 6.0     #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\ewp\..\..\..\external_libs\" -I  #
#                    "C:\Program Files\IAR Systems\Embedded Workbench 6.0     #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\ewp\..\..\..\at91lib/boards/at91 #
#                    sam3u-ek\" --cpu_mode thumb -On --use_c++_inline         #
#    List file    =  C:\Program Files\IAR Systems\Embedded Workbench 6.0      #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\ewp\BC_SMT_RT\List\613x_bc.lst   #
#    Object file  =  C:\Program Files\IAR Systems\Embedded Workbench 6.0      #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\ewp\BC_SMT_RT\Obj\613x_bc.o      #
#                                                                             #
#                                                                             #
###############################################################################

C:\Program Files\IAR Systems\Embedded Workbench 6.0 Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt HI-6130-40 EBI Demo 2_0\613x_bc.c
      1          /* ----------------------------------------------------------------------------
      2           *                            HOLT Integrated Circuits 
      3           * ----------------------------------------------------------------------------
      4           *
      5           *    file	613x_bc.c
      6           *    brief     This file contains initialization functions and arrays for 
      7           *		initializing BC register and RAM tables inside the Holt  
      8           *		HI-6130 or HI-6131 device. 
      9           *
     10           *		IMPORTANT: Edit file 613x_initialization.h to define either:
     11           *
     12           *		HOST_BUS_INTERFACE  YES  sets compilation for HI-6130 (bus)
     13           *		 		    NO   sets compilation for HI-6131 (SPI)
     14           *
     15           *		Most functional procedures in this project are written for
     16           *		both parallel bus or SPI host interface schemes, this runtime 
     17           *		switch determines which are procedures are compiled.
     18           * 
     19           *
     20           *	   	HOLT DISCLAIMER
     21           *      	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY 
     22           *      	KIND, EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE 
     23           *      	WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
     24           *      	PURPOSE AND NONINFRINGEMENT. 
     25           *      	IN NO EVENT SHALL HOLT, INC BE LIABLE FOR ANY CLAIM, DAMAGES
     26           *      	OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
     27           *      	OTHERWISE,ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
     28           *      	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
     29           *
     30           *              Copyright (C) 2009-2011 by  HOLT, Inc.
     31           *              All Rights Reserved
     32           */
     33          
     34          
     35          //------------------------------------------------------------------------------
     36          //         Headers
     37          //------------------------------------------------------------------------------
     38          
     39          // standard Atmel/IAR headers
     40          #include <pio/pio.h>
     41          #include <intrinsics.h>
     42          #include <spi/spi.h>
     43          
     44          // Holt project headers
     45          #include "613x_initialization.h"
     46          #include "613x_regs.h"
     47          #include "613x_bc.h"
     48          #include "board_613x.h"
     49          
     50          #include "board_6130.h"
     51          #include "device_6130.h"
     52          extern const H6130 pH6130;
     53          extern GPQ pGPQ;
     54          extern const BCil pBCil;
     55          extern const BCstack pBCstack; 
     56          extern const BCstack2RT pBCstack2RT; 
     57          
     58          
     59          //------------------------------------------------------------------------------
     60          //         Functions
     61          //------------------------------------------------------------------------------
     62          
     63          // IMPORTANT: NEXT FUNCTION'S EXAMPLES ONLY APPLY TO HI-6130 NOT TO HI-6131!
     64          

   \                                 In section .text, align 2, keep-with-next
     65          void BC_bus_addressing_examples(void) {
     66            
     67              unsigned short j,k;  
     68            
     69              // -----------------------------------------------------
     70              // 64-word BC General Purpose Queue addressing examples
     71              // -----------------------------------------------------
     72              // using array pointer declared in 613x_bc.h
     73              // queue base address declared/initialized as global const
     74                  
     75              (*pGPQ)[0] = 0x0123;         // write general purpose queue word 0
   \                     BC_bus_addressing_examples:
   \   00000000   ........           LDR.W    R2,??DataTable10
   \   00000004   1268               LDR      R2,[R2, #+0]
   \   00000006   40F22313           MOVW     R3,#+291
   \   0000000A   1380               STRH     R3,[R2, #+0]
     76              (*pGPQ)[1] = 0x4567;         // write general purpose queue word 1
   \   0000000C   ........           LDR.W    R2,??DataTable10
   \   00000010   1268               LDR      R2,[R2, #+0]
   \   00000012   44F26753           MOVW     R3,#+17767
   \   00000016   5380               STRH     R3,[R2, #+2]
     77              (*pGPQ)[2] = 0x89AB;         // write general purpose queue word 2
   \   00000018   ........           LDR.W    R2,??DataTable10
   \   0000001C   1268               LDR      R2,[R2, #+0]
   \   0000001E   48F6AB13           MOVW     R3,#+35243
   \   00000022   9380               STRH     R3,[R2, #+4]
     78              k = (*pGPQ)[2];              // read general purpose queue word 2
   \   00000024   ........           LDR.W    R2,??DataTable10
   \   00000028   1268               LDR      R2,[R2, #+0]
   \   0000002A   9288               LDRH     R2,[R2, #+4]
   \   0000002C   1100               MOVS     R1,R2
     79                
     80              // or, using a macro, GPQ(n) defined as (*pGPQ)[n] where n = 0 to 63
     81              k = GPQ(25);                  // read general purpose queue word 25
   \   0000002E   ........           LDR.W    R2,??DataTable10
   \   00000032   1268               LDR      R2,[R2, #+0]
   \   00000034   528E               LDRH     R2,[R2, #+50]
   \   00000036   1100               MOVS     R1,R2
     82              GPQ(2) = 0xAB89;              // write general purpose queue word 2
   \   00000038   ........           LDR.W    R2,??DataTable10
   \   0000003C   1268               LDR      R2,[R2, #+0]
   \   0000003E   4AF68933           MOVW     R3,#+43913
   \   00000042   9380               STRH     R3,[R2, #+4]
     83                
     84              // ----------------------------------------
     85              // BC Instruction List addressing examples
     86              // ----------------------------------------
     87              // using pointer to array of 2-word structs (declared in 613x_bc.h)
     88              // instruction list base address is declared in file 613x_bc.h
     89                
     90              (*pBCil)[0].opCode = 0xD14F;     // write op code word for operation 0 in BC instruction list
   \   00000044   ........           LDR.W    R2,??DataTable10_1
   \   00000048   1268               LDR      R2,[R2, #+0]
   \   0000004A   4DF24F13           MOVW     R3,#+53583
   \   0000004E   1380               STRH     R3,[R2, #+0]
     91              (*pBCil)[0].param = 0x6789;      // write parameter word for operation 0 in BC instruction list
   \   00000050   ........           LDR.W    R2,??DataTable10_1
   \   00000054   1268               LDR      R2,[R2, #+0]
   \   00000056   46F28973           MOVW     R3,#+26505
   \   0000005A   5380               STRH     R3,[R2, #+2]
     92              j = (*pBCil)[1].opCode;          // read op code word for operation 1 in BC instruction list
   \   0000005C   ........           LDR.W    R2,??DataTable10_1
   \   00000060   1268               LDR      R2,[R2, #+0]
   \   00000062   9288               LDRH     R2,[R2, #+4]
   \   00000064   1000               MOVS     R0,R2
     93              k = (*pBCil)[1].param;           // write parameter word for operation 1 in BC instruction list
   \   00000066   ........           LDR.W    R2,??DataTable10_1
   \   0000006A   1268               LDR      R2,[R2, #+0]
   \   0000006C   D288               LDRH     R2,[R2, #+6]
   \   0000006E   1100               MOVS     R1,R2
     94          
     95              // or, using a macro, ILIST(n) defined as (*pBCil)[n]
     96              ILIST(0).param = 0x0000;         // write parameter word for operation 0 in BC instruction list
   \   00000070   ........           LDR.W    R2,??DataTable10_1
   \   00000074   1268               LDR      R2,[R2, #+0]
   \   00000076   0023               MOVS     R3,#+0
   \   00000078   5380               STRH     R3,[R2, #+2]
     97              j = ILIST(1).opCode;             // read op code word for operation 1 in BC instruction list
   \   0000007A   ........           LDR.W    R2,??DataTable10_1
   \   0000007E   1268               LDR      R2,[R2, #+0]
   \   00000080   9288               LDRH     R2,[R2, #+4]
   \   00000082   1000               MOVS     R0,R2
     98          
     99              
    100              // ------------------------------------------------------------
    101              // BC Message Stack for non-RT-RT messages, addressing examples 
    102              // ------------------------------------------------------------
    103              // BC Message Stack for non-RT-RT messages is comprised of 8-word message blocks. 
    104              // The index, for example [0], is the message number in the stack. Message order of
    105              // execution is determined by the BC instruction list (not index number) and jumps
    106              // between this non-RT-RT message stack and the RT-RT stack...
    107              // The message stack base address is declared in file 613x_bc.h
    108                
    109              k = (*pBCstack)[0].ctrlWord;      // read nonRTRT msg 0 control word
   \   00000084   ........           LDR.W    R2,??DataTable10_2
   \   00000088   1268               LDR      R2,[R2, #+0]
   \   0000008A   1288               LDRH     R2,[R2, #+0]
   \   0000008C   1100               MOVS     R1,R2
    110              j = (*pBCstack)[0].cmdWord;       // read nonRTRT msg 0 command word
   \   0000008E   ........           LDR.W    R2,??DataTable10_2
   \   00000092   1268               LDR      R2,[R2, #+0]
   \   00000094   5288               LDRH     R2,[R2, #+2]
   \   00000096   1000               MOVS     R0,R2
    111              k = (*pBCstack)[1].dataPtr;       // read data pointer for nonRTRT msg 1
   \   00000098   ........           LDR.W    R2,??DataTable10_2
   \   0000009C   1268               LDR      R2,[R2, #+0]
   \   0000009E   928A               LDRH     R2,[R2, #+20]
   \   000000A0   1100               MOVS     R1,R2
    112              (*pBCstack)[3].timeNextMsg = 500; // write nonRTRT msg 3 time-to-next-msg = 500us
   \   000000A2   ........           LDR.W    R2,??DataTable10_2
   \   000000A6   1268               LDR      R2,[R2, #+0]
   \   000000A8   4FF4FA73           MOV      R3,#+500
   \   000000AC   D386               STRH     R3,[R2, #+54]
    113              j = (*pBCstack)[1].blockStatus;   // read nonRTRT msg 1 block status word
   \   000000AE   ........           LDR.W    R2,??DataTable10_2
   \   000000B2   1268               LDR      R2,[R2, #+0]
   \   000000B4   528B               LDRH     R2,[R2, #+26]
   \   000000B6   1000               MOVS     R0,R2
    114              j = (*pBCstack)[1].RTstatus;      // read nonRTRT msg 1 RT status word
   \   000000B8   ........           LDR.W    R2,??DataTable10_2
   \   000000BC   1268               LDR      R2,[R2, #+0]
   \   000000BE   D28B               LDRH     R2,[R2, #+30]
   \   000000C0   1000               MOVS     R0,R2
    115                
    116              #ifndef BC_TTAG_HI_RES            // BC IS USING 16-BIT TIME BASE
    117              k = (*pBCstack)[0].timetag;       // read nonRTRT msg 0 16-bit time tag (16-bit timebase)
    118              k = (*pBCstack)[3].loopbackWord;  // read nonRTRT msg 3 block loopback word (16-bit timebase)
    119                
    120              #else // ifdef BC_TTAG_HI_RES     // BC IS USING 32-BIT TIME BASE
    121              j = (*pBCstack)[0].ttagLow;       // read nonRTRT msg 0 32-bit time tag count LOW 1 bits
   \   000000C2   ........           LDR.W    R2,??DataTable10_2
   \   000000C6   1268               LDR      R2,[R2, #+0]
   \   000000C8   1289               LDRH     R2,[R2, #+8]
   \   000000CA   1000               MOVS     R0,R2
    122              k = (*pBCstack)[0].ttagHigh;      // read nonRTRT msg 0 32-bit time tag count HIGH 16 bits
   \   000000CC   ........           LDR.W    R2,??DataTable10_2
   \   000000D0   1268               LDR      R2,[R2, #+0]
   \   000000D2   9289               LDRH     R2,[R2, #+12]
   \   000000D4   1100               MOVS     R1,R2
    123              #endif // ifdef BC_TTAG_HI_RES 
    124          
    125              // or, using a macro, MSTAK(n) defined as (*pBCstack)[n]
    126              MSTAK(3).timeNextMsg = 500;       // write nonRTRT msg 3 time-to-next-msg = 500us
   \   000000D6   ........           LDR.W    R2,??DataTable10_2
   \   000000DA   1268               LDR      R2,[R2, #+0]
   \   000000DC   4FF4FA73           MOV      R3,#+500
   \   000000E0   D386               STRH     R3,[R2, #+54]
    127              j = MSTAK(1).blockStatus;         // read nonRTRT msg 1 block status word
   \   000000E2   ........           LDR.W    R2,??DataTable10_2
   \   000000E6   1268               LDR      R2,[R2, #+0]
   \   000000E8   528B               LDRH     R2,[R2, #+26]
   \   000000EA   1000               MOVS     R0,R2
    128                
    129              // --------------------------------------------------------
    130              // BC Message Stack for RT-RT messages, addressing examples
    131              // --------------------------------------------------------
    132              // BC Message Stack for RT-RT messages is comprised of 16-word message blocks (6 dummy words). 
    133              // The index, for example [0], is the message number in the stack. Message order of
    134              // execution is determined by the BC instruction list (not index number) and jumps
    135              // between this RT-RT message stack and the non-RT-RT stack...
    136              // The message stack base address is declared in file 613x_bc.h
    137                
    138              k = (*pBCstack2RT)[0].ctrlWord;      // read RT-RT msg 0 control word
   \   000000EC   ........           LDR.W    R2,??DataTable10_3
   \   000000F0   1268               LDR      R2,[R2, #+0]
   \   000000F2   1288               LDRH     R2,[R2, #+0]
   \   000000F4   1100               MOVS     R1,R2
    139              j = (*pBCstack2RT)[1].RxCmdWord;     // read RT-RT msg 1 Rx command word (1)
   \   000000F6   ........           LDR.W    R2,??DataTable10_3
   \   000000FA   1268               LDR      R2,[R2, #+0]
   \   000000FC   528C               LDRH     R2,[R2, #+34]
   \   000000FE   1000               MOVS     R0,R2
    140              k = (*pBCstack2RT)[1].TxCmdWord;     // read RT-RT msg 1 Tx command word (2)
   \   00000100   ........           LDR.W    R2,??DataTable10_3
   \   00000104   1268               LDR      R2,[R2, #+0]
   \   00000106   128E               LDRH     R2,[R2, #+48]
   \   00000108   1100               MOVS     R1,R2
    141              j = (*pBCstack2RT)[1].dataPtr;       // read data pointer for RT-RT msg 1
   \   0000010A   ........           LDR.W    R2,??DataTable10_3
   \   0000010E   1268               LDR      R2,[R2, #+0]
   \   00000110   928C               LDRH     R2,[R2, #+36]
   \   00000112   1000               MOVS     R0,R2
    142              (*pBCstack2RT)[1].timeNextMsg = 500; // write RT-RT msg 1 time-to-next-msg = 500us
   \   00000114   ........           LDR.W    R2,??DataTable10_3
   \   00000118   1268               LDR      R2,[R2, #+0]
   \   0000011A   4FF4FA73           MOV      R3,#+500
   \   0000011E   D384               STRH     R3,[R2, #+38]
    143              j = (*pBCstack2RT)[1].blockStatus;   // read RT-RT msg 1 block status word
   \   00000120   ........           LDR.W    R2,??DataTable10_3
   \   00000124   1268               LDR      R2,[R2, #+0]
   \   00000126   528D               LDRH     R2,[R2, #+42]
   \   00000128   1000               MOVS     R0,R2
    144              k = (*pBCstack2RT)[1].TxRTstatus;    // read RT-RT msg 1 transmit RT status word
   \   0000012A   ........           LDR.W    R2,??DataTable10_3
   \   0000012E   1268               LDR      R2,[R2, #+0]
   \   00000130   D28D               LDRH     R2,[R2, #+46]
   \   00000132   1100               MOVS     R1,R2
    145              j = (*pBCstack2RT)[1].RxRTstatus;    // read RT-RT msg 1 receiving RT status word
   \   00000134   ........           LDR.W    R2,??DataTable10_3
   \   00000138   1268               LDR      R2,[R2, #+0]
   \   0000013A   528E               LDRH     R2,[R2, #+50]
   \   0000013C   1000               MOVS     R0,R2
    146                
    147              #ifndef BC_TTAG_HI_RES               // BC IS USING 16-BIT TIME BASE
    148              k = (*pBCstack2RT)[1].timetag;       // read RT-RT msg 0 16-bit time tag (16-bit timebase)
    149              k = (*pBCstack2RT)[1].loopbackWord;  // read RT-RT msg 3 block loopback word (16-bit timebase)
    150                
    151              #else // ifdef BC_TTAG_HI_RES        // BC IS USING 32-BIT TIME BASE
    152              j = (*pBCstack2RT)[0].ttagLow;       // read RT-RT msg 0 32-bit time tag count LOW 16 bits
   \   0000013E   ........           LDR.W    R2,??DataTable10_3
   \   00000142   1268               LDR      R2,[R2, #+0]
   \   00000144   1289               LDRH     R2,[R2, #+8]
   \   00000146   1000               MOVS     R0,R2
    153              k = (*pBCstack2RT)[0].ttagHigh;      // read RT-RT msg 0 32-bit time tag count HIGH 16 bits
   \   00000148   ........           LDR.W    R2,??DataTable10_3
   \   0000014C   1268               LDR      R2,[R2, #+0]
   \   0000014E   9289               LDRH     R2,[R2, #+12]
   \   00000150   1100               MOVS     R1,R2
    154              #endif // ifdef BC_TTAG_HI_RES 
    155          
    156              // or, using a macro, MSTAK2RT(n) defined as (*pBCstack2RT)[n]
    157              j = MSTAK2RT(1).dataPtr;             // read data pointer for RT-RT msg 1
   \   00000152   ........           LDR.W    R2,??DataTable10_3
   \   00000156   1268               LDR      R2,[R2, #+0]
   \   00000158   928C               LDRH     R2,[R2, #+36]
   \   0000015A   1000               MOVS     R0,R2
    158              MSTAK2RT(1).timeNextMsg = 500;       // write RT-RT msg 1 time-to-next-msg = 500us
   \   0000015C   ........           LDR.W    R2,??DataTable10_3
   \   00000160   1268               LDR      R2,[R2, #+0]
   \   00000162   4FF4FA73           MOV      R3,#+500
   \   00000166   D384               STRH     R3,[R2, #+38]
    159              
    160              // preempt warnings: variable was set but never used
    161              j=j;
    162              k=k;    
    163              
    164          }   // end BC_bus_addressing_examples(void) 
   \   00000168   7047               BX       LR               ;; return
    165          
    166          
    167          // the initialization functions below do not use the addressing methods shown above.
    168          // instead, they demonstrate alternative addressing methods...
    169          
    170          

   \                                 In section .text, align 2, keep-with-next
    171          void initialize_bc_instruction_list(void) {
   \                     initialize_bc_instruction_list:
   \   00000000   2DE9F041           PUSH     {R4-R8,LR}
   \   00000004   97B0               SUB      SP,SP,#+92
    172            
    173          	unsigned short i, j, len;
    174                                  
    175                  const unsigned int base_6130 = 0x60000000;
   \   00000006   5FF0C047           MOVS     R7,#+1610612736
    176                  unsigned int addr;
    177                  
    178          	unsigned short inst_list[46] = {
    179          	// test op codes WTG,XEQ,JMP, verify various msg block setups
    180          	WTG|ALWAYS, 0x0000,			// wait for ext trigger, addr = BC_ILIST_BASE_ADDR = 0x1B70 
    181          	XEQ|ALWAYS, MSG_BLK1_ADDR,		// 1
    182          	WTG|ALWAYS, 0x0000,			// wait for ext trigger
    183          	XEQ|ALWAYS, MSG_BLK2_ADDR,		// 2
    184          	WTG|ALWAYS, 0x0000,			// wait for ext trigger
    185          	XEQ|ALWAYS, MSG_BLK3_ADDR,		// 3
    186          	WTG|ALWAYS, 0x0000,			// wait for ext trigger
    187          	XEQ|ALWAYS, MSG_BLK4_ADDR,		// 4
    188          	WTG|ALWAYS, 0x0000,			// wait for ext trigger
    189          	XEQ|ALWAYS, MSG_BLK5_ADDR,		// 5
    190          	WTG|ALWAYS, 0x0000,			// wait for ext trigger
    191          	XEQ|ALWAYS, MSG_BLK6_ADDR,		// 6
    192          	WTG|ALWAYS, 0x0000,			// wait for ext trigger
    193          	XEQ|ALWAYS, MSG_BLK7_ADDR,		// 7
    194          	WTG|ALWAYS, 0x0000,			// wait for ext trigger
    195          	XEQ|ALWAYS, MSG_BLK8_ADDR,		// 8 
    196          	WTG|ALWAYS, 0x0000,			// wait for ext trigger
    197          	XEQ|ALWAYS, RTRT_MSG_BLK1_ADDR,		// RT-RT 1
    198          	WTG|ALWAYS, 0x0000,			// wait for ext trigger
    199          	XEQ|ALWAYS, RTRT_MSG_BLK2_ADDR,		// RT-RT 2
    200          	WTG|ALWAYS, 0x0000,			// wait for ext trigger
    201          	XEQ|ALWAYS, MSG_BLK2_ADDR,		// 2
    202          	JMP|ALWAYS, BC_ILIST_BASE_ADDR };	// loop to top 
   \   0000000A   00A8               ADD      R0,SP,#+0
   \   0000000C   ........           LDR.W    R1,??DataTable10_4
   \   00000010   5C22               MOVS     R2,#+92
   \   00000012   ........           BL       __aeabi_memcpy4
    203          
    204                  
    205                  // copy BC Instruction List (above) to RAM...
    206                                     
    207                      // instruction list array size, 16-bit words
    208                      len = sizeof(inst_list) / sizeof(short int);
   \   00000016   2E20               MOVS     R0,#+46
   \   00000018   0600               MOVS     R6,R0
    209                      
    210                      // set the instruction list start address.
    211                      // BC_ILIST_BASE_ADDR is defined in file 613x_bc.h 
    212                      pH6130->BC_INST_LIST_BASE_ADDR_REG = BC_ILIST_BASE_ADDR;
   \   0000001A   ........           LDR.W    R0,??DataTable10_5
   \   0000001E   0068               LDR      R0,[R0, #+0]
   \   00000020   41F67031           MOVW     R1,#+7024
   \   00000024   A0F86610           STRH     R1,[R0, #+102]
    213              
    214                      // using the address just written into the base address register,
    215                      // copy the BC Instruction List (declared above) into the HI-6130 RAM. 
    216                         
    217                      //  set up the address pointer, left-shift the list start address
    218                      addr = base_6130 + (BC_ILIST_BASE_ADDR << 1);	
   \   00000028   07F55850           ADD      R0,R7,#+13824
   \   0000002C   E030               ADDS     R0,R0,#+224
   \   0000002E   8046               MOV      R8,R0
    219                         
    220                      // write instruction list
    221                      for ( i = 0; i < len; i += 2) {
   \   00000030   0020               MOVS     R0,#+0
   \   00000032   0400               MOVS     R4,R0
   \                     ??initialize_bc_instruction_list_0:
   \   00000034   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000036   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000038   B442               CMP      R4,R6
   \   0000003A   32D2               BCS.N    ??initialize_bc_instruction_list_1
    222              
    223                          // add the validation field and odd parity bit,
    224                          // and write the adjusted op code word. 
    225                          j = inst_list[i];
   \   0000003C   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000003E   00A8               ADD      R0,SP,#+0
   \   00000040   30F81400           LDRH     R0,[R0, R4, LSL #+1]
   \   00000044   0500               MOVS     R5,R0
    226                          // the next 4 lines determine odd parity 			
    227                          j ^= j>>8;
   \   00000046   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000048   95EA1525           EORS     R5,R5,R5, LSR #+8
    228                          j ^= j>>4;
   \   0000004C   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004E   95EA1515           EORS     R5,R5,R5, LSR #+4
    229                          j &= 0xF;
   \   00000052   15F00F05           ANDS     R5,R5,#0xF
    230                          if (!((0x6996 >> j) & 1))  { 
   \   00000056   46F69610           MOVW     R0,#+27030
   \   0000005A   2841               ASRS     R0,R0,R5
   \   0000005C   C007               LSLS     R0,R0,#+31
   \   0000005E   0AD4               BMI.N    ??initialize_bc_instruction_list_2
    231                              // write the op code word with parity bit 15 = 1
    232                              j = inst_list[i] + VP1;
   \   00000060   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000062   00A8               ADD      R0,SP,#+0
   \   00000064   30F81400           LDRH     R0,[R0, R4, LSL #+1]
   \   00000068   47F6C061           MOVW     R1,#+32448
   \   0000006C   401A               SUBS     R0,R0,R1
   \   0000006E   0500               MOVS     R5,R0
    233                              *((volatile unsigned short *)(addr)) = j;
   \   00000070   A8F80050           STRH     R5,[R8, #+0]
   \   00000074   08E0               B.N      ??initialize_bc_instruction_list_3
    234                          }
    235                          else {
    236                              // write the op code word with parity bit 15 = 0
    237                              j = inst_list[i] + VP0;
   \                     ??initialize_bc_instruction_list_2:
   \   00000076   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000078   00A8               ADD      R0,SP,#+0
   \   0000007A   30F81400           LDRH     R0,[R0, R4, LSL #+1]
   \   0000007E   00F24010           ADDW     R0,R0,#+320
   \   00000082   0500               MOVS     R5,R0
    238                              *((volatile unsigned short *)(addr)) = j;
   \   00000084   A8F80050           STRH     R5,[R8, #+0]
    239                          }
    240              
    241                          addr += 2;
   \                     ??initialize_bc_instruction_list_3:
   \   00000088   18F10208           ADDS     R8,R8,#+2
    242                          // write parameter word that goes with just-written op code 
    243                          *((volatile unsigned short *)(addr)) = inst_list[i+1];
   \   0000008C   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000008E   00A8               ADD      R0,SP,#+0
   \   00000090   10EB4400           ADDS     R0,R0,R4, LSL #+1
   \   00000094   4088               LDRH     R0,[R0, #+2]
   \   00000096   A8F80000           STRH     R0,[R8, #+0]
    244                          addr += 2;
   \   0000009A   18F10208           ADDS     R8,R8,#+2
    245                      }
   \   0000009E   A41C               ADDS     R4,R4,#+2
   \   000000A0   C8E7               B.N      ??initialize_bc_instruction_list_0
    246                
    247          }	// end initialize_bc_instruction_list()
   \                     ??initialize_bc_instruction_list_1:
   \   000000A2   17B0               ADD      SP,SP,#+92
   \   000000A4   BDE8F081           POP      {R4-R8,PC}       ;; return
    248          
    249          
    250          
    251          // 	Next function initializes ten HI-613x Bus Controller Control/Status Blocks 
    252          //      for test purposes, and initializes BC transmit data buffers used with RT receive commands. 
    253          //
    254          //	Msg Block 1  = Subaddress Tx  Command 03-1-30-00 (loopback subaddress) Bus A
    255          //	Msg Block 2  = Subaddress Tx  Command 03-1-30-00 (loopback subaddress) Bus B
    256          //	Msg Block 3  = Subaddress Rx  Command 03-0-30-00 (loopback subaddress) Bus A
    257          //	Msg Block 4  = Subaddress BRx Command 31-0-05-11                       Bus B
    258          //	Msg Block 5  = Subaddress BRx Command 31-0-30-00 (loopback subaddress) Bus A
    259          //	Msg Block 6  = Mode Code  Tx  Command 03-1-31-02 (tx mode code 2)      Bus B
    260          //	Msg Block 7  = Mode Code  Tx  Command 03-1-31-18 (tx mode code 18)     Bus A
    261          //	Msg Block 8  = Mode Code  Rx  Command 03-0-31-21 (rx mode code 21)     Bus B
    262          //      RT-RT Msg Block 1 = RT-RT msg Commands 04-0-30-02 03-1-05-02           Bus A
    263          //      RT-RT Msg Block 2 = BRT-RT msg Commands 31-0-30-11 04-1-05-11          Bus B
    264          // 
    265           

   \                                 In section .text, align 2, keep-with-next
    266          void initialize_bc_msg_blocks(void) {
   \                     initialize_bc_msg_blocks:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   C0B0               SUB      SP,SP,#+256
    267          	
    268                  const unsigned int base_6130 = 0x60000000;
   \   00000004   5FF0C044           MOVS     R4,#+1610612736
    269                  unsigned int addr;
    270                  
    271          	unsigned short i;
    272          	unsigned short data[32] = {0x0101,0x0202,0x0303,0x0404,0x0505,0x0606,0x0707,0x0808,
    273          			      0x0909,0x1010,0x1111,0x1212,0x1313,0x1414,0x1515,0x1616,
    274          			      0x1717,0x1818,0x1919,0x2020,0x2121,0x2222,0x2323,0x2424,
    275          			      0x2525,0x2626,0x2727,0x2828,0x2929,0x3030,0x3131,0x3232};
   \   00000008   30A8               ADD      R0,SP,#+192
   \   0000000A   ........           LDR.W    R1,??DataTable10_6
   \   0000000E   4022               MOVS     R2,#+64
   \   00000010   ........           BL       __aeabi_memcpy4
    276          	//unsigned short data[32] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    277          
    278          
    279                  // ********************************************************************************
    280                  // Msg Block 1  = Subaddress Tx  Command 03-1-30-00 (loopback subaddress) Bus A
    281                  
    282          	unsigned short msg_block1[8] = {
    283          	//  Contro1 Word Options = TXTTMC17|MEMASK|SRQMASK|BSYMASK|SSFMASK|TFMASK|RSVMASK
    284          	//			   |RTRYENA|USEBUSA|USEBUSB|SFTEST|MSKBCR|EOMINT|MCODE|BCST|RT_RT 
    285          	//  Contro1 Word          
    286          	    RTRYENA|MEMASK|USEBUSA,
    287          
    288          	//  Command Word (Transmit Command, RT --> BC )
    289          	//  RT Addr Tx/Rx  SubAdd  WordCt 
    290          	    3<<11  | TX  | 30<<5 | 0,
    291          
    292          	//  Data     Time to   TimeTag  Block    LoopBack RT
    293          	//  Addr     NextMsg   Word     Status   Word     Status 
    294          	    0x5308,  0x0200,  0xABCD,  0xABCD,  0xABCD,  0xABCD };    
   \   00000014   1CA8               ADD      R0,SP,#+112
   \   00000016   ........           LDR.W    R1,??DataTable10_7
   \   0000001A   1022               MOVS     R2,#+16
   \   0000001C   ........           BL       __aeabi_memcpy4
    295          
    296          	// ********************************************************************************
    297                  // Msg Block 2  = Subaddress Tx  Command 03-1-30-00 (loopback subaddress) Bus B
    298          
    299          	unsigned short msg_block2[8] = {
    300          	//  Contro1 Word Options = TXTTMC17|MEMASK|SRQMASK|BSYMASK|SSFMASK|TFMASK|RSVMASK
    301          	//			   |RTRYENA|USEBUSA|USEBUSB|SFTEST|MSKBCR|EOMINT|MCODE|BCST|RT_RT 
    302          	//  Contro1 Word          
    303          	    RTRYENA|MEMASK|USEBUSB,
    304          
    305          	//  Command Word (Transmit Command, RT --> BC )
    306          	//  RT Addr Tx/Rx  SubAdd  WordCt 
    307          	    3<<11  | TX  | 30<<5 | 0,
    308          
    309          	//  Data     Time to   TimeTag  Block    LoopBack RT
    310          	//  Addr     NextMsg   Word     Status   Word     Status 
    311          	    0x5308,  0x0200,  0xABCD,  0xABCD,  0xABCD,  0xABCD };    
   \   00000020   18A8               ADD      R0,SP,#+96
   \   00000022   ........           LDR.W    R1,??DataTable10_8
   \   00000026   1022               MOVS     R2,#+16
   \   00000028   ........           BL       __aeabi_memcpy4
    312          
    313          	// ********************************************************************************
    314                  // Msg Block 3  = Subaddress Rx  Command 03-0-30-00 (loopback subaddress) Bus A
    315          
    316          	unsigned short msg_block3[8] = {
    317          	//  Contro1 Word Options = TXTTMC17|MEMASK|SRQMASK|BSYMASK|SSFMASK|TFMASK|RSVMASK
    318          	//                         |RTRYENA|USEBUSA|USEBUSB|SFTEST|MSKBCR|EOMINT|MCODE|BCST|RT_RT 
    319          	//  Contro1 Word          
    320          	    MEMASK|MSKBCR|USEBUSA,
    321          
    322          	//  Command Word (Receive Command, BC --> RT )
    323          	//  RT Addr Tx/Rx  SubAdd  WordCt 
    324          	    3<<11  | RX  | 30<<5 | 0,
    325          
    326          	//  Data     Time to   TimeTag  Block    LoopBack RT
    327          	//  Addr     NextMsg   Word     Status   Word     Status 
    328          	    0x5328,  700,      0xABCD,  0xABCD,  0xABCD,  0xABCD };   
   \   0000002C   08A8               ADD      R0,SP,#+32
   \   0000002E   ........           LDR.W    R1,??DataTable10_9
   \   00000032   1022               MOVS     R2,#+16
   \   00000034   ........           BL       __aeabi_memcpy4
    329          
    330          	// ********************************************************************************
    331                  // Msg Block 4  = Subaddress BRx Command 31-0-05-11 Bus B
    332          
    333          	unsigned short msg_block4[8] = {
    334          	//  Contro1 Word Options = TXTTMC17|MEMASK|SRQMASK|BSYMASK|SSFMASK|TFMASK|RSVMASK
    335          	//                         |RTRYENA|USEBUSA|USEBUSB|SFTEST|MSKBCR|EOMINT|MCODE|BCST|RT_RT 
    336          	//  Contro1 Word
    337          	    MEMASK|MSKBCR|BCST|USEBUSB,
    338          
    339          	//  Command Word (Broadcast Receive Command, BC --> RTs )
    340          	//  RT Addr  Tx/Rx  SubAdd  WordCt 
    341          	    31<<11 |  RX   | 1<<5 | 11,
    342          
    343          	//  Data     Time to   TimeTag  Block    LoopBack RT
    344          	//  Addr     NextMsg   Word     Status   Word     Status 
    345          	    0x5348,  0x333,    0xABCD,  0xABCD,  0xABCD,  0xABCD };   
   \   00000038   04A8               ADD      R0,SP,#+16
   \   0000003A   ........           LDR.W    R1,??DataTable10_10
   \   0000003E   1022               MOVS     R2,#+16
   \   00000040   ........           BL       __aeabi_memcpy4
    346          
    347          	// ********************************************************************************
    348                  // Msg Block 5  = Subaddress BRx Command 31-0-30-00 (loopback subaddress) Bus A
    349          
    350          	unsigned short msg_block5[8] = {
    351          	//  Contro1 Word Options = TXTTMC17|MEMASK|SRQMASK|BSYMASK|SSFMASK|TFMASK|RSVMASK
    352          	//			   |RTRYENA|USEBUSA|USEBUSB|SFTEST|MSKBCR|EOMINT|MCODE|BCST|RT_RT 
    353          	//  Contro1 Word
    354          	    MEMASK|MSKBCR|BCST|USEBUSA,
    355          
    356          	//  Command Word (Broadcast Receive Command, BC --> RTs )
    357          	//  RT Addr  Tx/Rx  SubAdd  WordCt 
    358          	    31<<11 |  RX   |30<<5 | 0,
    359          
    360          	//  Data     Time to   TimeTag  Block    LoopBack RT
    361          	//  Addr     NextMsg   Word     Status   Word     Status 
    362          	    0x5368,  0,        0xABCD,  0xABCD,  0xABCD,  0xABCD };    
   \   00000044   00A8               ADD      R0,SP,#+0
   \   00000046   ........           LDR.W    R1,??DataTable10_11
   \   0000004A   1022               MOVS     R2,#+16
   \   0000004C   ........           BL       __aeabi_memcpy4
    363          
    364          	// ********************************************************************************
    365                  // Msg Block 6  = Mode Code  Tx  Command 03-1-31-02 (tx mode code 2) Bus B
    366          
    367          
    368          	unsigned short msg_block6[8] = {
    369          	//  Contro1 Word Options = TXTTMC17|MEMASK|SRQMASK|BSYMASK|SSFMASK|TFMASK|RSVMASK
    370          	//			   |RTRYENA|USEBUSA|USEBUSB|SFTEST|MSKBCR|EOMINT|MCODE|BCST|RT_RT 
    371          	//  Contro1 Word
    372          	    MEMASK|MSKBCR|MCODE|USEBUSB,
    373          
    374          	//  Command Word (Transmit Mode Command, MC0-MC15 ONLY )
    375          	//  RT Addr  Tx/Rx  SubAdd  MCode 
    376          	    3<<11 |  TX   | 31<<5 | 2,
    377          
    378          	//  Data     Time to   TimeTag  Block    LoopBack RT
    379          	//  Addr     NextMsg   Word     Status   Word     Status 
    380          	    0xDEAD,  0,        0xABCD,  0xABCD,  0xABCD,  0xABCD };   
   \   00000050   14A8               ADD      R0,SP,#+80
   \   00000052   ........           LDR.W    R1,??DataTable10_12
   \   00000056   1022               MOVS     R2,#+16
   \   00000058   ........           BL       __aeabi_memcpy4
    381          
    382          	// ********************************************************************************
    383                  // Msg Block 7  = Mode Code  Tx  Command 03-1-31-18 (tx mode code 18)     Bus A
    384          
    385          	unsigned short msg_block7[8] = {
    386          	//  Contro1 Word Options = TXTTMC17|MEMASK|SRQMASK|BSYMASK|SSFMASK|TFMASK|RSVMASK
    387          	//			   |RTRYENA|USEBUSA|USEBUSB|SFTEST|MSKBCR|EOMINT|MCODE|BCST|RT_RT 
    388          	//  Contro1 Word
    389          	    MEMASK|MSKBCR|MCODE|USEBUSA,
    390           
    391          	//  Command Word (Transmit Mode Command, MC16-MC31 ONLY )
    392          	//  RT Addr  Tx/Rx  SubAdd  MCode 
    393          	    3<<11  |  TX  | 31<<5 | 18,
    394          
    395          	//  Data     Time to   TimeTag  Block    LoopBack RT
    396          	//  Addr     NextMsg   Word     Status   Word     Status 
    397          	    0x1B62,  0,        0xABCD,  0xABCD,  0xABCD,  0xABCD };    
   \   0000005C   10A8               ADD      R0,SP,#+64
   \   0000005E   ........           LDR.W    R1,??DataTable10_13
   \   00000062   1022               MOVS     R2,#+16
   \   00000064   ........           BL       __aeabi_memcpy4
    398          
    399          	// ********************************************************************************
    400                  // Msg Block 8  = Mode Code  Rx  Command 03-0-31-21 (rx mode code 21)     Bus B
    401          
    402          	unsigned short msg_block8[8] = {
    403          	//  Contro1 Word Options = TXTTMC17|MEMASK|SRQMASK|BSYMASK|SSFMASK|TFMASK|RSVMASK
    404          	//			   |RTRYENA|USEBUSA|USEBUSB|SFTEST|MSKBCR|EOMINT|MCODE|BCST|RT_RT 
    405          	//  Contro1 Word
    406          	    MEMASK|MSKBCR|MCODE|TXTTMC17|USEBUSB,
    407          
    408          	//  Command Word (Receive Mode Command, MC16-MC31 ONLY )
    409          	//  RT Addr  Tx/Rx  SubAdd  MCode 
    410          	    3<<11  |  RX   | 31<<5 | 21,
    411          
    412          	//  Data     Time to   TimeTag  Block    LoopBack RT
    413          	//  Addr     NextMsg   Word     Status   Word     Status 
    414          	    0x1B55,  0,        0xABCD,  0xABCD,  0xABCD,  0xABCD };   
   \   00000068   0CA8               ADD      R0,SP,#+48
   \   0000006A   ........           LDR.W    R1,??DataTable10_14
   \   0000006E   1022               MOVS     R2,#+16
   \   00000070   ........           BL       __aeabi_memcpy4
    415          
    416          	// ********************************************************************************
    417                  // RT-RT Msg Block 1   to RxRT4 from TxRT3   04-0-30-02 03-1-05-02  Bus A
    418          
    419          	unsigned short rtrt_msg_block1[16] = {
    420          	// This format is only used for RT-to-RT messages
    421          
    422          	//  Contro1 Word Options = TXTTMC17|MEMASK|SRQMASK|BSYMASK|SSFMASK|TFMASK|RSVMASK
    423          	//			   |RTRYENA|USEBUSA|USEBUSB|SFTEST|MSKBCR|EOMINT|MCODE|BCST|RT_RT 
    424          	//  Contro1 Word
    425          	    MEMASK|MSKBCR|RT_RT|USEBUSA,
    426          
    427          	//  Rx Command Word 
    428          	//  RT Addr  Tx/Rx  SubAdd  WordCt 
    429          	    4<<11  |  RX  |  30<<5 | 2,
    430          
    431          	//  Data     Time to   TimeTag  Block    LoopBack RT
    432          	//  Addr     NextMsg   Word     Status   Word     Status 
    433          	    0x5388,  0,        0xABCD,  0xABCD,  0xABCD,  0xABCD,  
    434          
    435          	//  Tx Command Word 
    436          	//  RT Addr  Tx/Rx  SubAdd  WordCt 
    437          	    3<<11  |  TX   | 1<<5 | 2,
    438          
    439          	//  Rx RT
    440          	//  Status   6 unused addresses for RT-to-RT only       
    441          	    0x0000,  0xDEAD, 0xDEAD, 0xDEAD, 0xDEAD, 0xDEAD, 0xDEAD };
   \   00000074   28A8               ADD      R0,SP,#+160
   \   00000076   ........           LDR.W    R1,??DataTable10_15
   \   0000007A   2022               MOVS     R2,#+32
   \   0000007C   ........           BL       __aeabi_memcpy4
    442          
    443          	// ********************************************************************************
    444                  // RT-RT Msg Block 2   broadcast to RxRT31 from TxRT3    31-0-30-11 04-1-05-11   Bus B
    445          
    446          	unsigned short rtrt_msg_block2[16] = {
    447          	// This format is only used for RT-to-RT messages 
    448          
    449          	//  Contro1 Word Options = TXTTMC17|MEMASK|SRQMASK|BSYMASK|SSFMASK|TFMASK|RSVMASK
    450          	//			   |RTRYENA|USEBUSA|USEBUSB|SFTEST|MSKBCR|EOMINT|MCODE|BCST|RT_RT 
    451          	//  Contro1 Word
    452          	    MEMASK|MSKBCR|BCST|RT_RT|USEBUSB,
    453          
    454          	//  Rx Command Word 
    455          	//  RT Addr  Tx/Rx  SubAdd  WordCt 
    456          	    31<<11 |  RX   |30<<5 | 11,
    457          
    458          	//  Data     Time to   TimeTag  Block    LoopBack RT
    459          	//  Addr     NextMsg   Word     Status   Word     Status 
    460          	    0x53A8,  0,        0xABCD,  0xABCD,  0xABCD,  0xABCD,
    461          
    462          	//  Tx Command Word 
    463          	//  RT Addr  Tx/Rx  SubAdd  WordCt 
    464          	    4<<11  |  TX   | 1<<5 | 11,
    465          
    466          	//  Rx RT
    467          	//  Status   6 unused addresses for RT-to-RT only       
    468          	    0x0000,  0xDEAD, 0xDEAD, 0xDEAD, 0xDEAD, 0xDEAD, 0xDEAD };
   \   00000080   20A8               ADD      R0,SP,#+128
   \   00000082   ........           LDR.W    R1,??DataTable10_16
   \   00000086   2022               MOVS     R2,#+32
   \   00000088   ........           BL       __aeabi_memcpy4
    469          
    470          	// ********************************************************************************
    471          
    472          		// Initialize BC Message Control / Status Blocks  
    473          
    474                  	//  set up the address pointer, left-shift the start address/offset 
    475          		// these message blocks will be contiguous, stored back-to-back 
    476          		addr = base_6130 + (MSG_BLK1_ADDR << 1);	
   \   0000008C   14F5F840           ADDS     R0,R4,#+31744
   \   00000090   0500               MOVS     R5,R0
    477          
    478          		// these non-RT-RT blocks need 8 words, must start with low nibble = 0x0 or 0x8 
    479          
    480          		for ( i = 0; i < 8; i++) {
   \   00000092   0020               MOVS     R0,#+0
   \   00000094   0600               MOVS     R6,R0
   \                     ??initialize_bc_msg_blocks_0:
   \   00000096   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000098   082E               CMP      R6,#+8
   \   0000009A   07D2               BCS.N    ??initialize_bc_msg_blocks_1
    481                                  *((volatile unsigned short *)(addr)) = msg_block1[i]; // 0x3E00 - 0x3E07
   \   0000009C   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000009E   1CA8               ADD      R0,SP,#+112
   \   000000A0   30F81600           LDRH     R0,[R0, R6, LSL #+1]
   \   000000A4   2880               STRH     R0,[R5, #+0]
    482          			addr += 2;
   \   000000A6   AD1C               ADDS     R5,R5,#+2
    483          		}
   \   000000A8   761C               ADDS     R6,R6,#+1
   \   000000AA   F4E7               B.N      ??initialize_bc_msg_blocks_0
    484          
    485          		for ( i = 0; i < 8; i++) {
   \                     ??initialize_bc_msg_blocks_1:
   \   000000AC   0020               MOVS     R0,#+0
   \   000000AE   0600               MOVS     R6,R0
   \                     ??initialize_bc_msg_blocks_2:
   \   000000B0   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000B2   082E               CMP      R6,#+8
   \   000000B4   07D2               BCS.N    ??initialize_bc_msg_blocks_3
    486          			*((volatile unsigned short *)(addr)) = msg_block2[i]; // 0x3E08 - 0x3E0F
   \   000000B6   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000B8   18A8               ADD      R0,SP,#+96
   \   000000BA   30F81600           LDRH     R0,[R0, R6, LSL #+1]
   \   000000BE   2880               STRH     R0,[R5, #+0]
    487          			addr += 2;
   \   000000C0   AD1C               ADDS     R5,R5,#+2
    488          		}
   \   000000C2   761C               ADDS     R6,R6,#+1
   \   000000C4   F4E7               B.N      ??initialize_bc_msg_blocks_2
    489          
    490          		for ( i = 0; i < 8; i++) {
   \                     ??initialize_bc_msg_blocks_3:
   \   000000C6   0020               MOVS     R0,#+0
   \   000000C8   0600               MOVS     R6,R0
   \                     ??initialize_bc_msg_blocks_4:
   \   000000CA   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000CC   082E               CMP      R6,#+8
   \   000000CE   07D2               BCS.N    ??initialize_bc_msg_blocks_5
    491          			*((volatile unsigned short *)(addr)) = msg_block3[i]; // 0x3E10 - 0x3E17
   \   000000D0   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000D2   08A8               ADD      R0,SP,#+32
   \   000000D4   30F81600           LDRH     R0,[R0, R6, LSL #+1]
   \   000000D8   2880               STRH     R0,[R5, #+0]
    492          			addr += 2;
   \   000000DA   AD1C               ADDS     R5,R5,#+2
    493          		}
   \   000000DC   761C               ADDS     R6,R6,#+1
   \   000000DE   F4E7               B.N      ??initialize_bc_msg_blocks_4
    494          
    495          		for ( i = 0; i < 8; i++) {
   \                     ??initialize_bc_msg_blocks_5:
   \   000000E0   0020               MOVS     R0,#+0
   \   000000E2   0600               MOVS     R6,R0
   \                     ??initialize_bc_msg_blocks_6:
   \   000000E4   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000E6   082E               CMP      R6,#+8
   \   000000E8   07D2               BCS.N    ??initialize_bc_msg_blocks_7
    496          			*((volatile unsigned short *)(addr)) = msg_block4[i]; // 0x3E18 - 0x3E1F
   \   000000EA   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000EC   04A8               ADD      R0,SP,#+16
   \   000000EE   30F81600           LDRH     R0,[R0, R6, LSL #+1]
   \   000000F2   2880               STRH     R0,[R5, #+0]
    497          			addr += 2;
   \   000000F4   AD1C               ADDS     R5,R5,#+2
    498          		}
   \   000000F6   761C               ADDS     R6,R6,#+1
   \   000000F8   F4E7               B.N      ??initialize_bc_msg_blocks_6
    499          
    500          
    501          		for ( i = 0; i < 8; i++) {
   \                     ??initialize_bc_msg_blocks_7:
   \   000000FA   0020               MOVS     R0,#+0
   \   000000FC   0600               MOVS     R6,R0
   \                     ??initialize_bc_msg_blocks_8:
   \   000000FE   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000100   082E               CMP      R6,#+8
   \   00000102   07D2               BCS.N    ??initialize_bc_msg_blocks_9
    502          			*((volatile unsigned short *)(addr)) = msg_block5[i]; // 0x3E20 - 0x3E27
   \   00000104   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000106   00A8               ADD      R0,SP,#+0
   \   00000108   30F81600           LDRH     R0,[R0, R6, LSL #+1]
   \   0000010C   2880               STRH     R0,[R5, #+0]
    503          			addr += 2;
   \   0000010E   AD1C               ADDS     R5,R5,#+2
    504          		}
   \   00000110   761C               ADDS     R6,R6,#+1
   \   00000112   F4E7               B.N      ??initialize_bc_msg_blocks_8
    505          
    506          		for ( i = 0; i < 8; i++) {
   \                     ??initialize_bc_msg_blocks_9:
   \   00000114   0020               MOVS     R0,#+0
   \   00000116   0600               MOVS     R6,R0
   \                     ??initialize_bc_msg_blocks_10:
   \   00000118   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000011A   082E               CMP      R6,#+8
   \   0000011C   07D2               BCS.N    ??initialize_bc_msg_blocks_11
    507          			*((volatile unsigned short *)(addr)) = msg_block6[i]; // 0x3E28 - 0x3E2F
   \   0000011E   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000120   14A8               ADD      R0,SP,#+80
   \   00000122   30F81600           LDRH     R0,[R0, R6, LSL #+1]
   \   00000126   2880               STRH     R0,[R5, #+0]
    508          			addr += 2;
   \   00000128   AD1C               ADDS     R5,R5,#+2
    509          		}
   \   0000012A   761C               ADDS     R6,R6,#+1
   \   0000012C   F4E7               B.N      ??initialize_bc_msg_blocks_10
    510          
    511          		for ( i = 0; i < 8; i++) {
   \                     ??initialize_bc_msg_blocks_11:
   \   0000012E   0020               MOVS     R0,#+0
   \   00000130   0600               MOVS     R6,R0
   \                     ??initialize_bc_msg_blocks_12:
   \   00000132   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000134   082E               CMP      R6,#+8
   \   00000136   07D2               BCS.N    ??initialize_bc_msg_blocks_13
    512          			*((volatile unsigned short *)(addr)) = msg_block7[i]; // 0x3E30 - 0x3E37
   \   00000138   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000013A   10A8               ADD      R0,SP,#+64
   \   0000013C   30F81600           LDRH     R0,[R0, R6, LSL #+1]
   \   00000140   2880               STRH     R0,[R5, #+0]
    513          			addr += 2;
   \   00000142   AD1C               ADDS     R5,R5,#+2
    514          		}
   \   00000144   761C               ADDS     R6,R6,#+1
   \   00000146   F4E7               B.N      ??initialize_bc_msg_blocks_12
    515          
    516          		for ( i = 0; i < 8; i++) {
   \                     ??initialize_bc_msg_blocks_13:
   \   00000148   0020               MOVS     R0,#+0
   \   0000014A   0600               MOVS     R6,R0
   \                     ??initialize_bc_msg_blocks_14:
   \   0000014C   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000014E   082E               CMP      R6,#+8
   \   00000150   07D2               BCS.N    ??initialize_bc_msg_blocks_15
    517          			*((volatile unsigned short *)(addr)) = msg_block8[i]; // 0x3E38 - 0x3E3F
   \   00000152   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000154   0CA8               ADD      R0,SP,#+48
   \   00000156   30F81600           LDRH     R0,[R0, R6, LSL #+1]
   \   0000015A   2880               STRH     R0,[R5, #+0]
    518          			addr += 2;
   \   0000015C   AD1C               ADDS     R5,R5,#+2
    519          		}
   \   0000015E   761C               ADDS     R6,R6,#+1
   \   00000160   F4E7               B.N      ??initialize_bc_msg_blocks_14
    520          		
    521          		// these next RT-RT blocks need 16 words, MUST start with low nibble = 0x0 
    522          
    523          		for ( i = 0; i < 16; i++) {
   \                     ??initialize_bc_msg_blocks_15:
   \   00000162   0020               MOVS     R0,#+0
   \   00000164   0600               MOVS     R6,R0
   \                     ??initialize_bc_msg_blocks_16:
   \   00000166   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000168   102E               CMP      R6,#+16
   \   0000016A   07D2               BCS.N    ??initialize_bc_msg_blocks_17
    524          			*((volatile unsigned short *)(addr)) = rtrt_msg_block1[i]; // 0x3E40 - 0x3E4F
   \   0000016C   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000016E   28A8               ADD      R0,SP,#+160
   \   00000170   30F81600           LDRH     R0,[R0, R6, LSL #+1]
   \   00000174   2880               STRH     R0,[R5, #+0]
    525          			addr += 2;
   \   00000176   AD1C               ADDS     R5,R5,#+2
    526          		}
   \   00000178   761C               ADDS     R6,R6,#+1
   \   0000017A   F4E7               B.N      ??initialize_bc_msg_blocks_16
    527          
    528          		for ( i = 0; i < 16; i++) {
   \                     ??initialize_bc_msg_blocks_17:
   \   0000017C   0020               MOVS     R0,#+0
   \   0000017E   0600               MOVS     R6,R0
   \                     ??initialize_bc_msg_blocks_18:
   \   00000180   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000182   102E               CMP      R6,#+16
   \   00000184   07D2               BCS.N    ??initialize_bc_msg_blocks_19
    529          			*((volatile unsigned short *)(addr)) = rtrt_msg_block2[i]; // 0x3E50 - 0x3E5F
   \   00000186   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000188   20A8               ADD      R0,SP,#+128
   \   0000018A   30F81600           LDRH     R0,[R0, R6, LSL #+1]
   \   0000018E   2880               STRH     R0,[R5, #+0]
    530          			addr += 2;
   \   00000190   AD1C               ADDS     R5,R5,#+2
    531          		}
   \   00000192   761C               ADDS     R6,R6,#+1
   \   00000194   F4E7               B.N      ??initialize_bc_msg_blocks_18
    532          
    533          
    534          		// write dummy data into the transmit data buffers for the 3 receive subaddress commands 
    535                          // REMEMBER: For Receive commands (that is RT receives), the BC IS TRANSMITTING...
    536          
    537          		// a 32-word buffer for rx msg block 3
    538          		addr = msg_block3[2] << 1;
   \                     ??initialize_bc_msg_blocks_19:
   \   00000196   BDF82400           LDRH     R0,[SP, #+36]
   \   0000019A   4000               LSLS     R0,R0,#+1
   \   0000019C   0500               MOVS     R5,R0
    539                          addr += base_6130;
   \   0000019E   6519               ADDS     R5,R4,R5
    540          		// write the 32 data words...
    541          		for ( i = 0; i < 32; i++) {	
   \   000001A0   0020               MOVS     R0,#+0
   \   000001A2   0600               MOVS     R6,R0
   \                     ??initialize_bc_msg_blocks_20:
   \   000001A4   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000001A6   202E               CMP      R6,#+32
   \   000001A8   07D2               BCS.N    ??initialize_bc_msg_blocks_21
    542          			*((volatile unsigned short *)(addr)) = data[i];
   \   000001AA   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000001AC   30A8               ADD      R0,SP,#+192
   \   000001AE   30F81600           LDRH     R0,[R0, R6, LSL #+1]
   \   000001B2   2880               STRH     R0,[R5, #+0]
    543          			addr += 2;
   \   000001B4   AD1C               ADDS     R5,R5,#+2
    544          		}
   \   000001B6   761C               ADDS     R6,R6,#+1
   \   000001B8   F4E7               B.N      ??initialize_bc_msg_blocks_20
    545          
    546          		// a 32-word buffer for rx msg block 4
    547          		addr = msg_block4[2] << 1;
   \                     ??initialize_bc_msg_blocks_21:
   \   000001BA   BDF81400           LDRH     R0,[SP, #+20]
   \   000001BE   4000               LSLS     R0,R0,#+1
   \   000001C0   0500               MOVS     R5,R0
    548                          addr += base_6130;
   \   000001C2   6519               ADDS     R5,R4,R5
    549          		// write the 32 data words...
    550          		for ( i = 0; i < 32; i++) {	
   \   000001C4   0020               MOVS     R0,#+0
   \   000001C6   0600               MOVS     R6,R0
   \                     ??initialize_bc_msg_blocks_22:
   \   000001C8   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000001CA   202E               CMP      R6,#+32
   \   000001CC   07D2               BCS.N    ??initialize_bc_msg_blocks_23
    551          			*((volatile unsigned short *)(addr)) = data[i];
   \   000001CE   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000001D0   30A8               ADD      R0,SP,#+192
   \   000001D2   30F81600           LDRH     R0,[R0, R6, LSL #+1]
   \   000001D6   2880               STRH     R0,[R5, #+0]
    552          			addr += 2;
   \   000001D8   AD1C               ADDS     R5,R5,#+2
    553          		}
   \   000001DA   761C               ADDS     R6,R6,#+1
   \   000001DC   F4E7               B.N      ??initialize_bc_msg_blocks_22
    554          
    555          		// a 32-word buffer for rx msg block 5
    556          		addr = msg_block5[2] << 1;
   \                     ??initialize_bc_msg_blocks_23:
   \   000001DE   BDF80400           LDRH     R0,[SP, #+4]
   \   000001E2   4000               LSLS     R0,R0,#+1
   \   000001E4   0500               MOVS     R5,R0
    557                          addr += base_6130;
   \   000001E6   6519               ADDS     R5,R4,R5
    558          		// write the 32 data words...
    559          		for ( i = 0; i < 32; i++) {	
   \   000001E8   0020               MOVS     R0,#+0
   \   000001EA   0600               MOVS     R6,R0
   \                     ??initialize_bc_msg_blocks_24:
   \   000001EC   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000001EE   202E               CMP      R6,#+32
   \   000001F0   07D2               BCS.N    ??initialize_bc_msg_blocks_25
    560          			*((volatile unsigned short *)(addr)) = data[i];
   \   000001F2   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000001F4   30A8               ADD      R0,SP,#+192
   \   000001F6   30F81600           LDRH     R0,[R0, R6, LSL #+1]
   \   000001FA   2880               STRH     R0,[R5, #+0]
    561          			addr += 2;
   \   000001FC   AD1C               ADDS     R5,R5,#+2
    562          		}
   \   000001FE   761C               ADDS     R6,R6,#+1
   \   00000200   F4E7               B.N      ??initialize_bc_msg_blocks_24
    563          
    564          		// 16 mode data words for Rx MC16-MC31 
    565          		addr = 0x1B50 << 1;
   \                     ??initialize_bc_msg_blocks_25:
   \   00000202   43F2A060           MOVW     R0,#+13984
   \   00000206   0500               MOVS     R5,R0
    566                          addr += base_6130;
   \   00000208   6519               ADDS     R5,R4,R5
    567          		for ( i = 0; i < 16; i++) {	
   \   0000020A   0020               MOVS     R0,#+0
   \   0000020C   0600               MOVS     R6,R0
   \                     ??initialize_bc_msg_blocks_26:
   \   0000020E   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000210   102E               CMP      R6,#+16
   \   00000212   08D2               BCS.N    ??initialize_bc_msg_blocks_27
    568          			// writes 0x1616 for Rx MC16 thru 0x3131 for Rx MC31
    569          			*((volatile unsigned short *)(addr)) = data[i+15];
   \   00000214   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000216   30A8               ADD      R0,SP,#+192
   \   00000218   10EB4600           ADDS     R0,R0,R6, LSL #+1
   \   0000021C   C08B               LDRH     R0,[R0, #+30]
   \   0000021E   2880               STRH     R0,[R5, #+0]
    570          			addr += 2;
   \   00000220   AD1C               ADDS     R5,R5,#+2
    571          		}
   \   00000222   761C               ADDS     R6,R6,#+1
   \   00000224   F3E7               B.N      ??initialize_bc_msg_blocks_26
    572          
    573          	// ********************************************************************************
    574          
    575          }	// end initialize_bc_msg_blocks(void)
   \                     ??initialize_bc_msg_blocks_27:
   \   00000226   40B0               ADD      SP,SP,#+256
   \   00000228   70BD               POP      {R4-R6,PC}       ;; return
    576          
    577          
    578          
    579          //	This function disables the Holt HI-613x BC by writing 
    580          //	the Master Configuration Register to reset the BCENA bit.
    581          //

   \                                 In section .text, align 2, keep-with-next
    582          void bc_disable(void) {
    583          	
    584                  // read-modify-write Master Config register
    585                    
    586          
    587          	unsigned short j = (pH6130->MASTER_CONFIG_REG) & ~BCENA;
   \                     bc_disable:
   \   00000000   ....               LDR.N    R0,??DataTable10_5
   \   00000002   0068               LDR      R0,[R0, #+0]
   \   00000004   0088               LDRH     R0,[R0, #+0]
   \   00000006   10F46040           ANDS     R0,R0,#0xE000
    588          	pH6130->MASTER_CONFIG_REG = j;
   \   0000000A   ....               LDR.N    R1,??DataTable10_5
   \   0000000C   0968               LDR      R1,[R1, #+0]
   \   0000000E   0880               STRH     R0,[R1, #+0]
    589          
    590          }
   \   00000010   7047               BX       LR               ;; return
    591          
    592          
    593          
    594          // 	If the BCENA pin is high, this function enables the Holt 
    595          //	HI-613x BC by writing the Master Configuration Register 
    596          //	to set the BCENA bit. Then BC operation only begins after
    597          //	the BCSTART bit or BCTRIG pin gets a rising edge.
    598          //

   \                                 In section .text, align 2, keep-with-next
    599          void bc_enable(void) {
   \                     bc_enable:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   89B0               SUB      SP,SP,#+36
    600          		        
    601                  const Pin pinBCENA = PIN_BCENA;
   \   00000004   00A8               ADD      R0,SP,#+0
   \   00000006   ....               LDR.N    R1,??DataTable10_17
   \   00000008   2022               MOVS     R2,#+32
   \   0000000A   ........           BL       __aeabi_memcpy4
    602          
    603          	if(PIO_Get(&pinBCENA)) {
   \   0000000E   00A8               ADD      R0,SP,#+0
   \   00000010   ........           BL       PIO_Get
   \   00000014   0028               CMP      R0,#+0
   \   00000016   07D0               BEQ.N    ??bc_enable_0
    604                    
    605                      // read-modify-write Master Config register
    606          
    607          	    unsigned short j = (pH6130->MASTER_CONFIG_REG) | BCENA;
   \   00000018   ....               LDR.N    R0,??DataTable10_5
   \   0000001A   0068               LDR      R0,[R0, #+0]
   \   0000001C   0088               LDRH     R0,[R0, #+0]
   \   0000001E   50F48050           ORRS     R0,R0,#0x1000
    608          	    pH6130->MASTER_CONFIG_REG = j;
   \   00000022   ....               LDR.N    R1,??DataTable10_5
   \   00000024   0968               LDR      R1,[R1, #+0]
   \   00000026   0880               STRH     R0,[R1, #+0]
    609                     
    610          	}
    611          }	// return enabled but not started 
   \                     ??bc_enable_0:
   \   00000028   09B0               ADD      SP,SP,#+36
   \   0000002A   00BD               POP      {PC}             ;; return
    612          
    613          
    614          
    615          // 	If the BCENA pin is high, this function enables and starts 
    616          //	the Holt HI-613x BC by writing the Master Configuration 
    617          //	Register to set the BCENA and BCSTART bits.
    618          //

   \                                 In section .text, align 2, keep-with-next
    619          void bc_start(void) {
   \                     bc_start:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   89B0               SUB      SP,SP,#+36
    620          	
    621                  const Pin pinBCENA = PIN_BCENA;
   \   00000004   00A8               ADD      R0,SP,#+0
   \   00000006   ....               LDR.N    R1,??DataTable10_18
   \   00000008   2022               MOVS     R2,#+32
   \   0000000A   ........           BL       __aeabi_memcpy4
    622          
    623          	if(PIO_Get(&pinBCENA)) {
   \   0000000E   00A8               ADD      R0,SP,#+0
   \   00000010   ........           BL       PIO_Get
   \   00000014   0028               CMP      R0,#+0
   \   00000016   07D0               BEQ.N    ??bc_start_0
    624                    
    625                      // read-modify-write Master Config register
    626                      unsigned short j = (pH6130->MASTER_CONFIG_REG) | BCENA | BCSTRT ;
   \   00000018   ....               LDR.N    R0,??DataTable10_5
   \   0000001A   0068               LDR      R0,[R0, #+0]
   \   0000001C   0088               LDRH     R0,[R0, #+0]
   \   0000001E   50F44050           ORRS     R0,R0,#0x3000
    627          	    pH6130->MASTER_CONFIG_REG = j;
   \   00000022   ....               LDR.N    R1,??DataTable10_5
   \   00000024   0968               LDR      R1,[R1, #+0]
   \   00000026   0880               STRH     R0,[R1, #+0]
    628          
    629          	}
    630          }	// return enabled and started 
   \                     ??bc_start_0:
   \   00000028   09B0               ADD      SP,SP,#+36
   \   0000002A   00BD               POP      {PC}             ;; return
    631          
    632          
    633          // This function generates a BC Trigger pulse for the HI-613x.
    634          //

   \                                 In section .text, align 2, keep-with-next
    635          void bc_trigger(void) {
   \                     bc_trigger:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   88B0               SUB      SP,SP,#+32
    636          	
    637              const Pin pinBCTRIG = PIN_BCTRIG;
   \   00000004   00A8               ADD      R0,SP,#+0
   \   00000006   ....               LDR.N    R1,??DataTable10_19
   \   00000008   2022               MOVS     R2,#+32
   \   0000000A   ........           BL       __aeabi_memcpy4
    638              char i = 2;
   \   0000000E   0224               MOVS     R4,#+2
    639              
    640              PIO_Set(&pinBCTRIG);        
   \   00000010   00A8               ADD      R0,SP,#+0
   \   00000012   ........           BL       PIO_Set
    641              while (i--);       
   \                     ??bc_trigger_0:
   \   00000016   2000               MOVS     R0,R4
   \   00000018   441E               SUBS     R4,R0,#+1
   \   0000001A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0028               CMP      R0,#+0
   \   0000001E   FAD1               BNE.N    ??bc_trigger_0
    642              PIO_Clear(&pinBCTRIG);
   \   00000020   00A8               ADD      R0,SP,#+0
   \   00000022   ........           BL       PIO_Clear
    643          }
   \   00000026   08B0               ADD      SP,SP,#+32
   \   00000028   10BD               POP      {R4,PC}          ;; return
    644          
    645          
    646          // part of infinite standby loop when CONSOLE_IO is disabled.
    647          // this function is used for demonstration for BC mode only...
    648          //

   \                                 In section .text, align 2, keep-with-next
    649          void bc_switch_tests(void) {
   \                     bc_switch_tests:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   89B0               SUB      SP,SP,#+36
    650          
    651              const Pin pinNSW1 = PIN_NSW1;
   \   00000004   00A8               ADD      R0,SP,#+0
   \   00000006   ....               LDR.N    R1,??DataTable10_20
   \   00000008   2022               MOVS     R2,#+32
   \   0000000A   ........           BL       __aeabi_memcpy4
    652              //const Pin pinNSW2 = PIN_NSW2;
    653          
    654              // eval board button SW1 generates BC Trigger pulse
    655              if(!PIO_Get(&pinNSW1))  SW1_BC_Trigger();
   \   0000000E   00A8               ADD      R0,SP,#+0
   \   00000010   ........           BL       PIO_Get
   \   00000014   0028               CMP      R0,#+0
   \   00000016   01D1               BNE.N    ??bc_switch_tests_0
   \   00000018   ........           BL       SW1_BC_Trigger
    656              
    657              // eval board button SW2 modifies BC Condition Code and GP Flag Register
    658              // NEXT STATEMENT IS DISABLED TO AVOID CONFLICT WITH USER BC PROGRAM
    659              /*  
    660              if(!PIO_Get(&pinNSW2))  SW2_BCtest();
    661              */
    662              
    663          }   // end bc_switch_tests()
   \                     ??bc_switch_tests_0:
   \   0000001C   09B0               ADD      SP,SP,#+36
   \   0000001E   00BD               POP      {PC}             ;; return
    664          
    665          
    666          
    667          // This function generates a BC Trigger pulse for the HI-613x
    668          // if button SW1 is pressed. Demo program uses this call in main()
    669          // if Console I/O is disabled. This triggers BC when a "wait for
    670          // trigger" op code has executed. Demo program interleaves 1553 
    671          // WTG op codes strictly for demonstration purposes).
    672          //

   \                                 In section .text, align 2, keep-with-next
    673          char SW1_BC_Trigger(void){
   \                     SW1_BC_Trigger:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   88B0               SUB      SP,SP,#+32
    674            
    675              const Pin pinNSW1 = PIN_NSW1;
   \   00000004   00A8               ADD      R0,SP,#+0
   \   00000006   ....               LDR.N    R1,??DataTable10_21
   \   00000008   2022               MOVS     R2,#+32
   \   0000000A   ........           BL       __aeabi_memcpy4
    676              unsigned short i=2000;
   \   0000000E   4FF4FA64           MOV      R4,#+2000
    677          
    678              if(!PIO_Get(&pinNSW1)) { 
   \   00000012   00A8               ADD      R0,SP,#+0
   \   00000014   ........           BL       PIO_Get
   \   00000018   0028               CMP      R0,#+0
   \   0000001A   1DD1               BNE.N    ??SW1_BC_Trigger_0
    679                   // button press
    680                   while(i){
   \                     ??SW1_BC_Trigger_1:
   \   0000001C   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000001E   002C               CMP      R4,#+0
   \   00000020   0FD0               BEQ.N    ??SW1_BC_Trigger_2
    681                      // wait for release
    682                      while(!PIO_Get(&pinNSW1));
   \                     ??SW1_BC_Trigger_3:
   \   00000022   00A8               ADD      R0,SP,#+0
   \   00000024   ........           BL       PIO_Get
   \   00000028   0028               CMP      R0,#+0
   \   0000002A   FAD0               BEQ.N    ??SW1_BC_Trigger_3
    683          
    684                      // if switch bounce, reload
    685                      if(!PIO_Get(&pinNSW1)) i=2000;
   \   0000002C   00A8               ADD      R0,SP,#+0
   \   0000002E   ........           BL       PIO_Get
   \   00000032   0028               CMP      R0,#+0
   \   00000034   03D1               BNE.N    ??SW1_BC_Trigger_4
   \   00000036   4FF4FA60           MOV      R0,#+2000
   \   0000003A   0400               MOVS     R4,R0
   \   0000003C   EEE7               B.N      ??SW1_BC_Trigger_1
    686                      // otherwise dec debounce delay
    687                      else i--;         
   \                     ??SW1_BC_Trigger_4:
   \   0000003E   641E               SUBS     R4,R4,#+1
   \   00000040   ECE7               B.N      ??SW1_BC_Trigger_1
    688                   }
    689                   // trigger BC after debounce, minimize switch bounce retrigger
    690                   bc_trigger();
   \                     ??SW1_BC_Trigger_2:
   \   00000042   ........           BL       bc_trigger
    691                   
    692                   // read STATUS_AND_RESET_REG to verfy "BC msg in progress" bit, 0x0200. 
    693                   // To see BCMIP state, set a breakpoint at "return 1" line below.
    694                 
    695                       i = pH6130->STATUS_AND_RESET_REG;   
   \   00000046   ....               LDR.N    R0,??DataTable10_5
   \   00000048   0068               LDR      R0,[R0, #+0]
   \   0000004A   4088               LDRH     R0,[R0, #+2]
   \   0000004C   0400               MOVS     R4,R0
    696                       
    697                  i &= BCMIP;
   \   0000004E   4FF40070           MOV      R0,#+512
   \   00000052   0440               ANDS     R4,R0,R4
    698                         
    699                   return 1;
   \   00000054   0120               MOVS     R0,#+1
   \   00000056   00E0               B.N      ??SW1_BC_Trigger_5
    700              }
    701              else return 0;
   \                     ??SW1_BC_Trigger_0:
   \   00000058   0020               MOVS     R0,#+0
   \                     ??SW1_BC_Trigger_5:
   \   0000005A   08B0               ADD      SP,SP,#+32
   \   0000005C   10BD               POP      {R4,PC}          ;; return
    702          }
    703                  
    704          
    705          //
    706          // brief  For some BC tests, this function is called from main() standby loop 
    707          //	  when user presses button SW2.	First press after reset, the BC Cond
    708          //        Code and GP Flag Register is written so GP Flag bits 7-0 = 0x01.
    709          //        On subsequent presses, the set bit rotates left, i.e.,0x02, 0x04,
    710          //	  0x08, 0x10, 0x20, 0x40, 0x80 then next press starts over at 0x01.
    711          // 		  
    712          //	  primary purpose: testing the condition codes GP0-GP7 and nGP0-nGP7
    713           

   \                                 In section .text, align 2, keep-with-next
    714          void SW2_BCtest(void) {
   \                     SW2_BCtest:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   89B0               SUB      SP,SP,#+36
    715          
    716                  const Pin pinNSW2 = PIN_NSW2;
   \   00000004   00A8               ADD      R0,SP,#+0
   \   00000006   ....               LDR.N    R1,??DataTable10_22
   \   00000008   2022               MOVS     R2,#+32
   \   0000000A   ........           BL       __aeabi_memcpy4
    717          	static unsigned short press = 128;
    718          
    719          	// SW2 was pressed before this function call 
    720          	// turn on green LED 
    721                  AT91C_BASE_PIOA->PIO_CODR = nLEDG;
   \   0000000E   ....               LDR.N    R0,??DataTable10_23  ;; 0x400e0c34
   \   00000010   5FF00051           MOVS     R1,#+536870912
   \   00000014   0160               STR      R1,[R0, #+0]
    722          
    723          	// wait for button release
    724                  while(PIO_Get(&pinNSW2)) ;
   \                     ??SW2_BCtest_0:
   \   00000016   00A8               ADD      R0,SP,#+0
   \   00000018   ........           BL       PIO_Get
   \   0000001C   0028               CMP      R0,#+0
   \   0000001E   FAD1               BNE.N    ??SW2_BCtest_0
    725          
    726          	press = press << 1;
   \   00000020   ....               LDR.N    R0,??DataTable10_24
   \   00000022   0088               LDRH     R0,[R0, #+0]
   \   00000024   4000               LSLS     R0,R0,#+1
   \   00000026   ....               LDR.N    R1,??DataTable10_24
   \   00000028   0880               STRH     R0,[R1, #+0]
    727          	if(press == 256) press = 1;
   \   0000002A   ....               LDR.N    R0,??DataTable10_24
   \   0000002C   0088               LDRH     R0,[R0, #+0]
   \   0000002E   4FF48071           MOV      R1,#+256
   \   00000032   8842               CMP      R0,R1
   \   00000034   02D1               BNE.N    ??SW2_BCtest_1
   \   00000036   ....               LDR.N    R0,??DataTable10_24
   \   00000038   0121               MOVS     R1,#+1
   \   0000003A   0180               STRH     R1,[R0, #+0]
    728                  
    729          
    730                      // reset all GP Flag bits by writing the 8 clear bits
    731                      pH6130->BC_CCODE_AND_GPF_REG = 0xFF00;
   \                     ??SW2_BCtest_1:
   \   0000003C   ....               LDR.N    R0,??DataTable10_5
   \   0000003E   0068               LDR      R0,[R0, #+0]
   \   00000040   4FF47F41           MOV      R1,#+65280
   \   00000044   A0F86E10           STRH     R1,[R0, #+110]
    732                      // set the GP Flag bits to match variable "press" by writing set bits
    733                      pH6130->BC_CCODE_AND_GPF_REG = press;  
   \   00000048   ....               LDR.N    R0,??DataTable10_5
   \   0000004A   0068               LDR      R0,[R0, #+0]
   \   0000004C   ....               LDR.N    R1,??DataTable10_24
   \   0000004E   0988               LDRH     R1,[R1, #+0]
   \   00000050   A0F86E10           STRH     R1,[R0, #+110]
    734                      
    735          	// debounce delay then turn off green LED
    736          	Delay_x100ms(4);
   \   00000054   0420               MOVS     R0,#+4
   \   00000056   ........           BL       Delay_x100ms
    737                  AT91C_BASE_PIOA->PIO_SODR = nLEDG;
   \   0000005A   ....               LDR.N    R0,??DataTable10_25  ;; 0x400e0c30
   \   0000005C   5FF00051           MOVS     R1,#+536870912
   \   00000060   0160               STR      R1,[R0, #+0]
    738                  
    739          }   // end SW2_BCtest()
   \   00000062   09B0               ADD      SP,SP,#+36
   \   00000064   00BD               POP      {PC}             ;; return

   \                                 In section .data, align 2
   \                     ??press:
   \   00000000   8000               DC16 128
    740          
    741          
    742          
    743          // This function initializes the Holt HI-613x BC by writing configuration registers in the device. 
    744          // Only BC mode option bits are affected. The program has already initialized the common parameters
    745          // shared by the BC, RT1, RT2 and/or Bus Monitor.
    746           

   \                                 In section .text, align 2, keep-with-next
    747          void initialize_613x_BC(void) {
    748                  
    749                          // HI-6130 uses host bus interface to initialize HI-6130 registers and RAM tables
    750                  
    751              	        pH6130->BC_CONFIG_REG = BCTO_138U|BCGTE|ETTSYN|TTSYNEN|BCRME|BCRE;//|BSYNDV|MENDV|RESBS|CHKCWFMT|BCGCE|BC2RE|BCR1A|BCR2A;
   \                     initialize_613x_BC:
   \   00000000   ....               LDR.N    R0,??DataTable10_5
   \   00000002   0068               LDR      R0,[R0, #+0]
   \   00000004   4DF22D01           MOVW     R1,#+53293
   \   00000008   A0F86410           STRH     R1,[R0, #+100]
    752          		//pH6130->BC_INST_LIST_BASE_ADDR_REG = OP_START_ADDR;
    753          		//pH6130->BC_GP_QUEUE_POINTER = 0x00C0;  // default (64 locations)
    754          		pH6130->BC_INT_ENABLE_REG = BCWDT|SELMSG|BCGPQ|BCRETRY|CSTKERR|BCTRAP|STATSET|BCIRQMASK|BCMERR|BCEOM;
   \   0000000C   ....               LDR.N    R0,??DataTable10_5
   \   0000000E   0068               LDR      R0,[R0, #+0]
   \   00000010   4FF6F871           MOVW     R1,#+65528
   \   00000014   0184               STRH     R1,[R0, #+32]
    755          		pH6130->BC_INT_OUTPUT_ENABLE_REG = BCWDT|SELMSG|BCGPQ|BCRETRY|CSTKERR|STATSET|BCIRQMASK|BCMERR|BCEOM; //|BCTRAP
   \   00000016   ....               LDR.N    R0,??DataTable10_5
   \   00000018   0068               LDR      R0,[R0, #+0]
   \   0000001A   4FF6F831           MOVW     R1,#+64504
   \   0000001E   0185               STRH     R1,[R0, #+40]
    756                          
    757          }	// end initialize_613x_BC()
   \   00000020   7047               BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   ........           DC32     pGPQ

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   ........           DC32     pBCil

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   ........           DC32     pBCstack

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   ........           DC32     pBCstack2RT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   ........           DC32     `?<Constant {20495, 0, 1039, 15872, 20495, 0, 1`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   ........           DC32     pH6130

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   ........           DC32     `?<Constant {257, 514, 771, 1028, 1285, 1542, 1`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   ........           DC32     `?<Constant {16768, 8128, 21256, 512, 43981, 43`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   ........           DC32     `?<Constant {16640, 8128, 21256, 512, 43981, 43`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   ........           DC32     `?<Constant {16544, 7104, 21288, 700, 43981, 43`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   ........           DC32     `?<Constant {16418, 63531, 21320, 819, 43981, 4`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \   00000000   ........           DC32     `?<Constant {16546, 64448, 21352, 0, 43981, 439`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_12:
   \   00000000   ........           DC32     `?<Constant {16420, 8162, 57005, 0, 43981, 4398`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_13:
   \   00000000   ........           DC32     `?<Constant {16548, 8178, 7010, 0, 43981, 43981`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_14:
   \   00000000   ........           DC32     `?<Constant {49188, 7157, 6997, 0, 43981, 43981`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_15:
   \   00000000   ........           DC32     `?<Constant {16545, 9154, 21384, 0, 43981, 4398`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_16:
   \   00000000   ........           DC32     `?<Constant {16419, 64459, 21416, 0, 43981, 439`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_17:
   \   00000000   ........           DC32     `?<Constant {268435456, (AT91S_PIO *)1074663424`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_18:
   \   00000000   ........           DC32     `?<Constant {268435456, (AT91S_PIO *)1074663424_1`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_19:
   \   00000000   ........           DC32     `?<Constant {536870912, (AT91S_PIO *)1074663424`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_20:
   \   00000000   ........           DC32     `?<Constant {131072, (AT91S_PIO *)1074662912, 1`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_21:
   \   00000000   ........           DC32     `?<Constant {131072, (AT91S_PIO *)1074662912, 1_1`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_22:
   \   00000000   ........           DC32     `?<Constant {262144, (AT91S_PIO *)1074662912, 1`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_23:
   \   00000000   340C0E40           DC32     0x400e0c34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_24:
   \   00000000   ........           DC32     ??press

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_25:
   \   00000000   300C0E40           DC32     0x400e0c30

   \                                 In section .rodata, align 4
   \                     `?<Constant {20495, 0, 1039, 15872, 20495, 0, 1`:
   \   00000000   0F5000000F04       DC16 20495, 0, 1039, 15872, 20495, 0, 1039, 15880, 20495, 0, 1039
   \              003E0F500000
   \              0F04083E0F50
   \              00000F04    
   \   00000016   103E0F500000       DC16 15888, 20495, 0, 1039, 15896, 20495, 0, 1039, 15904, 20495, 0
   \              0F04183E0F50
   \              00000F04203E
   \              0F500000    
   \   0000002C   0F04283E0F50       DC16 1039, 15912, 20495, 0, 1039, 15920, 20495, 0, 1039, 15928, 20495
   \              00000F04303E
   \              0F5000000F04
   \              383E0F50    
   \   00000042   00000F04403E       DC16 0, 1039, 15936, 20495, 0, 1039, 15952, 20495, 0, 1039, 15880, 2063
   \              0F5000000F04
   \              503E0F500000
   \              0F04083E0F08
   \   0000005A   701B               DC16 7024

   \                                 In section .rodata, align 4
   \                     `?<Constant {257, 514, 771, 1028, 1285, 1542, 1`:
   \   00000000   010102020303       DC16 257, 514, 771, 1028, 1285, 1542, 1799, 2056, 2313, 4112, 4369
   \              040405050606
   \              070708080909
   \              10101111    
   \   00000016   121213131414       DC16 4626, 4883, 5140, 5397, 5654, 5911, 6168, 6425, 8224, 8481, 8738
   \              151516161717
   \              181819192020
   \              21212222    
   \   0000002C   232324242525       DC16 8995, 9252, 9509, 9766, 10023, 10280, 10537, 12336, 12593, 12850
   \              262627272828
   \              292930303131
   \              3232        

   \                                 In section .rodata, align 4
   \                     `?<Constant {16768, 8128, 21256, 512, 43981, 43`:
   \   00000000   8041C01F0853       DC16 16768, 8128, 21256, 512, 43981, 43981, 43981, 43981
   \              0002CDABCDAB
   \              CDABCDAB    

   \                                 In section .rodata, align 4
   \                     `?<Constant {16640, 8128, 21256, 512, 43981, 43`:
   \   00000000   0041C01F0853       DC16 16640, 8128, 21256, 512, 43981, 43981, 43981, 43981
   \              0002CDABCDAB
   \              CDABCDAB    

   \                                 In section .rodata, align 4
   \                     `?<Constant {16544, 7104, 21288, 700, 43981, 43`:
   \   00000000   A040C01B2853       DC16 16544, 7104, 21288, 700, 43981, 43981, 43981, 43981
   \              BC02CDABCDAB
   \              CDABCDAB    

   \                                 In section .rodata, align 4
   \                     `?<Constant {16418, 63531, 21320, 819, 43981, 4`:
   \   00000000   22402BF84853       DC16 16418, 63531, 21320, 819, 43981, 43981, 43981, 43981
   \              3303CDABCDAB
   \              CDABCDAB    

   \                                 In section .rodata, align 4
   \                     `?<Constant {16546, 64448, 21352, 0, 43981, 439`:
   \   00000000   A240C0FB6853       DC16 16546, 64448, 21352, 0, 43981, 43981, 43981, 43981
   \              0000CDABCDAB
   \              CDABCDAB    

   \                                 In section .rodata, align 4
   \                     `?<Constant {16420, 8162, 57005, 0, 43981, 4398`:
   \   00000000   2440E21FADDE       DC16 16420, 8162, 57005, 0, 43981, 43981, 43981, 43981
   \              0000CDABCDAB
   \              CDABCDAB    

   \                                 In section .rodata, align 4
   \                     `?<Constant {16548, 8178, 7010, 0, 43981, 43981`:
   \   00000000   A440F21F621B       DC16 16548, 8178, 7010, 0, 43981, 43981, 43981, 43981
   \              0000CDABCDAB
   \              CDABCDAB    

   \                                 In section .rodata, align 4
   \                     `?<Constant {49188, 7157, 6997, 0, 43981, 43981`:
   \   00000000   24C0F51B551B       DC16 49188, 7157, 6997, 0, 43981, 43981, 43981, 43981
   \              0000CDABCDAB
   \              CDABCDAB    

   \                                 In section .rodata, align 4
   \                     `?<Constant {16545, 9154, 21384, 0, 43981, 4398`:
   \   00000000   A140C2238853       DC16 16545, 9154, 21384, 0, 43981, 43981, 43981, 43981, 7202, 0, 57005
   \              0000CDABCDAB
   \              CDABCDAB221C
   \              0000ADDE    
   \   00000016   ADDEADDEADDE       DC16 57005, 57005, 57005, 57005, 57005
   \              ADDEADDE    

   \                                 In section .rodata, align 4
   \                     `?<Constant {16419, 64459, 21416, 0, 43981, 439`:
   \   00000000   2340CBFBA853       DC16 16419, 64459, 21416, 0, 43981, 43981, 43981, 43981, 9259, 0, 57005
   \              0000CDABCDAB
   \              CDABCDAB2B24
   \              0000ADDE    
   \   00000016   ADDEADDEADDE       DC16 57005, 57005, 57005, 57005, 57005
   \              ADDEADDE    

   \                                 In section .rodata, align 4
   \                     `?<Constant {268435456, (AT91S_PIO *)1074663424`:
   \   00000000   000000100010       DC32 268435456, 400E1000H
   \              0E40        
   \   00000008   0C0200000000       DC8 12, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \   0000001A   000000000000       DC8 0, 0, 0, 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant {268435456, (AT91S_PIO *)1074663424_1`:
   \   00000000   000000100010       DC32 268435456, 400E1000H
   \              0E40        
   \   00000008   0C0200000000       DC8 12, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \   0000001A   000000000000       DC8 0, 0, 0, 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant {536870912, (AT91S_PIO *)1074663424`:
   \   00000000   000000200010       DC32 536870912, 400E1000H
   \              0E40        
   \   00000008   0C0300000000       DC8 12, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   0000001B   0000000000         DC8 0, 0, 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant {131072, (AT91S_PIO *)1074662912, 1`:
   \   00000000   00000200000E       DC32 131072, 400E0E00H
   \              0E40        
   \   00000008   0B0202000000       DC8 11, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   0000001B   0000000000         DC8 0, 0, 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant {131072, (AT91S_PIO *)1074662912, 1_1`:
   \   00000000   00000200000E       DC32 131072, 400E0E00H
   \              0E40        
   \   00000008   0B0202000000       DC8 11, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   0000001B   0000000000         DC8 0, 0, 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant {262144, (AT91S_PIO *)1074662912, 1`:
   \   00000000   00000400000E       DC32 262144, 400E0E00H
   \              0E40        
   \   00000008   0B0202000000       DC8 11, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   0000001B   0000000000         DC8 0, 0, 0, 0, 0
    758          
    759          
    760          
    761          
    762          // end of file 
    763          

   Maximum stack usage in bytes:

     Function                       .cstack
     --------                       -------
     BC_bus_addressing_examples          0
     SW1_BC_Trigger                     40
     SW2_BCtest                         40
     bc_disable                          0
     bc_enable                          40
     bc_start                           40
     bc_switch_tests                    40
     bc_trigger                         40
     initialize_613x_BC                  0
     initialize_bc_instruction_list    116
     initialize_bc_msg_blocks          272


   Section sizes:

     Function/Label                                   Bytes
     --------------                                   -----
     BC_bus_addressing_examples                        362
     initialize_bc_instruction_list                    168
     initialize_bc_msg_blocks                          554
     bc_disable                                         18
     bc_enable                                          44
     bc_start                                           44
     bc_trigger                                         42
     bc_switch_tests                                    32
     SW1_BC_Trigger                                     94
     SW2_BCtest                                        102
     press                                               2
     initialize_613x_BC                                 34
     ??DataTable10                                       4
     ??DataTable10_1                                     4
     ??DataTable10_2                                     4
     ??DataTable10_3                                     4
     ??DataTable10_4                                     4
     ??DataTable10_5                                     4
     ??DataTable10_6                                     4
     ??DataTable10_7                                     4
     ??DataTable10_8                                     4
     ??DataTable10_9                                     4
     ??DataTable10_10                                    4
     ??DataTable10_11                                    4
     ??DataTable10_12                                    4
     ??DataTable10_13                                    4
     ??DataTable10_14                                    4
     ??DataTable10_15                                    4
     ??DataTable10_16                                    4
     ??DataTable10_17                                    4
     ??DataTable10_18                                    4
     ??DataTable10_19                                    4
     ??DataTable10_20                                    4
     ??DataTable10_21                                    4
     ??DataTable10_22                                    4
     ??DataTable10_23                                    4
     ??DataTable10_24                                    4
     ??DataTable10_25                                    4
     ?<Constant {20495, 0, 1039, 15872, 20495, 0, 1     92
     ?<Constant {257, 514, 771, 1028, 1285, 1542, 1     64
     ?<Constant {16768, 8128, 21256, 512, 43981, 43     16
     ?<Constant {16640, 8128, 21256, 512, 43981, 43     16
     ?<Constant {16544, 7104, 21288, 700, 43981, 43     16
     ?<Constant {16418, 63531, 21320, 819, 43981, 4     16
     ?<Constant {16546, 64448, 21352, 0, 43981, 439     16
     ?<Constant {16420, 8162, 57005, 0, 43981, 4398     16
     ?<Constant {16548, 8178, 7010, 0, 43981, 43981     16
     ?<Constant {49188, 7157, 6997, 0, 43981, 43981     16
     ?<Constant {16545, 9154, 21384, 0, 43981, 4398     32
     ?<Constant {16419, 64459, 21416, 0, 43981, 439     32
     ?<Constant {268435456, (AT91S_PIO *)1074663424     32
     ?<Constant {268435456, (AT91S_PIO *)1074663424_1   32
     ?<Constant {536870912, (AT91S_PIO *)1074663424     32
     ?<Constant {131072, (AT91S_PIO *)1074662912, 1     32
     ?<Constant {131072, (AT91S_PIO *)1074662912, 1_1   32
     ?<Constant {262144, (AT91S_PIO *)1074662912, 1     32

 
     2 bytes in section .data
   540 bytes in section .rodata
 1 598 bytes in section .text
 
 1 598 bytes of CODE  memory
   540 bytes of CONST memory
     2 bytes of DATA  memory

Errors: none
Warnings: none
