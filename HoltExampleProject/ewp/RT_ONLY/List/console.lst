###############################################################################
#                                                                             #
#                                                       18/Jun/2012  10:24:06 #
# IAR ANSI C/C++ Compiler V6.21.1.32794/W32 KICKSTART for ARM                 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Program Files\IAR Systems\Embedded Workbench 6.0      #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\console.c                        #
#    Command line =  "C:\Program Files\IAR Systems\Embedded Workbench 6.0     #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\console.c" -D at91sam3u4 -D      #
#                    flash -D TRACE_LEVEL=4 -D BC_ena=0 -D RT2_ena=1 -D       #
#                    RT1_ena=1 -D SMT_ena=0 -D IMT_ena=0 -lC "C:\Program      #
#                    Files\IAR Systems\Embedded Workbench 6.0                 #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\ewp\RT_ONLY\List\" --remarks     #
#                    --diag_suppress Pe826,Pe1375,Pe068 -o "C:\Program        #
#                    Files\IAR Systems\Embedded Workbench 6.0                 #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\ewp\RT_ONLY\Obj\" --no_cse       #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench 6.0                 #
#                    Kickstart_2\arm\INC\c\DLib_Config_Full.h" -I             #
#                    "C:\Program Files\IAR Systems\Embedded Workbench 6.0     #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\ewp\..\..\..\at91lib/peripherals #
#                    \" -I "C:\Program Files\IAR Systems\Embedded Workbench   #
#                    6.0 Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt    #
#                    HI-6130-40 EBI Demo 2_0\ewp\..\..\..\at91lib/components\ #
#                    " -I "C:\Program Files\IAR Systems\Embedded Workbench    #
#                    6.0 Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt    #
#                    HI-6130-40 EBI Demo 2_0\ewp\..\..\..\at91lib\" -I        #
#                    "C:\Program Files\IAR Systems\Embedded Workbench 6.0     #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\ewp\..\..\..\external_libs\" -I  #
#                    "C:\Program Files\IAR Systems\Embedded Workbench 6.0     #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\ewp\..\..\..\at91lib/boards/at91 #
#                    sam3u-ek\" --cpu_mode thumb -On --use_c++_inline         #
#    List file    =  C:\Program Files\IAR Systems\Embedded Workbench 6.0      #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\ewp\RT_ONLY\List\console.lst     #
#    Object file  =  C:\Program Files\IAR Systems\Embedded Workbench 6.0      #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\ewp\RT_ONLY\Obj\console.o        #
#                                                                             #
#                                                                             #
###############################################################################

C:\Program Files\IAR Systems\Embedded Workbench 6.0 Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt HI-6130-40 EBI Demo 2_0\console.c
      1          /* ----------------------------------------------------------------------------
      2           *                            HOLT Integrated Circuits 
      3           * ----------------------------------------------------------------------------
      4           *
      5           *    file	console.c
      6           *    object    HyperTerminal-style console I/O for reference design, Holt
      7                          HI-6130 or HI-6131 Evaluation Board based on the Atmel Cortex M-3
      8           
      9           *    brief     This file contains functions for UART initialization, console
     10           *              screen text display and keyboard input when using a program 
     11           *              like HyperTerminal. As a debug aid, this function is optional
     12           *              and is enabled or disabled in file 613x_initialization.h :
     13           *
     14           *		     CONSOLE_IO  YES  enables console I/O for debug.
     15           *                               NO   disables it, reducing program size
     16           *
     17           *              Settings: 115200 baud, 8 data bits, 1 stop bit, no parity, 
     18           *              hardware flow control OFF
     19           *
     20           *	   	HOLT DISCLAIMER
     21           *      	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY 
     22           *      	KIND, EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE 
     23           *      	WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
     24           *      	PURPOSE AND NONINFRINGEMENT. 
     25           *      	IN NO EVENT SHALL HOLT, INC BE LIABLE FOR ANY CLAIM, DAMAGES
     26           *      	OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
     27           *      	OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
     28           *      	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
     29           *
     30           *              Copyright (C) 2009-2011 by  HOLT, Inc.
     31           *              All Rights Reserved
     32           */
     33          
     34          // standard Atmel/IAR headers
     35          #include <usart/usart.h>
     36          #include <stdio.h>
     37          #include <pio/pio.h>
     38          #include <pmc/pmc.h>
     39          
     40          // Holt project headers
     41          #include "613x_regs.h"
     42          #include "board_613x.h"
     43          #include "613x_bc.h"
     44          #include "613x_mt.h"
     45          #include "613x_initialization.h"
     46          #include "console.h"
     47          
     48          #include "device_6130.h"
     49          #include "board_6130.h"
     50          extern const H6130 pH6130;
     51          
     52          
     53          //------------------------------------------------------------------------------
     54          //         Global variables
     55          //------------------------------------------------------------------------------
     56          

   \                                 In section .bss, align 2
     57          static unsigned short waddr = 0;
   \                     waddr:
   \   00000000                      DS8 2

   \                                 In section .bss, align 1
     58          static unsigned char watch = 0;
   \                     watch:
   \   00000000                      DS8 1
     59          
     60          
     61          //------------------------------------------------------------------------------
     62          //         Functions
     63          //------------------------------------------------------------------------------
     64          
     65          //------------------------------------------------------------------------------
     66          /// Configures USART: hardware flow control OFF, asynchronous, 8 bits, 1 stop
     67          /// bit, no parity, 115200 baud, then enables USART transmitter and receiver.
     68          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     69          void ConfigureUsart1(void)
     70          {
   \                     ConfigureUsart1:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   A0B0               SUB      SP,SP,#+128
     71            const Pin pins[] = {PINS_USART};
   \   00000004   00A8               ADD      R0,SP,#+0
   \   00000006   ........           LDR.W    R1,??DataTable13
   \   0000000A   8022               MOVS     R2,#+128
   \   0000000C   ........           BL       __aeabi_memcpy4
     72            
     73            unsigned int mode = AT91C_US_USMODE_NORMAL // USMODE_HWHSH enables RTS/CTS handshaking
     74                                  | AT91C_US_CLKS_CLOCK
     75                                  | AT91C_US_CHRL_8_BITS
     76                                  | AT91C_US_PAR_NONE
     77                                  | AT91C_US_NBSTOP_1_BIT
     78                                  | AT91C_US_CHMODE_NORMAL;
   \   00000010   4FF40C64           MOV      R4,#+2240
     79          
     80              // configure PIO pins used by USART1
     81              PIO_Configure(pins, PIO_LISTSIZE(pins));  
   \   00000014   0421               MOVS     R1,#+4
   \   00000016   00A8               ADD      R0,SP,#+0
   \   00000018   ........           BL       PIO_Configure
     82            
     83              // Enable the peripheral clock in the PMC
     84              PMC_EnablePeripheral(BOARD_ID_USART);
   \   0000001C   0E20               MOVS     R0,#+14
   \   0000001E   ........           BL       PMC_EnablePeripheral
     85          
     86              // Configure the USART in the desired mode @ 115200 baud
     87              USART_Configure(BOARD_USART_BASE, mode, 115200, BOARD_MCK);
   \   00000022   ........           LDR.W    R3,??DataTable13_1  ;; 0x2dc6c00
   \   00000026   5FF4E132           MOVS     R2,#+115200
   \   0000002A   2100               MOVS     R1,R4
   \   0000002C   ........           LDR.W    R0,??DataTable13_2  ;; 0x40094000
   \   00000030   ........           BL       USART_Configure
     88          
     89             // Enable USART receiver & transmitter
     90              USART_SetTransmitterEnabled(BOARD_USART_BASE, 1);
   \   00000034   0121               MOVS     R1,#+1
   \   00000036   ........           LDR.W    R0,??DataTable13_2  ;; 0x40094000
   \   0000003A   ........           BL       USART_SetTransmitterEnabled
     91              USART_SetReceiverEnabled(BOARD_USART_BASE, 1);
   \   0000003E   0121               MOVS     R1,#+1
   \   00000040   ........           LDR.W    R0,??DataTable13_2  ;; 0x40094000
   \   00000044   ........           BL       USART_SetReceiverEnabled
     92          }
   \   00000048   20B0               ADD      SP,SP,#+128
   \   0000004A   10BD               POP      {R4,PC}          ;; return
     93          
     94          
     95          //------------------------------------------------------------------------------
     96          //     function sends ASCII text header to screen
     97          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     98          void show_menu(void) {
   \                     show_menu:
   \   00000000   80B5               PUSH     {R7,LR}
     99            
    100            // Console Output via USART to user HyperTerminal
    101            
    102            putchar(12); // clear screen
   \   00000002   0C20               MOVS     R0,#+12
   \   00000004   ........           BL       putchar
    103          
    104            printf("\n\r*************************************************\n\r");
   \   00000008   ........           LDR.W    R0,??DataTable13_3
   \   0000000C   ........           BL       printf
    105            printf("   Holt Integrated Circuits HI-6130_40 EBI Project   \n\r");
   \   00000010   ........           LDR.W    R0,??DataTable13_4
   \   00000014   ........           BL       printf
    106            printf("        Compiled: %s %s        \n\r", __DATE__, __TIME__);
   \   00000018   ........           LDR.W    R2,??DataTable13_5
   \   0000001C   ........           LDR.W    R1,??DataTable13_6
   \   00000020   ........           LDR.W    R0,??DataTable13_7
   \   00000024   ........           BL       printf
    107            printf("*************************************************\n\n\r");
   \   00000028   ........           LDR.W    R0,??DataTable13_8
   \   0000002C   ........           BL       printf
    108            #if(BC_ena) 
    109              printf("   BC On   "); 
    110            #else 
    111              printf("   BC Off  ");
   \   00000030   ........           LDR.W    R0,??DataTable13_9
   \   00000034   ........           BL       printf
    112            #endif
    113            #if(SMT_ena) 
    114              printf("SMT On    ");
    115            #elif(IMT_ena) 
    116              printf("IMT On    ");
    117            #else 
    118              printf("MT Off   ");
   \   00000038   ........           LDR.W    R0,??DataTable13_10
   \   0000003C   ........           BL       printf
    119            #endif
    120            #if(RT1_ena) 
    121              printf("RT1 On   ");
   \   00000040   ........           LDR.W    R0,??DataTable13_11
   \   00000044   ........           BL       printf
    122            #else 
    123              printf("RT1 Off  ");
    124            #endif
    125            #if(RT2_ena) 
    126              printf("RT2 On");
   \   00000048   ........           LDR.W    R0,??DataTable13_12
   \   0000004C   ........           BL       printf
    127            #else 
    128              printf("RT2 Off");
    129            #endif
    130              printf("\n\n\r");
   \   00000050   ....               ADR.N    R0,??DataTable1  ;; "\n\n\r"
   \   00000052   ........           BL       printf
    131            #if(BC_ena) 
    132              printf(" Press '1' to step BC and list results...\n\r");
    133              printf(" Press '2' to list BC configuration...\n\r");
    134              printf(" Press '3' to list BC condition codes & GP flags...\n\r");
    135            #endif
    136            #if(SMT_ena || IMT_ena)
    137              printf(" Press '4' to list MT configuration...\n\r");
    138              printf(" Press '5' to list MT results, last msg...\n\r");
    139            #endif
    140              printf(" Press '6' to list HW interrupt status...\n\r");
   \   00000056   ........           LDR.W    R0,??DataTable13_13
   \   0000005A   ........           BL       printf
    141            #if(BC_ena) 
    142              printf(" Press '7' to list BC interrupt status...\n\r");
    143            #endif
    144            #if(RT1_ena || RT2_ena)
    145              printf(" Press '8' to list RT interrupt status...\n\r");
   \   0000005E   ........           LDR.W    R0,??DataTable13_14
   \   00000062   ........           BL       printf
    146            #endif
    147            #if(SMT_ena || IMT_ena)
    148              printf(" Press '9' to list MT interrupt status...\n\r");
    149            #endif
    150              
    151              printf(" NOTE: Options 6-9 clear the accessed Pending Interrupt Register!\n\r"); 
   \   00000066   ........           LDR.W    R0,??DataTable13_15
   \   0000006A   ........           BL       printf
    152              print_line();
   \   0000006E   ........           BL       print_line
    153              printf("\n\r");
   \   00000072   ....               ADR.N    R0,??DataTable1_1  ;; 0x0A, 0x0D, 0x00, 0x00
   \   00000074   ........           BL       printf
    154              print_menuprompt();
   \   00000078   ........           BL       print_menuprompt
    155          
    156          } // end of show_menu()
   \   0000007C   01BD               POP      {R0,PC}          ;; return
    157          
    158          
    159          #if(BC_ena) 
    160          //------------------------------------------------------------------------------
    161          //	This function generates a BC external trigger pulse for the HI-613x. 
    162          //	The pin has a pull-down with a push button pulling high. This function
    163          //	provides an alternate, software-generated trigger. To avoid contention
    164          //	with the button, the PA0 GPIO rests in high-z input mode. The PAOUT
    165          //	register sets PA0 high, so this function simply pulses the pin in 
    166          //	output mode to generate trigger.
    167          //
    168          //	After triggering, an in-line delay provides adequate time for 
    169          //	worst case message completion, then console output displays 
    170          //	formatted message results
    171          //------------------------------------------------------------------------------
    172          void bc_last_msg_console(void) {
    173          
    174            unsigned short int i, j, k, addr, wordcount=8, mcsb[10], data[32];
    175            char rtrt=0,bcast=0,mcode=0,tx=0,nr=0,mtype=0; //,mcd=0;
    176          
    177            // formfeed 
    178            putchar(12); 	
    179            printf("\n\rResults From Last Message Issued by BC\n\r");
    180            print_line();
    181            printf("Message Type: ");
    182          
    183          	// read block address for the last message 
    184          	addr = pH6130->BC_LAST_MSG_BLOCK_ADDR_REG;
    185          	// read BC Control Word 
    186          	mcsb[0] = *((unsigned int *)(0x60000000 + (addr<<1)));
    187          	// read Command Word 
    188          	addr++;
    189          	mcsb[1] = *((unsigned int *)(0x60000000 + (addr<<1)));
    190                  
    191            if((mcsb[1] & 0xF800) == 0xF800) {
    192          	printf("Broadcast ");
    193          	bcast = 1;
    194            }
    195          
    196            // RT-RT message? 
    197            if(mcsb[0] & 1) {
    198          	rtrt=1;
    199          	printf("RT-RT Message, ");
    200          	wordcount = 10;
    201            }
    202          
    203            // read rest of control-status block 
    204          	for (i=2,addr++; i<wordcount; i++,addr++) {
    205          		mcsb[i] = *((unsigned int *)(0x60000000 + (addr<<1)));
    206          	}
    207          
    208            
    209            if(!rtrt) {
    210          	if(mcsb[1] & (1<<10)) {
    211          	    printf("Tx ");
    212                      tx = 1;
    213                  }
    214          	else printf("Rx ");
    215            }
    216          
    217          //mtype = mcsb[0] & 7;
    218            // check CW subaddress field to detect mode code 
    219            j = mcsb[1] & 0x03E0;
    220            if((j == 0) || (j == 0x03E0)) {
    221                // mode code 
    222                mcode = 1;
    223                i = 0x1F & mcsb[1];
    224                if(i > 15) {
    225                    wordcount = 1;
    226                    addr = mcsb[2];
    227          			data[0] = *((unsigned int *)(0x60000000 + (addr<<1)));
    228          
    229              //    mcd=1;
    230                    printf("Mode Code %02d With Data 0x%.2X%.2X\n\n\r", i, (char)(data[0]>>8), (char)data[0]);
    231                }
    232                else {
    233                    wordcount = 0;
    234                    if(mcsb[1] & (1<<10)) printf("Mode Code %02d w/o Data\n\n\r", i);
    235                    // undef Rx MC0-15 
    236                    else printf("Mode Code %02d w/o Data, Undefined\n\n\r", i);
    237                }
    238            }
    239            
    240            else {
    241                printf("Subaddress Command, ");
    242                wordcount = mcsb[1] & 0x1F;
    243                if (!wordcount) wordcount = 32;
    244                printf("%d data word",wordcount);
    245                if(wordcount!=1) printf("s");
    246                printf("\n\n\r"); 
    247            }                                     
    248          
    249            if (rtrt) {
    250              // validity check RT-RT 
    251              if(mcode) printf("RT-RT problem: RxCW mode code.\n\r");
    252              // CW1 = Rx? 
    253              if (tx) printf("RT-RT problem: RxCW is transmit.\n\r");
    254              // CW2 = Tx? 
    255              if(!(mcsb[8] & (1<<10))) printf("RT-RT problem: TxCW is receive.\n\r");
    256              // check CW2 mode code 
    257              j = mcsb[8] & 0x03E0;
    258              if((j == 0) || (j == 0x03E0)) printf("RT-RT problem: TxCW mode code.\n\r");
    259              // rule-out CW1 address = CW2 address 
    260              i = mcsb[1] & 0xF800;
    261              j = mcsb[8] & 0xF800;
    262              if(i == j) printf("RT-RT problem: RxCW & TxCW have same RT addr.\n\r");
    263              // rule-out different word counts 
    264              i = mcsb[8] & 0x001F;
    265              if(i != wordcount) printf("RT-RT problem: RxCW & TxCW word counts differ.\n\r");
    266              printf("\n\r");
    267          
    268              i = mcsb[1];
    269              printf("CW1: 0x%.2X%.2X", (char)(i>>8), (char)i);
    270              printf(" = %02d-%1d-%02d-%02d     ", i>>11, (0x0400 & i)>>10, (0x03E0 & i)>>5, (0x001F & i));
    271              if(bcast) printf("RSW not applicable\n\r");
    272              else {
    273                  i = mcsb[9];
    274                  printf("RxSW: 0x%.2X%.2X", (char)(i>>8), (char)i);
    275                  printf(" = RT%02d ", (char)(i>>11));
    276                  i &= 0x7FF;
    277                  if(!i) printf("CS\n\r");
    278                  else {
    279                      if(i & (1<<10)) printf("ME ");
    280                      if(i & (1<<9)) printf("INST ");
    281                      if(i & (1<<8)) printf("SRQ ");
    282                      if(i & (7<<5)) printf("RSV ");
    283                      if(i & 16) printf("BCR ");
    284                      if(i & 8) printf("BSY ");
    285                      if(i & 4) printf("SSF ");
    286                      if(i & 2) printf("DBCA ");
    287                      if(i & 1) printf("TF ");
    288                      printf("\n\r");
    289                  }
    290              }
    291              i = mcsb[8];
    292              printf("CW2: 0x%.2X%.2X", (char)(i>>8), (char)i);
    293              printf(" = %02d-%1d-%02d-%02d     ", (char)(i>>11), (char)((0x0400 & i)>>10), (char)((0x03E0 & i)>>5), (char)((0x001F & i)));
    294              i = mcsb[7];
    295              printf("TxSW: 0x%.2X%.2X", (char)(i>>8), (char)i);
    296              printf(" = RT%02d ", (char)(i>>11));
    297              i &= 0x7FF;
    298              if(!i) printf("CS\n\n\r");
    299              else {
    300                  if(i & (1<<10)) printf("ME ");
    301                  if(i & (1<<9)) printf("INST ");
    302                  if(i & (1<<8)) printf("SRQ ");
    303                  if(i & (7<<5)) printf("RSV ");
    304                  if(i & 16) printf("BCR ");
    305                  if(i & 8) printf("BSY ");
    306                  if(i & 4) printf("SSF ");
    307                  if(i & 2) printf("DBCA ");
    308                  if(i & 1) printf("TF ");
    309                  printf("\n\n\r");
    310              }
    311              
    312              // read Condition Code & General Purpose Flag register
    313          
    314          	j = pH6130->BC_CCODE_AND_GPF_REG;
    315          
    316            }       // end rtrt
    317                  
    318                  else { 	// not rtrt
    319          
    320          	    // display Command Word  
    321          	    i = mcsb[1];
    322          	    printf("CW: 0x%.2X%.2X", (char)(i>>8), (char)i);
    323          	    printf(" = %02d-%1d-%02d-%02d     ", (char)(i>>11), (char)((0x0400 & i)>>10), (char)((0x03E0 & i)>>5), (char)((0x001F & i)));
    324                      
    325                      // read Condition Code & General Purpose Flag register
    326                      
    327          
    328          		j = pH6130->BC_CCODE_AND_GPF_REG;
    329          
    330                          
    331          	    // check broadcast 
    332          	    if (bcast) printf("SW not applicable\n\n\r");
    333          
    334          	    else {
    335          		// not broadcast, check if No Response timeout 
    336          		if(j & (1<<8)) {
    337          		    // normal subaddress msg without RT response, excl rt-rt                   
    338          		    printf("SW not received\n\n\r");
    339          		    nr = 1;
    340          		}
    341          		else {
    342          		    // normal subaddress msg with RT response, excl rt-rt 
    343          		    i = mcsb[7];
    344          		    // decode received RT status 
    345          		    printf("SW: 0x%.2X%.2X", (char)(i>>8), (char)i);
    346          		    printf(" = RT%02d ",i>>11);
    347          		    i &= 0x7FF;
    348          		    if(!i) printf("CS\n\n\r");
    349          		    else {
    350          			if(i & (1<<10)) printf("ME ");
    351          			if(i & (1<<9)) printf("INST ");
    352          			if(i & (1<<8)) printf("SRQ ");
    353          			if(i & (7<<5)) printf("RSV ");
    354          			if(i & 16) printf("BCR ");
    355          			if(i & 8) printf("BSY ");
    356          			if(i & 4) printf("SSF ");
    357          			if(i & 2) printf("DBCA ");
    358          			if(i & 1) printf("TF ");
    359          		        printf("\n\n\r");	
    360                              }
    361                          }
    362                      }
    363          	}	// end "not rtrt"
    364          
    365          	// BC Control Word for message 
    366          	i = mcsb[0];
    367          	printf("BC Control Word: 0x%.2X%.2X  \n\r", (char)(i>>8), (char)i);
    368          	if(i & (1<<15)) printf("MC17TTL ");
    369          	if(i & (1<<14)) printf("MEmask ");
    370          	if(i & (1<<13)) printf("SRQmask ");
    371          	if(i & (1<<12)) printf("BSYmask ");
    372          	if(i & (1<<11)) printf("SSFmask ");
    373          	if(i & (1<<10)) printf("TFmask ");
    374          	if(i & (1<<9)) printf("RSVmask ");
    375          	if(i & (1<<8)) printf("RetryEna ");
    376          	if(i & (1<<7)) printf("UseBusA ");
    377          	else           printf("UseBusB ");
    378          	if(i & (1<<6)) printf("SelfTest ");
    379          	if(i & (1<<5)) printf("maskBCR ");
    380          	if(i & (1<<4)) printf("EOMirq ");
    381          	if((i & 7) == 0) printf("NonBcstSA ");
    382          	if((i & 7) == 1) printf("RTRT ");
    383          	if((i & 7) == 2) printf("BcstSA ");
    384          	if((i & 7) == 3) printf("BcstRTRT ");
    385          	if((i & 7) == 4) printf("MC ");
    386          	if((i & 7) == 5) printf("RTRT_MC?? ");
    387          	if((i & 7) == 6) printf("BcstMC ");
    388          	if((i & 7) == 7) printf("BcstRTRT_MC?? ");
    389          	printf("\n\r");
    390          
    391          	k = (i & 2) >> 1;
    392          	// Block Control broadcast format bit 1 should agree w/ CW1 
    393          	if(k != bcast) printf("The Cmd Word and Control Word bit 1 disagree on broadcast format.\n\r");
    394          	k = (i & 4) >> 2;
    395          	// Block Control mode code format bit 2 should agree w/ CW1 
    396          	if(k != mcode) printf("The Cmd Word and Control Word bit 2 disagree on mode code format.\n\r");
    397          	printf("\n\r");
    398          
    399          
    400          	// Block Status Word 
    401          	i = mcsb[5];
    402          	printf("Block Status Word: 0x%.2X%.2X \n\r", (char)(i>>8), (char)i);
    403          	if(i & (1<<14)) printf("SOM  ");
    404          	if(i & (1<<15)) printf("EOM  ");
    405          	if(i & (1<<13)) printf("BusB  ");
    406          	else printf("Bus A  ");
    407          	if(i & (1<<12)) printf("ErrOcc ");
    408          	if(i & (1<<11)) printf("SSet  ");
    409          	if(i & (1<<9)) printf("NoResp  ");
    410          	if(i & (1<<8)) printf("LpBk  ");
    411          	if(i & (1<<6)) printf("2retry  ");
    412          	else if(i & (1<<5)) printf("1retry  ");
    413          	if(i & (1<<4)) printf("GDB  ");
    414          	if(i & (1<<3)) printf("WAG  ");
    415          	if(i & (1<<2)) printf("WdCt  ");
    416          	if(i & (1<<1)) printf("SyncErr  ");
    417          	if(i & (1<<0)) printf("InvWd  ");
    418          	if(i & (1<<10)) printf("FmtErr  ");
    419          	if(i & (1<<7)) printf("MSSet  ");
    420          	printf("\n\n\r");
    421          
    422          	// j = Condition Code Register value
    423          	printf("Condition Code Register: 0x%.2X%.2X\n\r", (char)(j>>8), (char)j);
    424          	if(j==0x0000) printf("BC Stopped: No Condition Codes or Gen Purpose Flags Are Set.");
    425          	else if(j==0x8000) printf("BC Running: No Condition Codes or Gen Purpose Flags Are Set.");
    426          	else if(j & (1<<15)) printf("BC Is Running.\n\r");
    427          	else printf("BC Not Running.\n\r");
    428          	if(j & (1<<14)) printf("2Retries  ");
    429          	if(j & (1<<13)) printf("1Retry  ");
    430          	if(j & (1<<12)) printf("BadMsg  ");
    431          	if(j & (1<<10)) printf("GdDataBlk  ");
    432          	if(j & (1<<9)) printf("FmtErr  ");
    433          	if(j & (1<<8)) printf("NoResp  ");
    434          	if(j & (1<<7)) printf("GPF7  ");
    435          	if(j & (1<<6)) printf("GPF6  ");
    436          	if(j & (1<<5)) printf("GPF5  ");
    437          	if(j & (1<<4)) printf("GPF4  ");
    438          	if(j & (1<<3)) printf("GPF3  ");
    439          	if(j & (1<<2)) printf("GPF2  ");
    440          	if(j & (1<<1)) printf("LT-GPF1  ");
    441          	if(j & (1<<0)) printf("EQ-GPF0  ");
    442          	if(j & (1<<11)) printf("MSSet  ");
    443          	printf("\n\n\r");
    444          
    445          	// if not a mode command, read data block then display it
    446          	if(!(mtype & 4)) {
    447          
    448          	    // rule out tx command with no response 
    449          	    if(tx & nr & !rtrt) printf("No RT response, no received data\n\n\r");
    450          
    451          	    else {
    452          	        // store data words as array 
    453          	        addr = mcsb[2];
    454          			for (i=0; i<wordcount; i++,addr++) {
    455          				data[i] = *((unsigned int *)(0x60000000 + (addr<<1)));
    456                                  }
    457                                  
    458          	        // print the Data Buffer start address 
    459          	        printf("Data Addr: 0x%.2X%.2X,      ",(char)(j>>8),(char)j);
    460          
    461          			j = mcsb[2] << 1;
    462          			printf("Bus Addr: 0x6000%.2X%.2X\n\rData:",(char)(j>>8),(char)j);
    463          
    464          			printf("\n\r");
    465          
    466          	        // print data words, 8 words per line 
    467          	        for(i=0; (i<8)&&(i<wordcount); i++) {
    468          			j = data[i];
    469          			printf("0x%.2X%.2X ",(char)(j>>8),(char)j);
    470                          }
    471          	        printf("\n\r");
    472          	        if(wordcount>7) {
    473          	    	    for(i=8; (i<16)&&(i<wordcount); i++) {
    474          					j = data[i];
    475          					printf("0x%.2X%.2X ",(char)(j>>8),(char)j);
    476                          }
    477          				printf("\n\r");
    478                      }
    479          	        if(wordcount>15) {
    480          	    	    for(i=16; (i<24)&&(i<wordcount); i++) {
    481          					j = data[i];
    482          					printf("0x%.2X%.2X ",(char)(j>>8),(char)j);
    483                          }
    484          				printf("\n\r");
    485                      }
    486          	        if(wordcount>23) {
    487          				for(i=24; (i<32)&&(i<wordcount); i++) {
    488          					j = data[i];
    489          	                printf("0x%.2X%.2X ",(char)(j>>8),(char)j);
    490                          }
    491          				printf("\n\r");
    492                      }
    493                  }	// end else "store data words"
    494              }	// end "not a mode command"
    495          
    496          	printf("\n\r");
    497          	print_line();
    498          	print_menuprompt();
    499          
    500          }	// end bc_last_msg_console()
    501          #endif //(BC_ena) 
    502          
    503          
    504          
    505          #if (BC_ena) 
    506          //--------------------------------------------------------------
    507          //  this function lists the BC Config reg 0x0032
    508          //	to the console via UART
    509          //--------------------------------------------------------------
    510          void list_bc_config (void) {
    511          
    512          	unsigned short int i, j;
    513          
    514          
    515          	i = pH6130->BC_CONFIG_REG;
    516          
    517                          
    518          	// formfeed 
    519          	putchar(12); 	
    520          	printf("\n\rBC Configuration Register: 0x%.2X%.2X\n\r",(char)(i>>8),(char)i);
    521          	print_line();
    522          	
    523          	j = (i & 0xC000) >> 14;
    524          	if(j == 1) printf("  20");
    525          	else if(j == 2) printf("  58");
    526          	else if(j == 3) printf(" 138");
    527          	else printf("  15");
    528          	printf("us Timeout (bus dead time)   ");
    529          
    530          	if(i & (1<<13)) printf("Check Control Word Format Bits");
    531          	else printf("Don't Check Control Word Format Bits");
    532          	printf("\n\n\r");
    533          
    534          	if(i & (1<<11)) {
    535          		j = (i & (3<<9)) >> 9;
    536          		if(j==0) printf(" 2 Retries, Same Bus, Same Bus   "); 
    537          		else if(j==2) printf("  2 Retries, Alt Bus, Same Bus   "); 
    538          		else if(j==1) printf("  2 Retries, Same Bus, Alt Bus   "); 
    539          		else printf("   2 Retries, Alt Bus, Alt Bus   "); 
    540          	}
    541          	else if(i & (1<<12)) {
    542          		if(i & (1<<10)) printf("  1 Retry if Msg Fail, Alt Bus   ");
    543          		else printf(" 1 Retry if Msg Fail, Same Bus   ");
    544          	}
    545          	else printf("    No Retries for Msg Failure   ");
    546          
    547          	if(i & (1<<8)) printf("Retry if RT status bit high");
    548          	else printf("No Retry if RT status bit high");
    549          	printf("\n\n\r");
    550          
    551          	if(i & (1<<7)) printf(    " RT status ME w/o data = Valid   ");
    552          	else printf(" RT status ME w/o data = Inval   ");
    553          	if(i & (1<<6)) printf("RT status BSY w/o data = Valid");
    554          	else printf("RT status BSY w/o data = Inval");
    555          	printf("\n\n\r");
    556          
    557          	if(i & (1<<5)) printf("            Msg Gap Timer = On   ");
    558          	else printf("           Msg Gap Timer = Off   ");
    559          	if(i & (1<<4)) printf("Watchdog Frame Timer = On");
    560          	else printf("Watchdog Frame Timer = Off");
    561          	printf("\n\n\r");
    562          
    563          	if(i & (1<<3)) printf("MC17 send Time Tag low 16 bits   ");
    564          	else printf("MC17 send data in msg data blk   ");
    565          	if(i & (1<<2)) printf("MC17 data word always even");
    566          	else printf("MC17 data may be even or odd");
    567          	printf("\n\n\r");
    568          
    569          	if(i & (1<<1)) printf("  Enable 4us Minimum Gap Check   ");
    570          	else printf("   No 4us Minimum Gap Checking   ");
    571          	if(i & (1<<0)) printf("BCR Mask Enabled, BCRME = 1");
    572          	else printf("BCR Mask Disabled, BCRME = 0");
    573          	printf("\n\n\r");
    574          
    575          
    576          		i = pH6130->TTAG_CONFIG_REG;
    577                     
    578          	printf("Timetag Config Register 0x%.2X%.2X  ",(char)(i>>8),(char)i);
    579          
    580          	if(i & (1<<3)) printf("32-bit timebase with ");
    581          	else printf("16-bit timebase with ");
    582          
    583          	i &= 7;
    584          	if(i == 0) printf("clock disabled! ");
    585          	else if(i == 1) printf("ext clock ");
    586          	else if(i == 2) printf("2us clock ");
    587          	else if(i == 3) printf("4us clock ");
    588          	else if(i == 4) printf("8us clock ");
    589          	else if(i == 5) printf("16us clock ");
    590          	else if(i == 6) printf("32us clock ");
    591          	else printf("64us clock ");
    592          	printf("\n\n\r");
    593          
    594          	print_line();
    595            	print_menuprompt();
    596          
    597          }	// end list_bc_config()
    598          #endif //(BC_ena) 
    599          
    600          
    601          #if (BC_ena) 
    602          //-------------------------------------------------------------------------
    603          //    brief	this function lists the BC's Cond Code / GP Flag reg
    604          //		to the console via UART
    605          //-------------------------------------------------------------------------
    606          void list_bc_ccgpf_reg(void) {
    607          
    608          	unsigned short int i;
    609          
    610          
    611          	i = pH6130->BC_CCODE_AND_GPF_REG;
    612          
    613          	// formfeed
    614          	putchar(12); 	
    615          	printf("\n\rBC Condition Code & GP Flag Register: 0x%.2X%.2X\n\r", (char)(i>>8),(char)i);
    616          	print_line();
    617          
    618          	if(i==0x0000) printf("BC Stopped: No Condition Codes or Gen Purpose Flags Are Set.\n\r");
    619          	else if(i==0x8000) printf("BC Running: No Condition Codes or Gen Purpose Flags Are Set.\n\r");
    620          	else if(i & (1<<15)) printf("BC Is Running.\n\n\r");
    621          	else printf("BC Not Running.\n\n\r");
    622          	if(i & (1<<14)) printf("2Retries  ");
    623          	if(i & (1<<13)) printf("1Retry  ");
    624          	if(i & (1<<12)) printf("BadMsg  ");
    625          	if(i & (1<<10)) printf("GdDataBlk  ");
    626          	if(i & (1<<9)) printf("FmtErr  ");
    627          	if(i & (1<<8)) printf("NoResp  ");
    628          	if(i & (1<<7)) printf("GPF7  ");
    629          	if(i & (1<<6)) printf("GPF6  ");
    630          	if(i & (1<<5)) printf("GPF5  ");
    631          	if(i & (1<<4)) printf("GPF4  ");
    632          	if(i & (1<<3)) printf("GPF3  ");
    633          	if(i & (1<<2)) printf("GPF2  ");
    634          	if(i & (1<<1)) printf("LT-GPF1  ");
    635          	if(i & (1<<0)) printf("EQ-GPF0  ");
    636          	if(i & (1<<11)) printf("MSSet  ");
    637          	printf("\n\r");
    638                  
    639          	print_line();
    640             	print_menuprompt();
    641          
    642          }
    643          #endif //(BC_ena) 
    644          
    645          
    646          
    647          #if (BC_ena) 
    648          //-------------------------------------------------------------
    649          //      this function lists bus controller interrupt 
    650          //	configuration to the console via UART. if there
    651          //	are pending BC interrupts, these too are displayed.
    652          //	Function returns the value read from the BC pending
    653          //	interrupt register, since reading the reg clears it.
    654          //-------------------------------------------------------------
    655          unsigned short int list_bc_ints_console (void) {
    656          
    657          	unsigned short int i, j, k=0;
    658          
    659          	// formfeed 
    660          	putchar(12); 	
    661          
    662          	#if(!BC_ena) 
    663          	printf("Bus Controller Is Not Enabled!\n\n\r"); 
    664          	#endif
    665          
    666          
    667          		i = pH6130->BC_INT_ENABLE_REG;
    668          		j = pH6130->BC_INT_OUTPUT_ENABLE_REG;
    669          		k = pH6130->BC_PENDING_INT_REG;
    670          
    671                          
    672          	printf("\n\r Bus Controller Ints   Enabled?   Pin Output?   Pending?\n\r");
    673          	print_line();
    674          
    675          	printf("BC Frame Timer Expired");
    676          	if(!(i & (1<<15))) {	
    677          		// int disabled 
    678          		print_null();
    679          	}
    680          	else {
    681          		// int enabled 
    682          		print_sp1sp();
    683          		// pin output? 
    684          		if(j & (1<<15)) print_b1sp();
    685          		else print_b0sp(); 
    686          		// pending? 
    687          		if(k & (1<<15)) printf("1\n\r");
    688          		else printf("0\n\r"); 
    689          	}
    690          
    691          	printf("Selected Msg Int,EOM=1");
    692          	if(!(i & (1<<14))) {	
    693          		// int disabled 
    694          		print_null();
    695          	}
    696          	else {
    697          		// int enabled 
    698          		print_sp1sp();
    699          		// pin output? 
    700          		if(j & (1<<14)) print_b1sp();
    701          		else print_b0sp(); 
    702          		// pending? 
    703          		if(k & (1<<14)) printf("1\n\r");
    704          		else printf("0\n\r"); 
    705          	}
    706          
    707          	printf("GenPurp Queue Rollover");
    708          	if(!(i & (1<<13))) {	
    709          		// int disabled 
    710          		print_null();
    711          	}
    712          	else {
    713          		// int enabled 
    714          		print_sp1sp();
    715          		// pin output? 
    716          		if(j & (1<<13)) print_b1sp();
    717          		else print_b0sp(); 
    718          		// pending? 
    719          		if(k & (1<<13)) printf("1\n\r");
    720          		else printf("0\n\r"); 
    721          	}
    722          
    723          	printf("   Message Was Retried");
    724          	if(!(i & (1<<12))) {	
    725          		// int disabled 
    726          		print_null();
    727          	}
    728          	else {
    729          		// int enabled 
    730          		print_sp1sp();
    731          		// pin output? 
    732          		if(j & (1<<12)) print_b1sp();
    733          		else print_b0sp(); 
    734          		// pending? 
    735          		if(k & (1<<12)) printf("1\n\r");
    736          		else printf("0\n\r"); 
    737          	}
    738          
    739          	printf("Call Stack Pointer Err");
    740          	if(!(i & (1<<11))) {	
    741          		// int disabled 
    742          		print_null();
    743          	}
    744          	else {
    745          		// int enabled 
    746          		print_sp1sp();
    747          		// pin output? 
    748          		if(j & (1<<11)) print_b1sp();
    749          		else print_b0sp(); 
    750          		// pending? 
    751          		if(k & (1<<11)) printf("1\n\r");
    752          		else printf("0\n\r"); 
    753          	}
    754          
    755          	printf("  Illegal Op Code Trap");
    756          	if(!(i & (1<<10))) {	
    757          		// int disabled 
    758          		print_null();
    759          	}
    760          	else {
    761          		// int enabled 
    762          		print_sp1sp();
    763          		// pin output? 
    764          		if(j & (1<<10)) print_b1sp();
    765          		else print_b0sp(); 
    766          		// pending? 
    767          		if(k & (1<<10)) printf("1\n\r");
    768          		else printf("0\n\r"); 
    769          	}
    770          
    771          	printf("Unexpected RT Stat Bit");
    772          	if(!(i & (1<<9))) {	
    773          		// int disabled 
    774          		print_null();
    775          	}
    776          	else {
    777          		// int enabled 
    778          		print_sp1sp();
    779          		// pin output? 
    780          		if(j & (1<<9)) print_b1sp();
    781          		else print_b0sp(); 
    782          		// pending? 
    783          		if(k & (1<<9)) printf("1\n\r");
    784          		else printf("0\n\r"); 
    785          	}
    786          
    787          	printf("User-Def Int Req Bit 3");
    788          	if(!(i & (1<<8))) {	
    789          		// int disabled 
    790          		print_null();
    791          	}
    792          	else {
    793          		// int enabled 
    794          		print_sp1sp();
    795          		// pin output? 
    796          		if(j & (1<<8)) print_b1sp();
    797          		else print_b0sp(); 
    798          		// pending? 
    799          		if(k & (1<<8)) printf("1\n\r");
    800          		else printf("0\n\r"); 
    801          	}
    802          
    803          	printf("User-Def Int Req Bit 2");
    804          	if(!(i & (1<<7))) {	
    805          		// int disabled 
    806          		print_null();
    807          	}
    808          	else {
    809          		// int enabled 
    810          		print_sp1sp();
    811          		// pin output? 
    812          		if(j & (1<<7)) print_b1sp();
    813          		else print_b0sp(); 
    814          		// pending? 
    815          		if(k & (1<<7)) printf("1\n\r");
    816          		else printf("0\n\r"); 
    817          	}
    818          
    819          	printf("User-Def Int Req Bit 1");
    820          	if(!(i & (1<<6))) {	
    821          		// int disabled 
    822          		print_null();
    823          	}
    824          	else {
    825          		// int enabled 
    826          		print_sp1sp();
    827          		// pin output? 
    828          		if(j & (1<<6)) print_b1sp();
    829          		else print_b0sp(); 
    830          		// pending? 
    831          		if(k & (1<<6)) printf("1\n\r");
    832          		else printf("0\n\r"); 
    833          	}
    834          
    835          	printf("User-Def Int Req Bit 0");
    836          	if(!(i & (1<<5))) {	
    837          		// int disabled 
    838          		print_null();
    839          	}
    840          	else {
    841          		// int enabled 
    842          		print_sp1sp();
    843          		// pin output? 
    844          		if(j & (1<<5)) print_b1sp();
    845          		else print_b0sp(); 
    846          		// pending? 
    847          		if(k & (1<<5)) printf("1\n\r");
    848          		else printf("0\n\r"); 
    849          	}
    850          
    851          	printf("RT Status is Msg Error");
    852          	if(!(i & (1<<4))) {	
    853          		// int disabled 
    854          		print_null();
    855          	}
    856          	else {
    857          		// int enabled 
    858          		print_sp1sp();
    859          		// pin output? 
    860          		if(j & (1<<4)) print_b1sp();
    861          		else print_b0sp(); 
    862          		// pending? 
    863          		if(k & (1<<4)) printf("1\n\r");
    864          		else printf("0\n\r"); 
    865          	}
    866          
    867          	printf("     BC End-of-Message");
    868          	if(!(i & (1<<3))) {	
    869          		// int disabled 
    870          		print_null();
    871          	}
    872          	else {
    873          		// int enabled 
    874          		print_sp1sp();
    875          		// pin output? 
    876          		if(j & (1<<3)) print_b1sp();
    877          		else print_b0sp(); 
    878          		// pending? 
    879          		if(k & (1<<3)) printf("1\n\r");
    880          		else printf("0\n\r"); 
    881          	}
    882          
    883          	printf("     Reserved Bits 2-0");
    884          	print_dddn();
    885          	print_line();
    886          	printf("Note: Reading the BC Pending Interrupt Register clears it!\n\r");
    887          	print_menuprompt();
    888          
    889          	// return value read from the BCW Pending Interrupt Register, now cleared 
    890          	return k;
    891          
    892          }	// end list_bc_ints_console()
    893          
    894          
    895          #endif //(BC_ena) 
    896          
    897          #if(SMT_ena || IMT_ena)
    898          
    899          //-----------------------------------------------------------------------
    900          //    this function lists the MT Config reg 0x0029
    901          //    to the console via UART
    902          //-----------------------------------------------------------------------
    903          void list_mt_config (void) {
    904          
    905          	unsigned short int i, j;
    906          	char smt = 0;
    907          
    908          
    909          	i = pH6130->MT_CONFIG_REG;
    910                         
    911          	// IRIG monitor (imt) or Simple monitor (smt)? 
    912          	if(i & 1) smt = 1;
    913          
    914          	// formfeed 
    915          	putchar(12); 	
    916          	if(smt) printf("\n\rS");
    917          	else    printf("\n\rI");
    918          	printf("MT monitor mode selected.\n\n\r");
    919          
    920          	printf("MT Configuration Register: 0x%.2X%.2X\n\r", (char)(i>>8),(char)i);
    921          	print_line();
    922          
    923          	j = (i & 0xC000) >> 14;
    924          	if(j == 1) printf("  20us Timeout");
    925          	else if(j == 2) printf("  58us Timeout");
    926          	else if(j == 3) printf(" 138us Timeout");
    927          	else printf("  15us Timeout");
    928          	printf(" (bus dead time)   ");
    929          	
    930          	if(i & (1<<12)) printf("2us Gap Check ON");
    931          	else printf("2us Gap Check OFF");
    932          	printf("\n\n\r");
    933          
    934          	j = (i & 0x0300) >> 8;
    935          	if(j==0) printf("  Time Tag last word, last bit   "); 
    936          	else if(j==1) printf("Time Tag first word, first bit   "); 
    937          	else if(j==2) printf(" Time Tag first word, last bit   "); 
    938          	else printf("           Time Tagging is OFF   "); 
    939          
    940          	j = (i & 0x0060) >> 5;
    941          	printf("Start Rec: First Cmd ");
    942          	if(j==0) printf("Word");
    943          	else if(j==1) printf("or Data Word");
    944          	else if(j==2) printf("Sync + 2 bits");
    945          	else printf("or Data Sync + 2 bits");
    946          	printf("\n\n\r");
    947          
    948          	printf("   Invalid Data Word");	
    949          	if(i & (1<<4)) printf("s recorded   ");
    950          	else printf          (" ends mssg   ");
    951          
    952          	printf("Extended Status Flags ");
    953          	if(i & (1<<2)) printf("ON");
    954          	else printf("OFF");
    955          	printf("\n\n\r");
    956          
    957          	if(smt) {
    958          		printf(" SMT using ");
    959          		if(i & 2) printf("48");
    960          		else printf("16");
    961          		printf("-bit Time Tag ");
    962          	}
    963          	else {  // imt
    964          		printf("IMT Pkt Timer starts ");
    965          		if(i & (1<<7)) printf("at PktEnd   ");
    966          		else printf("at Cmd Wd   ");
    967          
    968          		j = (i & 0x0C00) >> 10;
    969          		printf("IMT Hdr Data Type IRIG-106-");
    970          		if(j==0) printf("09  "); 
    971          		else if(j==1) printf("04  "); 
    972          		else if(j==2) printf("05  "); 
    973          		else printf("07  "); 
    974          		printf("\n\n\r");
    975          						 
    976          		printf (" IMT Auto Header & Trailer ");
    977          		if(i & 8) printf ("OFF   ");
    978          		else printf      (" ON   ");
    979          	
    980          		printf ("IMT Data Packet Checksum ");
    981          		if(i & 2) printf ("ON");
    982          		else printf("OFF"); 
    983          	} 
    984          	printf("\n\n\r");
    985          	print_line();
    986          	print_menuprompt();
    987          
    988          }	// end list_mt_config()
    989          
    990          
    991          //-----------------------------------------------------------------------
    992          //    this function lists the MT msg results, last message
    993          //    to the console via UART
    994          //-----------------------------------------------------------------------
    995          
    996          void mt_last_msg_console(void) {
    997          
    998              
    999                  extern const H6130 pH6130; // HI-6130 register struct base address    
   1000          
   1001          	unsigned short int h,i,j,m,addr,dbp,ndw;
   1002          	char k,bswo=3,smt=0,xmf=0,ttag16=0,rtrt=1;
   1003          
   1004          	// formfeed 
   1005          	putchar(12); 	
   1006          
   1007          	if(SMT_ena||IMT_ena) {
   1008          
   1009          		printf("\n\rLast Message Recorded by ");
   1010          
   1011          		// fetch Bus Monitor config word 
   1012          
   1013          		i = pH6130->MT_CONFIG_REG;
   1014          
   1015                                  
   1016          		// extended message status flags enabled? 
   1017          		if(i & 2) xmf = 1;
   1018          		// Simple monitor (smt)? 
   1019          		if(i & 1) {
   1020          			printf("SMT:    ");
   1021          			smt = 1;
   1022          			//--------------------------------------------------------------
   1023          				// for smt, msg block start addr for last msg is in reg 0x31 
   1024          				addr = pH6130->MT_LAST_MSG_STACK_ADDR_REG;
   1025          				// j = address list offset 
   1026          				j = pH6130->MT_ADDR_LIST_POINTER;
   1027          
   1028          				if(!(i&2)) {
   1029          					// smt with 16-bit ttag 
   1030          					ttag16 = 1;
   1031          					// bswo = block status word offset in cmd-stack msg block 
   1032          					bswo = 0;
   1033          					// data block pointer 
   1034          					dbp = *((unsigned int *)(0x60000000 + ((addr+2)<<1)));
   1035          				}
   1036          				else {
   1037          					// smt with 48-bit ttag
   1038          					// bswo = block status word offset in cmd-stack msg block 
   1039          					bswo = 3;
   1040          					// data block pointer 
   1041          					dbp = *((unsigned int *)(0x60000000 + ((addr+6)<<1)));
   1042          				}
   1043          
   1044          				// first msg only, last block start addr = stack start addr 
   1045          				if(addr == *((unsigned int *)(0x60000000 + (j<<1)))) {
   1046          					// for first msg, the number of words stored in the
   1047          					// data stack = next data store addr - stack start addr 
   1048          					ndw = *((unsigned int *)(0x60000000 + ((j+5)<<1))) \
   1049          						- *((unsigned int *)(0x60000000 + ((j+4)<<1)));
   1050          				}
   1051          				else {
   1052          					h = *((unsigned int *)(0x60000000 + ((j+1)<<1)));
   1053          					// h = offset for next store addr in cmd stack block:
   1054          					// examine cmd word, detect both cases for broadcast mode codes 
   1055          					// w/o data, for these, no words are stored in the data stack
   1056          					m = *((unsigned int *)(0x60000000 + ((h-1)<<1)));
   1057          					if     (( m & 0xFFE0) >> 5 == 0x7E0) ndw = 0;
   1058          					else if(( m & 0xFFE0) >> 5 == 0x7FF) ndw = 0;
   1059          					else {
   1060          						// at least 1 word stored in data stack for last msg 
   1061          						// use next d-stack store address to determine number of d-stack words  
   1062          						h = *((unsigned int *)(0x60000000 + ((j+5)<<1)));
   1063          						ndw = h - dbp;
   1064          					}
   1065          				}
   1066          			//--------------------------------------------------------------
   1067          
   1068          			//--------------------------------------------------------------
   1069          		}	// end smt 
   1070          
   1071          
   1072          		else if(i & 8) {
   1073          			// IMT with auto header/trailer OFF 
   1074          			printf("IMT:   ");
   1075          			bswo = 4;
   1076          			// the last msg block addr is in register 0x31 
   1077          
   1078          				addr =pH6130->MT_LAST_MSG_STACK_ADDR_REG;
   1079          
   1080                                          
   1081          			// the stored data starts at the 8th word  
   1082          			dbp = addr+7;
   1083          			// # of msg bytes in word 6
   1084          
   1085          				ndw = *((unsigned int *)(0x60000000 + ((addr+6)<<1)));
   1086          
   1087          			// convert bytes to words
   1088          			ndw = ndw/2;
   1089          			
   1090          		}
   1091          		else  {  
   1092          			// IMT with auto header/trailer ON 
   1093          			printf("IMT:   ");
   1094          			bswo = 4;
   1095          			// last msg block addr is stored in 5th word of MT addr list 
   1096          
   1097          				i = 4 + pH6130->MT_ADDR_LIST_POINTER;
   1098          				addr = *((unsigned int *)(0x60000000 + (i<<1)));
   1099          				// the stored data starts at the 8th word  
   1100          				dbp = addr+7;
   1101          				// # of msg bytes in word 6, convert to words (div-by-2)
   1102          				ndw = (*((unsigned int *)(0x60000000 + (addr+6)<<1)))/2;
   1103          
   1104          		}
   1105          
   1106          		// read Block Status Word 
   1107          
   1108          		i = *((unsigned int *)(0x60000000 + ((addr+bswo)<<1)));
   1109          
   1110                          
   1111          		printf("Block Status Word = 0x%.2X%.2X...\n\n\r", (char)(i>>8),(char)i);
   1112          		if(!smt) printf("* means IMT BSW reserved bit:\n\n\r");
   1113          		printf("           * Start of Msg ");
   1114          		if(!xmf || !smt) printf("n/a    ");
   1115          		else if(i & (1<<14)) printf("= 1    ");
   1116          		else printf("= 0    ");
   1117          		printf("Bus Used = ");
   1118          		if(i & (1<<13)) printf("B\n\n\r");
   1119          		else printf("A\n\n\r");
   1120          
   1121          		printf("             * End of Msg ");
   1122          		if(!xmf || !smt) printf("n/a    ");
   1123          		else if(i & (1<<15)) printf("= 1    ");
   1124          		else printf("= 0    ");
   1125          		printf("Error Occurred = ");
   1126          		if(i & (1<<12)) printf("1\n\n\r");
   1127          		else printf("0\n\n\r");
   1128          
   1129          		printf("        * Good Data Block ");
   1130          		if(!xmf) printf("n/a    ");
   1131          		else if(i & (1<<8)) printf("= 1    ");
   1132          		else printf("= 0    ");
   1133          		printf("Response Timeout = ");
   1134          		if(i & (1<<9)) printf("1\n\n\r");
   1135          		else printf("0\n\n\r");
   1136          
   1137          		printf("* SMT Data Stack Rollover ");
   1138          		if(!xmf) printf("n/a    ");
   1139          		else if(i & (1<<7)) printf("= 1    ");
   1140          		else printf("= 0    ");
   1141          		printf("Illegal Gap Error = ");
   1142          		if(i & (1<<10)) printf("1\n\n\r");
   1143          		else printf("0\n\n\r");
   1144          
   1145          		printf(" * Cmd Word Content Error ");
   1146          		if(!xmf) printf("n/a    ");
   1147          		else if(i & 1) printf("= 1    ");
   1148          		else printf("= 0    ");
   1149          		printf("Word Count Error = ");
   1150          		if(i & (1<<5)) printf("1\n\n\r");
   1151          		else printf("0\n\n\r");
   1152          
   1153          		printf("* RT-RT Gap,Sync,Addr Err ");
   1154          		if(!xmf) printf("n/a    ");
   1155          		else if(i & 4) printf("= 1    ");
   1156          		else printf("= 0    ");
   1157          
   1158          		if(!(i & (1<<11))) {
   1159          			rtrt = 0;
   1160          			printf("Non-");
   1161          		}
   1162          		printf("RT-RT Cmd: ");
   1163          		// fetch & printf CW1 
   1164          		if(!smt)        m = 7; 
   1165          		else if(ttag16) m = 3; 
   1166          		else            m = 7;
   1167          
   1168          			j = *((unsigned int *)(0x60000000 + ((addr+m)<<1)));
   1169          
   1170          		printf("0x%.2X%.2X", (char)(j>>8),(char)j);
   1171          
   1172          		if(rtrt) {
   1173          			// fetch & printf CW2 
   1174          
   1175          				if(!smt) j = *((unsigned int *)(0x60000000 + ((addr+8)<<1)));
   1176          				else j = *((unsigned int *)(0x60000000 + (dbp<<1)));
   1177          
   1178                                          
   1179          			printf("0x%.2X%.2X", (char)(j>>8),(char)j);
   1180          		}
   1181          
   1182          		printf("\n\n\r * RT-RT Cmd Word 2 Error ");
   1183          		if(!xmf) printf("n/a    ");
   1184          		else if(i & 2) printf("= 1    ");
   1185          		else printf("= 0    ");
   1186          
   1187          		printf("Timetag = ");
   1188          		if(smt & ttag16) {	// 16-bit ttag
   1189          
   1190          			i = *((unsigned int *)(0x60000000 + ((addr+1)<<1)));
   1191          
   1192          			printf("0x%.2X%.2X\n\n\r", (char)(i>>8),(char)i);
   1193          		}
   1194          		else {			// 48-bit ttag
   1195          
   1196          				h = *((unsigned int *)(0x60000000 + ((addr+2)<<1)));
   1197          				i = *((unsigned int *)(0x60000000 + ((addr+1)<<1)));
   1198          				m = *((unsigned int *)(0x60000000 + (addr<<1)));
   1199          
   1200          			printf("0x%.2X%.2X", (char)(h>>8),(char)h);
   1201          			printf("%.2X%.2X", (char)(i>>8),(char)i);
   1202          			printf("%.2X%.2X\n\n\r", (char)(m>>8),(char)m);
   1203          		}
   1204          		
   1205          		if(smt) {
   1206          			if(!ndw) printf("No Words Stored in Data Stack    (Broadcast Mode Code w/o Data)\n\n\r");
   1207          			else {
   1208          				if(ndw<9) printf(" ");
   1209          				printf("Msg Words 2-%d at Addr 0x%.2X%.2X   ", ndw+1, (char)(dbp>>8),(char)dbp);
   1210          			}
   1211          		}
   1212          
   1213          		else {
   1214          			if(ndw<10) printf("  %d",ndw);
   1215          			else printf(" %d",ndw);
   1216          			printf(" Msg Words at Addr: ");
   1217          			printf("0x%.2X%.2X   ", (char)(dbp>>8),(char)dbp);
   1218          		}
   1219          		if(ndw) {
   1220          
   1221          				dbp = dbp<<1;
   1222          				printf("Bus Debug Addr: 0x6000%.2X%.2X", (char)(dbp>>8),(char)(dbp));
   1223          
   1224          			printf("\n\n\r");
   1225          		}
   1226          
   1227          		// only for imt, or smt using 48-bit ttag option
   1228          		// (smt using 16-bit ttag option does not store gap time word):
   1229          		// get gap time word, the upper and lower bytes 
   1230          		// express both TxRT and RxRT gap times for RT-RT messages... 
   1231          		if(!smt || (smt & !ttag16)) {
   1232          			if(!smt) m = 5;
   1233          			else if(!ttag16) m = 4;
   1234          
   1235          			j = *((unsigned int *)(0x60000000 + ((addr+m)<<1)));
   1236          
   1237                                          
   1238          			// lower byte gives gap time for non-RT-RT msgs,
   1239          			// and gives the TxRT gap for RT-RT msgs 
   1240          			k = 0;
   1241          			i = j&0xFF;
   1242          			// expressed in 0.1us increments, parse byte into 
   1243          			// whole number k and tenths digit i for display 
   1244          			while (i >= 10) {
   1245          				i -= 10;
   1246          				k += 1;
   1247          			}
   1248          			if(k<10) printf(" ");
   1249          			if(rtrt) printf("       Tx");
   1250          			//else printf("         ");
   1251          			printf("RT Response = %d.%dus    ", k,i);
   1252          			if(!k && !i) printf("(Broadcast?)");
   1253          			if(!rtrt) printf("\n\r");
   1254          
   1255          			// upper byte is non-zero for RT-RT only,
   1256          			// gives the RxRT gap if not broadcast msg 
   1257          			else {
   1258          				k = 0;
   1259          				i = (j>>8) & 0xFF;
   1260          				while (i >= 10) {
   1261          					i -= 10;
   1262          					k += 1;
   1263          				}
   1264          				printf("RxRT Response = %d.%dus ", k,i);
   1265          				if(!k && !i) printf("(Broadcast?)");
   1266          				printf("\n\r");
   1267          			}
   1268          		}
   1269          	}	
   1270          	print_line();
   1271          	print_menuprompt();
   1272          
   1273          }	// end mt_last_msg_console()
   1274          
   1275          
   1276          //-----------------------------------------------------------------------
   1277          //	this function lists bus monitor interrupt 
   1278          //	configuration to the console via UART. if there
   1279          //	are pending MT interrupts, these too are displayed.
   1280          //	Function returns the value read from the MT pending
   1281          //	interrupt register, since reading the reg clears it.
   1282          //-----------------------------------------------------------------------
   1283          unsigned short int list_mt_ints_console(void) {
   1284          
   1285             
   1286                  extern const H6130 pH6130; // HI-6130 register struct base address    
   1287          
   1288          	unsigned short i, j, k=0;
   1289          	char smt = 0;
   1290          
   1291          
   1292          		i = pH6130->MT_CONFIG_REG;
   1293          		if(i & 1) smt = 1;
   1294          		i = pH6130->MT_INT_ENABLE_REG;
   1295          		j = pH6130->MT_INT_OUTPUT_ENABLE_REG;
   1296          		k = pH6130->MT_PENDING_INT_REG;
   1297          
   1298                          
   1299          
   1300          	// formfeed 
   1301          	putchar(12); 	
   1302          	// IRIG monitor (imt) or Simple monitor (smt)? 
   1303                  printf("\n\r");
   1304          	if(smt) printf("SMT mode is selected by MT Config Register bit 0.\n\n\r");
   1305          	else    printf("IMT mode is selected by MT Config Register bit 0.\n\n\r");
   1306          	printf("   Bus Monitor Ints    Enabled?   Pin Output?   Pending?\n\r");
   1307          	print_line();
   1308          
   1309          	if(!smt) {
   1310          		// IRIG-106 mode, disregard bits 7,4,2,1,0 
   1311          		printf("End of Pkt,Buffer Full");
   1312          		if(!(i & FULL_EOP)) {	
   1313          			// int disabled 
   1314          			print_null();
   1315          		}
   1316          		else {
   1317          			// int enabled 
   1318          			print_sp1sp();
   1319          			// pin output? 
   1320          			if(j & FULL_EOP) print_b1sp();
   1321          			else print_b0sp(); 
   1322          			// pending? 
   1323          			if(k & FULL_EOP) printf("1\n\r");
   1324          			else printf("0\n\r"); 
   1325          		}
   1326          
   1327          		printf("Offset before FULL_EOP");
   1328          		if(!(i & FULL_OFS)) {	
   1329          			// int disabled 
   1330          			print_null();
   1331          		}
   1332          		else {
   1333          			// int enabled 
   1334          			print_sp1sp();
   1335          			// pin output? 
   1336          			if(j & FULL_OFS) print_b1sp();
   1337          			else print_b0sp(); 
   1338          			// pending? 
   1339          			if(k & FULL_OFS) printf("1\n\r");
   1340          			else printf("0\n\r"); 
   1341          		}
   1342          
   1343          		printf("Pkt Max 1553 Msg Words");
   1344          		if(!(i & MAXWORDS)) {	
   1345          			// int disabled 
   1346          			print_null();
   1347          		}
   1348          		else {
   1349          			// int enabled 
   1350          			print_sp1sp();
   1351          			// pin output? 
   1352          			if(j & MAXWORDS) print_b1sp();
   1353          			else print_b0sp(); 
   1354          			// pending? 
   1355          			if(k & MAXWORDS) printf("1\n\r");
   1356          			else printf("0\n\r"); 
   1357          		}
   1358          
   1359          		printf("Pkt Max 1553 Msg Count");
   1360          		if(!(i & MAXMSGS)) {	
   1361          			// int disabled 
   1362          			print_null();
   1363          		}
   1364          		else {
   1365          			// int enabled 
   1366          			print_sp1sp();
   1367          			// pin output? 
   1368          			if(j & MAXMSGS) print_b1sp();
   1369          			else print_b0sp(); 
   1370          			// pending? 
   1371          			if(k & MAXMSGS) printf("1\n\r");
   1372          			else printf("0\n\r"); 
   1373          		}
   1374          	
   1375          		printf(" Max Gap Time Exceeded");
   1376          		if(!(i & MAXGAP)) {	
   1377          			// int disabled 
   1378          			print_null();
   1379          		}
   1380          		else {
   1381          			// int enabled 
   1382          			print_sp1sp();
   1383          			// pin output? 
   1384          			if(j & MAXGAP) print_b1sp();
   1385          			else print_b0sp(); 
   1386          			// pending? 
   1387          			if(k & MAXGAP) printf("1\n\r");
   1388          			else printf("0\n\r"); 
   1389          		}
   1390          	
   1391          		printf("Max Pkt Recording Time");
   1392          		if(!(i & MAXTIME)) {	
   1393          			// int disabled 
   1394          			print_null();
   1395          		}
   1396          		else {
   1397          			// int enabled 
   1398          			print_sp1sp();
   1399          			// pin output? 
   1400          			if(j & MAXTIME) print_b1sp();
   1401          			else print_b0sp(); 
   1402          			// pending? 
   1403          			if(k & MAXTIME) printf("1\n\r");
   1404          			else printf("0\n\r"); 
   1405          		}
   1406          	
   1407          		printf("      Host Packet Stop");
   1408          		if(!(i & HPKTSTOP)) {	
   1409          			// int disabled 
   1410          			print_null();
   1411          		}
   1412          		else {
   1413          			// int enabled 
   1414          			print_sp1sp();
   1415          			// pin output? 
   1416          			if(j & HPKTSTOP) print_b1sp();
   1417          			else print_b0sp(); 
   1418          			// pending? 
   1419          			if(k & HPKTSTOP) printf("1\n\r");
   1420          			else printf("0\n\r"); 
   1421          		}
   1422          				 
   1423          		printf("Stack End Addr Written");
   1424          		if(!(i & STKROVR)) {	
   1425          			// int disabled 
   1426          			print_null();
   1427          		}
   1428          		else {
   1429          			// int enabled 
   1430          			print_sp1sp();
   1431          			// pin output? 
   1432          			if(j & STKROVR) print_b1sp();
   1433          			else print_b0sp(); 
   1434          			// pending? 
   1435          			if(k & STKROVR) printf("1\n\r");
   1436          			else printf("0\n\r"); 
   1437          		}
   1438          
   1439          		printf(" Hit Cmd Stack Address");
   1440          		if(!(i & STKADRSS)) {	
   1441          			// int disabled 
   1442          			print_null();
   1443          		}
   1444          		else {
   1445          			// int enabled 
   1446          			print_sp1sp();
   1447          			// pin output? 
   1448          			if(j & STKADRSS) print_b1sp();
   1449          			else print_b0sp(); 
   1450          			// pending? 
   1451          			if(k & STKADRSS) printf("1\n\r");
   1452          			else printf("0\n\r"); 
   1453          		}
   1454          
   1455          		printf(" IRIG-106 Packet Ready");
   1456          		if(!(i & PKTREADY)) {	
   1457          			// int disabled 
   1458          			print_null();
   1459          		}
   1460          		else {
   1461          			// int enabled 
   1462          			print_sp1sp();
   1463          			// pin output? 
   1464          			if(j & PKTREADY) print_b1sp();
   1465          			else print_b0sp(); 
   1466          			// pending? 
   1467          			if(k & PKTREADY) printf("1\n\r");
   1468          			else printf("0\n\r"); 
   1469          		}
   1470          
   1471          		printf("Monitor End-of-Message");
   1472          		if(!(i & (1<<3))) {	
   1473          			// int disabled 
   1474          			print_null();
   1475          		}
   1476          		else {
   1477          			// int enabled 
   1478          			print_sp1sp();
   1479          			// pin output? 
   1480          			if(j & (1<<3)) print_b1sp();
   1481          			else print_b0sp(); 
   1482          			// pending? 
   1483          			if(k & (1<<3)) printf("1\n\r");
   1484          			else printf("0\n\r"); 
   1485          		}
   1486          
   1487          		printf("\nIMT Skips Bits 4,2,1,0");
   1488          		print_dddn();
   1489          
   1490          	}		// end if(!smt)
   1491          
   1492          	else {
   1493          		// Simple Monitor mode, disregard bits 15-9 and 2-0 
   1494          
   1495          		printf("SMT Cmd Stack Rollover");
   1496          		if(!(i & STKROVR)) {	
   1497          			// int disabled 
   1498          			print_null();
   1499          		}
   1500          		else {
   1501          			// int enabled 
   1502          			print_sp1sp();
   1503          			// pin output? 
   1504          			if(j & STKROVR) print_b1sp();
   1505          			else print_b0sp(); 
   1506          			// pending? 
   1507          			if(k & STKROVR) printf("1\n\r");
   1508          			else printf("0\n\r"); 
   1509          		}
   1510          	
   1511          		printf("SMT DataStack Rollover");
   1512          		if(!(i & DSTKROVR)) {	
   1513          			// int disabled 
   1514          			print_null();
   1515          		}
   1516          		else {
   1517          			// int enabled 
   1518          			print_sp1sp();
   1519          			// pin output? 
   1520          			if(j & DSTKROVR) print_b1sp();
   1521          			else print_b0sp(); 
   1522          			// pending? 
   1523          			if(k & STKROVR) printf("1\n\r");
   1524          			else printf("0\n\r"); 
   1525          		}
   1526          
   1527          		printf("SMT  Cmd Stack Address");
   1528          		if(!(i & STKADRSS)) {	
   1529          			// int disabled 
   1530          			print_null();
   1531          		}
   1532          		else {
   1533          			// int enabled 
   1534          			print_sp1sp();
   1535          			// pin output? 
   1536          			if(j & STKADRSS) print_b1sp();
   1537          			else print_b0sp(); 
   1538          			// pending? 
   1539          			if(k & STKADRSS) printf("1\n\r");
   1540          			else printf("0\n\r"); 
   1541          		}
   1542          
   1543          		printf("SMT Data Stack Address");
   1544          		if(!(i & DSTKADRSS)) {	
   1545          			// int disabled 
   1546          			print_null();
   1547          		}
   1548          		else {
   1549          			// int enabled 
   1550          			print_sp1sp();
   1551          			// pin output? 
   1552          			if(j & DSTKADRSS) print_b1sp();
   1553          			else print_b0sp(); 
   1554          				// pending? 
   1555          			if(k & DSTKADRSS) printf("1\n\r");
   1556          			else printf("0\n\r"); 
   1557          		}
   1558          
   1559          		printf("RT Status is Msg Error");
   1560          		if(!(i & MSG_ERR)) {	
   1561          			// int disabled 
   1562          			print_null();
   1563          		}
   1564          		else {
   1565          			// int enabled 
   1566          			print_sp1sp();
   1567          			// pin output? 
   1568          			if(j & MSG_ERR) print_b1sp();
   1569          			else print_b0sp(); 
   1570          			// pending? 
   1571          			if(k & MSG_ERR) printf("1\n\r");
   1572          			else printf("0\n\r"); 
   1573          		}
   1574          
   1575          		printf("     MT End-of-Message");
   1576          		if(!(i & MT_EOM)) {	
   1577          			// int disabled 
   1578          			print_null();
   1579          		}
   1580          		else {
   1581          			// int enabled 
   1582          			print_sp1sp();
   1583          			// pin output? 
   1584          			if(j & MT_EOM) print_b1sp();
   1585          			else print_b0sp(); 
   1586          			// pending? 
   1587          			if(k & MT_EOM) printf("1\n\r");
   1588          			else printf("0\n\r"); 
   1589          		}
   1590          	}		// end else .... SMT mode
   1591                    
   1592          	print_line();
   1593          	printf("Note: Reading the MT Pending Interrupt Register clears it!\n\r");
   1594          
   1595          	print_menuprompt();
   1596          
   1597          	// return value read from the MT Pending Interrupt Register, now cleared 
   1598          	return k;
   1599           
   1600          }	// end list_mt_ints_console()
   1601          
   1602          
   1603          #endif  // (SMT_ena || IMT_ena)
   1604          
   1605          
   1606          //-------------------------------------------------------------------------
   1607          //  this function lists hardware interrupt configuration
   1608          //	to the console via UART. if there are pending
   1609          //	hardware interrupts, these too are displayed.
   1610          //	Function returns the value read from the HW pending
   1611          //	interrupt register, since reading the reg clears it.
   1612          //-------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
   1613          unsigned short int list_hw_ints_console (void) {
   \                     list_hw_ints_console:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   1614          
   1615          	unsigned short i, j, k;
   1616                  
   1617          
   1618                  extern const H6130 pH6130; // HI-6130 register struct base address  
   1619          
   1620                  
   1621          	// formfeed 
   1622          	putchar(12); 	
   \   00000002   0C20               MOVS     R0,#+12
   \   00000004   ........           BL       putchar
   1623          	printf("\n\r Hardware Interrupts   Enabled?   Pin Output?   Pending?\n\r");
   \   00000008   ........           LDR.W    R0,??DataTable13_16
   \   0000000C   ........           BL       printf
   1624          	print_line();
   \   00000010   ........           BL       print_line
   1625          
   1626          		i = pH6130->HDW_INT_ENABLE_REG;
   \   00000014   ........           LDR.W    R0,??DataTable13_17
   \   00000018   0068               LDR      R0,[R0, #+0]
   \   0000001A   C08B               LDRH     R0,[R0, #+30]
   \   0000001C   0400               MOVS     R4,R0
   1627          		j = pH6130->HDW_INT_OUTPUT_ENABLE_REG;
   \   0000001E   ........           LDR.W    R0,??DataTable13_17
   \   00000022   0068               LDR      R0,[R0, #+0]
   \   00000024   C08C               LDRH     R0,[R0, #+38]
   \   00000026   0500               MOVS     R5,R0
   1628          		k = pH6130->HDW_PENDING_INT_REG;
   \   00000028   ........           LDR.W    R0,??DataTable13_17
   \   0000002C   0068               LDR      R0,[R0, #+0]
   \   0000002E   8089               LDRH     R0,[R0, #+12]
   \   00000030   0600               MOVS     R6,R0
   1629          		printf("HI-6131 Host SPI Error    n/a         n/a         n/a\n\r");
   \   00000032   ........           LDR.W    R0,??DataTable13_18
   \   00000036   ........           BL       printf
   1630          
   1631                          
   1632          	printf("EE Chksum/Corr RAM Err");
   \   0000003A   ........           LDR.W    R0,??DataTable13_19
   \   0000003E   ........           BL       printf
   1633          	if(!(i & (1<<14))) {	
   \   00000042   6004               LSLS     R0,R4,#+17
   \   00000044   02D4               BMI.N    ??list_hw_ints_console_0
   1634          		// int disabled 
   1635          		print_null();
   \   00000046   ........           BL       print_null
   \   0000004A   11E0               B.N      ??list_hw_ints_console_1
   1636          	}
   1637          	else {
   1638          		// int enabled 
   1639          		print_sp1sp();
   \                     ??list_hw_ints_console_0:
   \   0000004C   ........           BL       print_sp1sp
   1640          		// pin output? 
   1641          		if(j & (1<<14)) print_b1sp();
   \   00000050   6804               LSLS     R0,R5,#+17
   \   00000052   02D5               BPL.N    ??list_hw_ints_console_2
   \   00000054   ........           BL       print_b1sp
   \   00000058   01E0               B.N      ??list_hw_ints_console_3
   1642          		else print_b0sp(); 
   \                     ??list_hw_ints_console_2:
   \   0000005A   ........           BL       print_b0sp
   1643          		// pending? 
   1644          		if(k & (1<<14)) printf("1\n\r");
   \                     ??list_hw_ints_console_3:
   \   0000005E   7004               LSLS     R0,R6,#+17
   \   00000060   03D5               BPL.N    ??list_hw_ints_console_4
   \   00000062   ....               ADR.N    R0,??DataTable2  ;; "1\n\r"
   \   00000064   ........           BL       printf
   \   00000068   02E0               B.N      ??list_hw_ints_console_1
   1645          		else printf("0\n\r"); 
   \                     ??list_hw_ints_console_4:
   \   0000006A   ....               ADR.N    R0,??DataTable2_1  ;; "0\n\r"
   \   0000006C   ........           BL       printf
   1646          	}
   1647          
   1648          	printf("RAM Init/UncorrRAM Err");
   \                     ??list_hw_ints_console_1:
   \   00000070   ........           LDR.W    R0,??DataTable13_20
   \   00000074   ........           BL       printf
   1649          	if(!(i & (1<<13))) {	
   \   00000078   A004               LSLS     R0,R4,#+18
   \   0000007A   02D4               BMI.N    ??list_hw_ints_console_5
   1650          		// int disabled 
   1651          		print_null();
   \   0000007C   ........           BL       print_null
   \   00000080   11E0               B.N      ??list_hw_ints_console_6
   1652          	}
   1653          	else {
   1654          		// int enabled 
   1655          		print_sp1sp();
   \                     ??list_hw_ints_console_5:
   \   00000082   ........           BL       print_sp1sp
   1656          		// pin output? 
   1657          		if(j & (1<<13)) print_b1sp();
   \   00000086   A804               LSLS     R0,R5,#+18
   \   00000088   02D5               BPL.N    ??list_hw_ints_console_7
   \   0000008A   ........           BL       print_b1sp
   \   0000008E   01E0               B.N      ??list_hw_ints_console_8
   1658          		else print_b0sp(); 
   \                     ??list_hw_ints_console_7:
   \   00000090   ........           BL       print_b0sp
   1659          		// pending? 
   1660          		if(k & (1<<13)) printf("1\n\r");
   \                     ??list_hw_ints_console_8:
   \   00000094   B004               LSLS     R0,R6,#+18
   \   00000096   03D5               BPL.N    ??list_hw_ints_console_9
   \   00000098   ....               ADR.N    R0,??DataTable2  ;; "1\n\r"
   \   0000009A   ........           BL       printf
   \   0000009E   02E0               B.N      ??list_hw_ints_console_6
   1661          		else printf("0\n\r"); 
   \                     ??list_hw_ints_console_9:
   \   000000A0   ....               ADR.N    R0,??DataTable2_1  ;; "0\n\r"
   \   000000A2   ........           BL       printf
   1662          	}
   1663          
   1664          	printf("Loopback Fail on Bus A");
   \                     ??list_hw_ints_console_6:
   \   000000A6   ........           LDR.W    R0,??DataTable13_21
   \   000000AA   ........           BL       printf
   1665          	if(!(i & (1<<12))) {	
   \   000000AE   E004               LSLS     R0,R4,#+19
   \   000000B0   02D4               BMI.N    ??list_hw_ints_console_10
   1666          		// int disabled 
   1667          		print_null();
   \   000000B2   ........           BL       print_null
   \   000000B6   11E0               B.N      ??list_hw_ints_console_11
   1668          	}
   1669          	else {
   1670          		// int enabled 
   1671          		print_sp1sp();
   \                     ??list_hw_ints_console_10:
   \   000000B8   ........           BL       print_sp1sp
   1672          		// pin output? 
   1673          		if(j & (1<<12)) print_b1sp();
   \   000000BC   E804               LSLS     R0,R5,#+19
   \   000000BE   02D5               BPL.N    ??list_hw_ints_console_12
   \   000000C0   ........           BL       print_b1sp
   \   000000C4   01E0               B.N      ??list_hw_ints_console_13
   1674          		else print_b0sp(); 
   \                     ??list_hw_ints_console_12:
   \   000000C6   ........           BL       print_b0sp
   1675          		// pending? 
   1676          		if(k & (1<<12)) printf("1\n\r");
   \                     ??list_hw_ints_console_13:
   \   000000CA   F004               LSLS     R0,R6,#+19
   \   000000CC   03D5               BPL.N    ??list_hw_ints_console_14
   \   000000CE   ....               ADR.N    R0,??DataTable2  ;; "1\n\r"
   \   000000D0   ........           BL       printf
   \   000000D4   02E0               B.N      ??list_hw_ints_console_11
   1677          		else printf("0\n\r"); 
   \                     ??list_hw_ints_console_14:
   \   000000D6   ....               ADR.N    R0,??DataTable2_1  ;; "0\n\r"
   \   000000D8   ........           BL       printf
   1678          	}
   1679          
   1680          	printf("Loopback Fail on Bus B");
   \                     ??list_hw_ints_console_11:
   \   000000DC   ........           LDR.W    R0,??DataTable13_22
   \   000000E0   ........           BL       printf
   1681          	if(!(i & (1<<11))) {	
   \   000000E4   2005               LSLS     R0,R4,#+20
   \   000000E6   02D4               BMI.N    ??list_hw_ints_console_15
   1682          		// int disabled 
   1683          		print_null();
   \   000000E8   ........           BL       print_null
   \   000000EC   11E0               B.N      ??list_hw_ints_console_16
   1684          	}
   1685          	else {
   1686          		// int enabled 
   1687          		print_sp1sp();
   \                     ??list_hw_ints_console_15:
   \   000000EE   ........           BL       print_sp1sp
   1688          		// pin output? 
   1689          		if(j & (1<<11)) print_b1sp();
   \   000000F2   2805               LSLS     R0,R5,#+20
   \   000000F4   02D5               BPL.N    ??list_hw_ints_console_17
   \   000000F6   ........           BL       print_b1sp
   \   000000FA   01E0               B.N      ??list_hw_ints_console_18
   1690          		else print_b0sp(); 
   \                     ??list_hw_ints_console_17:
   \   000000FC   ........           BL       print_b0sp
   1691          		// pending? 
   1692          		if(k & (1<<11)) printf("1\n\r");
   \                     ??list_hw_ints_console_18:
   \   00000100   3005               LSLS     R0,R6,#+20
   \   00000102   03D5               BPL.N    ??list_hw_ints_console_19
   \   00000104   ....               ADR.N    R0,??DataTable2  ;; "1\n\r"
   \   00000106   ........           BL       printf
   \   0000010A   02E0               B.N      ??list_hw_ints_console_16
   1693          		else printf("0\n\r"); 
   \                     ??list_hw_ints_console_19:
   \   0000010C   ....               ADR.N    R0,??DataTable2_1  ;; "0\n\r"
   \   0000010E   ........           BL       printf
   1694          	}
   1695          
   1696          	printf("MT Timetag Ct Rollover");
   \                     ??list_hw_ints_console_16:
   \   00000112   ........           LDR.W    R0,??DataTable13_23
   \   00000116   ........           BL       printf
   1697          	if(!(i & (1<<10))) {	
   \   0000011A   6005               LSLS     R0,R4,#+21
   \   0000011C   02D4               BMI.N    ??list_hw_ints_console_20
   1698          		// int disabled 
   1699          		print_null();
   \   0000011E   ........           BL       print_null
   \   00000122   11E0               B.N      ??list_hw_ints_console_21
   1700          	}
   1701          	else {
   1702          		// int enabled 
   1703          		print_sp1sp();
   \                     ??list_hw_ints_console_20:
   \   00000124   ........           BL       print_sp1sp
   1704          		// pin output? 
   1705          		if(j & (1<<10)) print_b1sp();
   \   00000128   6805               LSLS     R0,R5,#+21
   \   0000012A   02D5               BPL.N    ??list_hw_ints_console_22
   \   0000012C   ........           BL       print_b1sp
   \   00000130   01E0               B.N      ??list_hw_ints_console_23
   1706          		else print_b0sp(); 
   \                     ??list_hw_ints_console_22:
   \   00000132   ........           BL       print_b0sp
   1707          		// pending? 
   1708          		if(k & (1<<10)) printf("1\n\r");
   \                     ??list_hw_ints_console_23:
   \   00000136   7005               LSLS     R0,R6,#+21
   \   00000138   03D5               BPL.N    ??list_hw_ints_console_24
   \   0000013A   ....               ADR.N    R0,??DataTable2  ;; "1\n\r"
   \   0000013C   ........           BL       printf
   \   00000140   02E0               B.N      ??list_hw_ints_console_21
   1709          		else printf("0\n\r"); 
   \                     ??list_hw_ints_console_24:
   \   00000142   ....               ADR.N    R0,??DataTable2_1  ;; "0\n\r"
   \   00000144   ........           BL       printf
   1710          	}
   1711          
   1712          	printf("BC Timetag Ct Rollover");
   \                     ??list_hw_ints_console_21:
   \   00000148   ........           LDR.W    R0,??DataTable13_24
   \   0000014C   ........           BL       printf
   1713          	if(!(i & (1<<9))) {	
   \   00000150   A005               LSLS     R0,R4,#+22
   \   00000152   02D4               BMI.N    ??list_hw_ints_console_25
   1714          		// int disabled 
   1715          		print_null();
   \   00000154   ........           BL       print_null
   \   00000158   11E0               B.N      ??list_hw_ints_console_26
   1716          	}
   1717          	else {
   1718          		// int enabled 
   1719          		print_sp1sp();
   \                     ??list_hw_ints_console_25:
   \   0000015A   ........           BL       print_sp1sp
   1720          		// pin output? 
   1721          		if(j & (1<<9)) print_b1sp();
   \   0000015E   A805               LSLS     R0,R5,#+22
   \   00000160   02D5               BPL.N    ??list_hw_ints_console_27
   \   00000162   ........           BL       print_b1sp
   \   00000166   01E0               B.N      ??list_hw_ints_console_28
   1722          		else print_b0sp(); 
   \                     ??list_hw_ints_console_27:
   \   00000168   ........           BL       print_b0sp
   1723          		// pending? 
   1724          		if(k & (1<<9)) printf("1\n\r");
   \                     ??list_hw_ints_console_28:
   \   0000016C   B005               LSLS     R0,R6,#+22
   \   0000016E   03D5               BPL.N    ??list_hw_ints_console_29
   \   00000170   ....               ADR.N    R0,??DataTable2  ;; "1\n\r"
   \   00000172   ........           BL       printf
   \   00000176   02E0               B.N      ??list_hw_ints_console_26
   1725          		else printf("0\n\r"); 
   \                     ??list_hw_ints_console_29:
   \   00000178   ....               ADR.N    R0,??DataTable2_1  ;; "0\n\r"
   \   0000017A   ........           BL       printf
   1726          	}
   1727          
   1728          	printf("RT2 Timetag Valu Match");
   \                     ??list_hw_ints_console_26:
   \   0000017E   ........           LDR.W    R0,??DataTable13_25
   \   00000182   ........           BL       printf
   1729          	if(!(i & (1<<8))) {	
   \   00000186   E005               LSLS     R0,R4,#+23
   \   00000188   02D4               BMI.N    ??list_hw_ints_console_30
   1730          		// int disabled 
   1731          		print_null();
   \   0000018A   ........           BL       print_null
   \   0000018E   11E0               B.N      ??list_hw_ints_console_31
   1732          	}
   1733          	else {
   1734          		// int enabled 
   1735          		print_sp1sp();
   \                     ??list_hw_ints_console_30:
   \   00000190   ........           BL       print_sp1sp
   1736          		// pin output? 
   1737          		if(j & (1<<8)) print_b1sp();
   \   00000194   E805               LSLS     R0,R5,#+23
   \   00000196   02D5               BPL.N    ??list_hw_ints_console_32
   \   00000198   ........           BL       print_b1sp
   \   0000019C   01E0               B.N      ??list_hw_ints_console_33
   1738          		else print_b0sp(); 
   \                     ??list_hw_ints_console_32:
   \   0000019E   ........           BL       print_b0sp
   1739          		// pending? 
   1740          		if(k & (1<<8)) printf("1\n\r");
   \                     ??list_hw_ints_console_33:
   \   000001A2   F005               LSLS     R0,R6,#+23
   \   000001A4   03D5               BPL.N    ??list_hw_ints_console_34
   \   000001A6   ....               ADR.N    R0,??DataTable2  ;; "1\n\r"
   \   000001A8   ........           BL       printf
   \   000001AC   02E0               B.N      ??list_hw_ints_console_31
   1741          		else printf("0\n\r"); 
   \                     ??list_hw_ints_console_34:
   \   000001AE   ....               ADR.N    R0,??DataTable2_1  ;; "0\n\r"
   \   000001B0   ........           BL       printf
   1742          	}
   1743          
   1744          	printf("RT1 Timetag Valu Match");
   \                     ??list_hw_ints_console_31:
   \   000001B4   ........           LDR.W    R0,??DataTable13_26
   \   000001B8   ........           BL       printf
   1745          	if(!(i & (1<<7))) {	
   \   000001BC   2006               LSLS     R0,R4,#+24
   \   000001BE   02D4               BMI.N    ??list_hw_ints_console_35
   1746          		// int disabled 
   1747          		print_null();
   \   000001C0   ........           BL       print_null
   \   000001C4   11E0               B.N      ??list_hw_ints_console_36
   1748          	}
   1749          	else {
   1750          		// int enabled 
   1751          		print_sp1sp();
   \                     ??list_hw_ints_console_35:
   \   000001C6   ........           BL       print_sp1sp
   1752          		// pin output? 
   1753          		if(j & (1<<7)) print_b1sp();
   \   000001CA   2806               LSLS     R0,R5,#+24
   \   000001CC   02D5               BPL.N    ??list_hw_ints_console_37
   \   000001CE   ........           BL       print_b1sp
   \   000001D2   01E0               B.N      ??list_hw_ints_console_38
   1754          		else print_b0sp(); 
   \                     ??list_hw_ints_console_37:
   \   000001D4   ........           BL       print_b0sp
   1755          		// pending? 
   1756          		if(k & (1<<7)) printf("1\n\r");
   \                     ??list_hw_ints_console_38:
   \   000001D8   3006               LSLS     R0,R6,#+24
   \   000001DA   03D5               BPL.N    ??list_hw_ints_console_39
   \   000001DC   ....               ADR.N    R0,??DataTable2  ;; "1\n\r"
   \   000001DE   ........           BL       printf
   \   000001E2   02E0               B.N      ??list_hw_ints_console_36
   1757          		else printf("0\n\r"); 
   \                     ??list_hw_ints_console_39:
   \   000001E4   ....               ADR.N    R0,??DataTable2_1  ;; "0\n\r"
   \   000001E6   ........           BL       printf
   1758          	}
   1759          
   1760          	printf("MT Timetag Value Match");
   \                     ??list_hw_ints_console_36:
   \   000001EA   ........           LDR.W    R0,??DataTable13_27
   \   000001EE   ........           BL       printf
   1761          	if(!(i & (1<<6))) {	
   \   000001F2   6006               LSLS     R0,R4,#+25
   \   000001F4   02D4               BMI.N    ??list_hw_ints_console_40
   1762          		// int disabled 
   1763          		print_null();
   \   000001F6   ........           BL       print_null
   \   000001FA   11E0               B.N      ??list_hw_ints_console_41
   1764          	}
   1765          	else {
   1766          		// int enabled 
   1767          		print_sp1sp();
   \                     ??list_hw_ints_console_40:
   \   000001FC   ........           BL       print_sp1sp
   1768          		// pin output? 
   1769          		if(j & (1<<6)) print_b1sp();
   \   00000200   6806               LSLS     R0,R5,#+25
   \   00000202   02D5               BPL.N    ??list_hw_ints_console_42
   \   00000204   ........           BL       print_b1sp
   \   00000208   01E0               B.N      ??list_hw_ints_console_43
   1770          		else print_b0sp(); 
   \                     ??list_hw_ints_console_42:
   \   0000020A   ........           BL       print_b0sp
   1771          		// pending? 
   1772          		if(k & (1<<6)) printf("1\n\r");
   \                     ??list_hw_ints_console_43:
   \   0000020E   7006               LSLS     R0,R6,#+25
   \   00000210   03D5               BPL.N    ??list_hw_ints_console_44
   \   00000212   ....               ADR.N    R0,??DataTable2  ;; "1\n\r"
   \   00000214   ........           BL       printf
   \   00000218   02E0               B.N      ??list_hw_ints_console_41
   1773          		else printf("0\n\r"); 
   \                     ??list_hw_ints_console_44:
   \   0000021A   ....               ADR.N    R0,??DataTable2_1  ;; "0\n\r"
   \   0000021C   ........           BL       printf
   1774          	}
   1775          
   1776          	printf("BC Timetag Value Match");
   \                     ??list_hw_ints_console_41:
   \   00000220   ........           LDR.W    R0,??DataTable13_28
   \   00000224   ........           BL       printf
   1777          	if(!(i & (1<<5))) {	
   \   00000228   A006               LSLS     R0,R4,#+26
   \   0000022A   02D4               BMI.N    ??list_hw_ints_console_45
   1778          		// int disabled 
   1779          		print_null();
   \   0000022C   ........           BL       print_null
   \   00000230   11E0               B.N      ??list_hw_ints_console_46
   1780          	}
   1781          	else {
   1782          		// int enabled 
   1783          		print_sp1sp();
   \                     ??list_hw_ints_console_45:
   \   00000232   ........           BL       print_sp1sp
   1784          		// pin output? 
   1785          		if(j & (1<<5)) print_b1sp();
   \   00000236   A806               LSLS     R0,R5,#+26
   \   00000238   02D5               BPL.N    ??list_hw_ints_console_47
   \   0000023A   ........           BL       print_b1sp
   \   0000023E   01E0               B.N      ??list_hw_ints_console_48
   1786          		else print_b0sp(); 
   \                     ??list_hw_ints_console_47:
   \   00000240   ........           BL       print_b0sp
   1787          		// pending? 
   1788          		if(k & (1<<5)) printf("1\n\r");
   \                     ??list_hw_ints_console_48:
   \   00000244   B006               LSLS     R0,R6,#+26
   \   00000246   03D5               BPL.N    ??list_hw_ints_console_49
   \   00000248   ....               ADR.N    R0,??DataTable2  ;; "1\n\r"
   \   0000024A   ........           BL       printf
   \   0000024E   02E0               B.N      ??list_hw_ints_console_46
   1789          		else printf("0\n\r"); 
   \                     ??list_hw_ints_console_49:
   \   00000250   ....               ADR.N    R0,??DataTable2_1  ;; "0\n\r"
   \   00000252   ........           BL       printf
   1790          	}
   1791          
   1792          	printf("  RT2 Addr Parity Fail");
   \                     ??list_hw_ints_console_46:
   \   00000256   ........           LDR.W    R0,??DataTable13_29
   \   0000025A   ........           BL       printf
   1793          	if(!(i & (1<<4))) {	
   \   0000025E   E006               LSLS     R0,R4,#+27
   \   00000260   02D4               BMI.N    ??list_hw_ints_console_50
   1794          		// int disabled 
   1795          		print_null();
   \   00000262   ........           BL       print_null
   \   00000266   11E0               B.N      ??list_hw_ints_console_51
   1796          	}
   1797          	else {
   1798          		// int enabled 
   1799          		print_sp1sp();
   \                     ??list_hw_ints_console_50:
   \   00000268   ........           BL       print_sp1sp
   1800          		// pin output? 
   1801          		if(j & (1<<4)) print_b1sp();
   \   0000026C   E806               LSLS     R0,R5,#+27
   \   0000026E   02D5               BPL.N    ??list_hw_ints_console_52
   \   00000270   ........           BL       print_b1sp
   \   00000274   01E0               B.N      ??list_hw_ints_console_53
   1802          		else print_b0sp(); 
   \                     ??list_hw_ints_console_52:
   \   00000276   ........           BL       print_b0sp
   1803          		// pending? 
   1804          		if(k & (1<<4)) printf("1\n\r");
   \                     ??list_hw_ints_console_53:
   \   0000027A   F006               LSLS     R0,R6,#+27
   \   0000027C   03D5               BPL.N    ??list_hw_ints_console_54
   \   0000027E   ....               ADR.N    R0,??DataTable2  ;; "1\n\r"
   \   00000280   ........           BL       printf
   \   00000284   02E0               B.N      ??list_hw_ints_console_51
   1805          		else printf("0\n\r"); 
   \                     ??list_hw_ints_console_54:
   \   00000286   ....               ADR.N    R0,??DataTable2_1  ;; "0\n\r"
   \   00000288   ........           BL       printf
   1806          	}
   1807          
   1808          	printf("  RT1 Addr Parity Fail");
   \                     ??list_hw_ints_console_51:
   \   0000028C   ........           LDR.W    R0,??DataTable13_30
   \   00000290   ........           BL       printf
   1809          	if(!(i & (1<<3))) {	
   \   00000294   2007               LSLS     R0,R4,#+28
   \   00000296   02D4               BMI.N    ??list_hw_ints_console_55
   1810          		// int disabled 
   1811          		print_null();
   \   00000298   ........           BL       print_null
   \   0000029C   11E0               B.N      ??list_hw_ints_console_56
   1812          	}
   1813          	else {
   1814          		// int enabled 
   1815          		print_sp1sp();
   \                     ??list_hw_ints_console_55:
   \   0000029E   ........           BL       print_sp1sp
   1816          		// pin output? 
   1817          		if(j & (1<<3)) print_b1sp();
   \   000002A2   2807               LSLS     R0,R5,#+28
   \   000002A4   02D5               BPL.N    ??list_hw_ints_console_57
   \   000002A6   ........           BL       print_b1sp
   \   000002AA   01E0               B.N      ??list_hw_ints_console_58
   1818          		else print_b0sp(); 
   \                     ??list_hw_ints_console_57:
   \   000002AC   ........           BL       print_b0sp
   1819          		// pending? 
   1820          		if(k & (1<<3)) printf("1\n\r");
   \                     ??list_hw_ints_console_58:
   \   000002B0   3007               LSLS     R0,R6,#+28
   \   000002B2   03D5               BPL.N    ??list_hw_ints_console_59
   \   000002B4   ....               ADR.N    R0,??DataTable2  ;; "1\n\r"
   \   000002B6   ........           BL       printf
   \   000002BA   02E0               B.N      ??list_hw_ints_console_56
   1821          		else printf("0\n\r"); 
   \                     ??list_hw_ints_console_59:
   \   000002BC   ....               ADR.N    R0,??DataTable2_1  ;; "0\n\r"
   \   000002BE   ........           BL       printf
   1822          	}
   1823          
   1824          	printf(" Check Pending RT Ints");
   \                     ??list_hw_ints_console_56:
   \   000002C2   ........           LDR.W    R0,??DataTable13_31
   \   000002C6   ........           BL       printf
   1825          	if(!(i & (1<<2))) print_dd0n(); // int disabled 
   \   000002CA   6007               LSLS     R0,R4,#+29
   \   000002CC   02D4               BMI.N    ??list_hw_ints_console_60
   \   000002CE   ........           BL       print_dd0n
   \   000002D2   01E0               B.N      ??list_hw_ints_console_61
   1826          	else print_dd1n();				// int enabled 
   \                     ??list_hw_ints_console_60:
   \   000002D4   ........           BL       print_dd1n
   1827          
   1828          	printf(" Check Pending MT Ints");
   \                     ??list_hw_ints_console_61:
   \   000002D8   ........           LDR.W    R0,??DataTable13_32
   \   000002DC   ........           BL       printf
   1829          	if(!(i & (1<<1))) print_dd0n(); // int disabled 
   \   000002E0   A007               LSLS     R0,R4,#+30
   \   000002E2   02D4               BMI.N    ??list_hw_ints_console_62
   \   000002E4   ........           BL       print_dd0n
   \   000002E8   01E0               B.N      ??list_hw_ints_console_63
   1830          	else print_dd1n();				// int enabled 
   \                     ??list_hw_ints_console_62:
   \   000002EA   ........           BL       print_dd1n
   1831          
   1832          	printf(" Check Pending BC Ints");
   \                     ??list_hw_ints_console_63:
   \   000002EE   ........           LDR.W    R0,??DataTable13_33
   \   000002F2   ........           BL       printf
   1833          	if(!(i & (1<<0))) print_dd0n(); // int disabled 
   \   000002F6   E007               LSLS     R0,R4,#+31
   \   000002F8   02D4               BMI.N    ??list_hw_ints_console_64
   \   000002FA   ........           BL       print_dd0n
   \   000002FE   01E0               B.N      ??list_hw_ints_console_65
   1834          	else print_dd1n();				// int enabled 
   \                     ??list_hw_ints_console_64:
   \   00000300   ........           BL       print_dd1n
   1835          
   1836          	print_line();
   \                     ??list_hw_ints_console_65:
   \   00000304   ........           BL       print_line
   1837          	printf("Note: Reading the HW Pending Interrupt Register clears it!\n\r");
   \   00000308   ........           LDR.W    R0,??DataTable13_34
   \   0000030C   ........           BL       printf
   1838          	printf("Press 'M' for menu, or press any valid menu key.   ");
   \   00000310   ........           LDR.W    R0,??DataTable13_35
   \   00000314   ........           BL       printf
   1839          
   1840          	// return value read from the HW Pending Interrupt Register, now cleared 
   1841          	return k;
   \   00000318   3000               MOVS     R0,R6
   \   0000031A   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000031C   70BD               POP      {R4-R6,PC}       ;; return
   1842          
   1843          }	// end list_hw_ints_console()
   1844          
   1845          
   1846          //---------------------------------------------------------------
   1847          //  this function lists remote terminal interrupt 
   1848          //	configuration to the console via UART. if there
   1849          //	are pending RT interrupts, these too are displayed.
   1850          //	Function returns the value read from the RT pending
   1851          //	interrupt register, since reading the reg clears it.
   1852          //---------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
   1853          unsigned short int list_rt_ints_console (void) {
   \                     list_rt_ints_console:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   1854            
   1855                  unsigned short k=0;
   \   00000002   0024               MOVS     R4,#+0
   1856          
   1857          	#if(!(RT1_ena||RT2_ena)) 
   1858          	printf("\n\rNeither Remote Terminal Is Enabled!\n\n\r"); 
   1859          	#else // (RT1_ena||RT2_ena)
   1860                  
   1861                      unsigned short i,j;
   1862              
   1863          
   1864                      extern const H6130 pH6130; // HI-6130 register struct base address  
   1865          
   1866                      
   1867                      // formfeed 
   1868                      putchar(12); 	
   \   00000004   0C20               MOVS     R0,#+12
   \   00000006   ........           BL       putchar
   1869              
   1870          
   1871                              i = pH6130->RT_INT_ENABLE_REG;
   \   0000000A   ........           LDR.W    R0,??DataTable13_17
   \   0000000E   0068               LDR      R0,[R0, #+0]
   \   00000010   808C               LDRH     R0,[R0, #+36]
   \   00000012   0500               MOVS     R5,R0
   1872                              j = pH6130->RT_INT_OUTPUT_ENABLE_REG;
   \   00000014   ........           LDR.W    R0,??DataTable13_17
   \   00000018   0068               LDR      R0,[R0, #+0]
   \   0000001A   808D               LDRH     R0,[R0, #+44]
   \   0000001C   0600               MOVS     R6,R0
   1873                              k = pH6130->RT_PENDING_INT_REG;
   \   0000001E   ........           LDR.W    R0,??DataTable13_17
   \   00000022   0068               LDR      R0,[R0, #+0]
   \   00000024   408A               LDRH     R0,[R0, #+18]
   \   00000026   0400               MOVS     R4,R0
   1874          
   1875                              
   1876                      printf("\n\r Remote Terminal Ints  Enabled?   Pin Output?   Pending?\n\r");
   \   00000028   ........           LDR.W    R0,??DataTable13_36
   \   0000002C   ........           BL       printf
   1877                      print_line();
   \   00000030   ........           BL       print_line
   1878              
   1879                      printf("RT2  Reset RT mode cmd");
   \   00000034   ........           LDR.W    R0,??DataTable13_37
   \   00000038   ........           BL       printf
   1880                      if(!(i & (1<<15))) {	
   \   0000003C   2804               LSLS     R0,R5,#+16
   \   0000003E   02D4               BMI.N    ??list_rt_ints_console_0
   1881                              // int disabled 
   1882                              print_null();
   \   00000040   ........           BL       print_null
   \   00000044   11E0               B.N      ??list_rt_ints_console_1
   1883                      }
   1884                      else {
   1885                              // int enabled 
   1886                              print_sp1sp();
   \                     ??list_rt_ints_console_0:
   \   00000046   ........           BL       print_sp1sp
   1887                              // pin output? 
   1888                              if(j & (1<<15)) print_b1sp();
   \   0000004A   3004               LSLS     R0,R6,#+16
   \   0000004C   02D5               BPL.N    ??list_rt_ints_console_2
   \   0000004E   ........           BL       print_b1sp
   \   00000052   01E0               B.N      ??list_rt_ints_console_3
   1889                              else print_b0sp(); 
   \                     ??list_rt_ints_console_2:
   \   00000054   ........           BL       print_b0sp
   1890                              // pending? 
   1891                              if(k & (1<<15)) printf("1\n\r");
   \                     ??list_rt_ints_console_3:
   \   00000058   2004               LSLS     R0,R4,#+16
   \   0000005A   03D5               BPL.N    ??list_rt_ints_console_4
   \   0000005C   ....               ADR.N    R0,??DataTable3  ;; "1\n\r"
   \   0000005E   ........           BL       printf
   \   00000062   02E0               B.N      ??list_rt_ints_console_1
   1892                              else printf("0\n\r"); 
   \                     ??list_rt_ints_console_4:
   \   00000064   ....               ADR.N    R0,??DataTable3_1  ;; "0\n\r"
   \   00000066   ........           BL       printf
   1893                      }
   1894              
   1895                      printf("RT2  Index Equals Zero");
   \                     ??list_rt_ints_console_1:
   \   0000006A   ........           LDR.W    R0,??DataTable13_38
   \   0000006E   ........           BL       printf
   1896                      if(!(i & (1<<14))) {	
   \   00000072   6804               LSLS     R0,R5,#+17
   \   00000074   02D4               BMI.N    ??list_rt_ints_console_5
   1897                              // int disabled 
   1898                              print_null();
   \   00000076   ........           BL       print_null
   \   0000007A   11E0               B.N      ??list_rt_ints_console_6
   1899                      }
   1900                      else {
   1901                              // int enabled 
   1902                              print_sp1sp();
   \                     ??list_rt_ints_console_5:
   \   0000007C   ........           BL       print_sp1sp
   1903                              // pin output? 
   1904                              if(j & (1<<14)) print_b1sp();
   \   00000080   7004               LSLS     R0,R6,#+17
   \   00000082   02D5               BPL.N    ??list_rt_ints_console_7
   \   00000084   ........           BL       print_b1sp
   \   00000088   01E0               B.N      ??list_rt_ints_console_8
   1905                              else print_b0sp(); 
   \                     ??list_rt_ints_console_7:
   \   0000008A   ........           BL       print_b0sp
   1906                              // pending? 
   1907                              if(k & (1<<14)) printf("1\n\r");
   \                     ??list_rt_ints_console_8:
   \   0000008E   6004               LSLS     R0,R4,#+17
   \   00000090   03D5               BPL.N    ??list_rt_ints_console_9
   \   00000092   ....               ADR.N    R0,??DataTable3  ;; "1\n\r"
   \   00000094   ........           BL       printf
   \   00000098   02E0               B.N      ??list_rt_ints_console_6
   1908                              else printf("0\n\r"); 
   \                     ??list_rt_ints_console_9:
   \   0000009A   ....               ADR.N    R0,??DataTable3_1  ;; "0\n\r"
   \   0000009C   ........           BL       printf
   1909                      }
   1910              
   1911                      printf("RT2    Illegal Command");
   \                     ??list_rt_ints_console_6:
   \   000000A0   ........           LDR.W    R0,??DataTable13_39
   \   000000A4   ........           BL       printf
   1912                      if(!(i & (1<<13))) {	
   \   000000A8   A804               LSLS     R0,R5,#+18
   \   000000AA   02D4               BMI.N    ??list_rt_ints_console_10
   1913                              // int disabled 
   1914                              print_null();
   \   000000AC   ........           BL       print_null
   \   000000B0   11E0               B.N      ??list_rt_ints_console_11
   1915                      }
   1916                      else {
   1917                              // int enabled 
   1918                              print_sp1sp();
   \                     ??list_rt_ints_console_10:
   \   000000B2   ........           BL       print_sp1sp
   1919                              // pin output? 
   1920                              if(j & (1<<13)) print_b1sp();
   \   000000B6   B004               LSLS     R0,R6,#+18
   \   000000B8   02D5               BPL.N    ??list_rt_ints_console_12
   \   000000BA   ........           BL       print_b1sp
   \   000000BE   01E0               B.N      ??list_rt_ints_console_13
   1921                              else print_b0sp(); 
   \                     ??list_rt_ints_console_12:
   \   000000C0   ........           BL       print_b0sp
   1922                              // pending? 
   1923                              if(k & (1<<13)) printf("1\n\r");
   \                     ??list_rt_ints_console_13:
   \   000000C4   A004               LSLS     R0,R4,#+18
   \   000000C6   03D5               BPL.N    ??list_rt_ints_console_14
   \   000000C8   ....               ADR.N    R0,??DataTable3  ;; "1\n\r"
   \   000000CA   ........           BL       printf
   \   000000CE   02E0               B.N      ??list_rt_ints_console_11
   1924                              else printf("0\n\r"); 
   \                     ??list_rt_ints_console_14:
   \   000000D0   ....               ADR.N    R0,??DataTable3_1  ;; "0\n\r"
   \   000000D2   ........           BL       printf
   1925                      }
   1926              
   1927                      printf("RT2 Broadcast Msg Rcvd");
   \                     ??list_rt_ints_console_11:
   \   000000D6   ........           LDR.W    R0,??DataTable13_40
   \   000000DA   ........           BL       printf
   1928                      if(!(i & (1<<12))) {	
   \   000000DE   E804               LSLS     R0,R5,#+19
   \   000000E0   02D4               BMI.N    ??list_rt_ints_console_15
   1929                              // int disabled 
   1930                              print_null();
   \   000000E2   ........           BL       print_null
   \   000000E6   11E0               B.N      ??list_rt_ints_console_16
   1931                      }
   1932                      else {
   1933                              // int enabled 
   1934                              print_sp1sp();
   \                     ??list_rt_ints_console_15:
   \   000000E8   ........           BL       print_sp1sp
   1935                              // pin output? 
   1936                              if(j & (1<<12)) print_b1sp();
   \   000000EC   F004               LSLS     R0,R6,#+19
   \   000000EE   02D5               BPL.N    ??list_rt_ints_console_17
   \   000000F0   ........           BL       print_b1sp
   \   000000F4   01E0               B.N      ??list_rt_ints_console_18
   1937                              else print_b0sp(); 
   \                     ??list_rt_ints_console_17:
   \   000000F6   ........           BL       print_b0sp
   1938                              // pending? 
   1939                              if(k & (1<<12)) printf("1\n\r");
   \                     ??list_rt_ints_console_18:
   \   000000FA   E004               LSLS     R0,R4,#+19
   \   000000FC   03D5               BPL.N    ??list_rt_ints_console_19
   \   000000FE   ....               ADR.N    R0,??DataTable3  ;; "1\n\r"
   \   00000100   ........           BL       printf
   \   00000104   02E0               B.N      ??list_rt_ints_console_16
   1940                              else printf("0\n\r"); 
   \                     ??list_rt_ints_console_19:
   \   00000106   ....               ADR.N    R0,??DataTable3_1  ;; "0\n\r"
   \   00000108   ........           BL       printf
   1941                      }
   1942              
   1943                      printf("RT2 MessageErrorStatus");
   \                     ??list_rt_ints_console_16:
   \   0000010C   ........           LDR.W    R0,??DataTable13_41
   \   00000110   ........           BL       printf
   1944                      if(!(i & (1<<11))) {	
   \   00000114   2805               LSLS     R0,R5,#+20
   \   00000116   02D4               BMI.N    ??list_rt_ints_console_20
   1945                              // int disabled 
   1946                              print_null();
   \   00000118   ........           BL       print_null
   \   0000011C   11E0               B.N      ??list_rt_ints_console_21
   1947                      }
   1948                      else {
   1949                              // int enabled 
   1950                              print_sp1sp();
   \                     ??list_rt_ints_console_20:
   \   0000011E   ........           BL       print_sp1sp
   1951                              // pin output? 
   1952                              if(j & (1<<11)) print_b1sp();
   \   00000122   3005               LSLS     R0,R6,#+20
   \   00000124   02D5               BPL.N    ??list_rt_ints_console_22
   \   00000126   ........           BL       print_b1sp
   \   0000012A   01E0               B.N      ??list_rt_ints_console_23
   1953                              else print_b0sp(); 
   \                     ??list_rt_ints_console_22:
   \   0000012C   ........           BL       print_b0sp
   1954                              // pending? 
   1955                              if(k & (1<<11)) printf("1\n\r");
   \                     ??list_rt_ints_console_23:
   \   00000130   2005               LSLS     R0,R4,#+20
   \   00000132   03D5               BPL.N    ??list_rt_ints_console_24
   \   00000134   ....               ADR.N    R0,??DataTable3  ;; "1\n\r"
   \   00000136   ........           BL       printf
   \   0000013A   02E0               B.N      ??list_rt_ints_console_21
   1956                              else printf("0\n\r"); 
   \                     ??list_rt_ints_console_24:
   \   0000013C   ....               ADR.N    R0,??DataTable3_1  ;; "0\n\r"
   \   0000013E   ........           BL       printf
   1957                      }
   1958              
   1959                      printf("RT2  Int When Accessed");
   \                     ??list_rt_ints_console_21:
   \   00000142   ........           LDR.W    R0,??DataTable13_42
   \   00000146   ........           BL       printf
   1960                      if(!(i & (1<<10))) {	
   \   0000014A   6805               LSLS     R0,R5,#+21
   \   0000014C   02D4               BMI.N    ??list_rt_ints_console_25
   1961                              // int disabled 
   1962                              print_null();
   \   0000014E   ........           BL       print_null
   \   00000152   11E0               B.N      ??list_rt_ints_console_26
   1963                      }
   1964                      else {
   1965                              // int enabled 
   1966                              print_sp1sp();
   \                     ??list_rt_ints_console_25:
   \   00000154   ........           BL       print_sp1sp
   1967                              // pin output? 
   1968                              if(j & (1<<10)) print_b1sp();
   \   00000158   7005               LSLS     R0,R6,#+21
   \   0000015A   02D5               BPL.N    ??list_rt_ints_console_27
   \   0000015C   ........           BL       print_b1sp
   \   00000160   01E0               B.N      ??list_rt_ints_console_28
   1969                              else print_b0sp(); 
   \                     ??list_rt_ints_console_27:
   \   00000162   ........           BL       print_b0sp
   1970                              // pending? 
   1971                              if(k & (1<<10)) printf("1\n\r");
   \                     ??list_rt_ints_console_28:
   \   00000166   6005               LSLS     R0,R4,#+21
   \   00000168   03D5               BPL.N    ??list_rt_ints_console_29
   \   0000016A   ....               ADR.N    R0,??DataTable3  ;; "1\n\r"
   \   0000016C   ........           BL       printf
   \   00000170   02E0               B.N      ??list_rt_ints_console_26
   1972                              else printf("0\n\r"); 
   \                     ??list_rt_ints_console_29:
   \   00000172   ....               ADR.N    R0,??DataTable3_1  ;; "0\n\r"
   \   00000174   ........           BL       printf
   1973                      }
   1974              
   1975                      printf("        Reserved Bit 9");
   \                     ??list_rt_ints_console_26:
   \   00000178   ........           LDR.W    R0,??DataTable13_43
   \   0000017C   ........           BL       printf
   1976                      print_dddn();
   \   00000180   ........           BL       print_dddn
   1977              
   1978                      printf("RT1  Reset RT mode cmd");
   \   00000184   ........           LDR.W    R0,??DataTable13_44
   \   00000188   ........           BL       printf
   1979                      if(!(i & (1<<8))) {	
   \   0000018C   E805               LSLS     R0,R5,#+23
   \   0000018E   02D4               BMI.N    ??list_rt_ints_console_30
   1980                              // int disabled 
   1981                              print_null();
   \   00000190   ........           BL       print_null
   \   00000194   11E0               B.N      ??list_rt_ints_console_31
   1982                      }
   1983                      else {
   1984                              // int enabled 
   1985                              print_sp1sp();
   \                     ??list_rt_ints_console_30:
   \   00000196   ........           BL       print_sp1sp
   1986                              // pin output? 
   1987                              if(j & (1<<8)) print_b1sp();
   \   0000019A   F005               LSLS     R0,R6,#+23
   \   0000019C   02D5               BPL.N    ??list_rt_ints_console_32
   \   0000019E   ........           BL       print_b1sp
   \   000001A2   01E0               B.N      ??list_rt_ints_console_33
   1988                              else print_b0sp(); 
   \                     ??list_rt_ints_console_32:
   \   000001A4   ........           BL       print_b0sp
   1989                              // pending? 
   1990                              if(k & (1<<8)) printf("1\n\r");
   \                     ??list_rt_ints_console_33:
   \   000001A8   E005               LSLS     R0,R4,#+23
   \   000001AA   03D5               BPL.N    ??list_rt_ints_console_34
   \   000001AC   ....               ADR.N    R0,??DataTable3  ;; "1\n\r"
   \   000001AE   ........           BL       printf
   \   000001B2   02E0               B.N      ??list_rt_ints_console_31
   1991                              else printf("0\n\r"); 
   \                     ??list_rt_ints_console_34:
   \   000001B4   ....               ADR.N    R0,??DataTable3_1  ;; "0\n\r"
   \   000001B6   ........           BL       printf
   1992                      }
   1993              
   1994                      printf("RT1  Index Equals Zero");
   \                     ??list_rt_ints_console_31:
   \   000001BA   ....               LDR.N    R0,??DataTable13_45
   \   000001BC   ........           BL       printf
   1995                      if(!(i & (1<<7))) {	
   \   000001C0   2806               LSLS     R0,R5,#+24
   \   000001C2   02D4               BMI.N    ??list_rt_ints_console_35
   1996                              // int disabled 
   1997                              print_null();
   \   000001C4   ........           BL       print_null
   \   000001C8   11E0               B.N      ??list_rt_ints_console_36
   1998                      }
   1999                      else {
   2000                              // int enabled 
   2001                              print_sp1sp();
   \                     ??list_rt_ints_console_35:
   \   000001CA   ........           BL       print_sp1sp
   2002                              // pin output? 
   2003                              if(j & (1<<7)) print_b1sp();
   \   000001CE   3006               LSLS     R0,R6,#+24
   \   000001D0   02D5               BPL.N    ??list_rt_ints_console_37
   \   000001D2   ........           BL       print_b1sp
   \   000001D6   01E0               B.N      ??list_rt_ints_console_38
   2004                              else print_b0sp(); 
   \                     ??list_rt_ints_console_37:
   \   000001D8   ........           BL       print_b0sp
   2005                              // pending? 
   2006                              if(k & (1<<7)) printf("1\n\r");
   \                     ??list_rt_ints_console_38:
   \   000001DC   2006               LSLS     R0,R4,#+24
   \   000001DE   03D5               BPL.N    ??list_rt_ints_console_39
   \   000001E0   ....               ADR.N    R0,??DataTable3  ;; "1\n\r"
   \   000001E2   ........           BL       printf
   \   000001E6   02E0               B.N      ??list_rt_ints_console_36
   2007                              else printf("0\n\r"); 
   \                     ??list_rt_ints_console_39:
   \   000001E8   ....               ADR.N    R0,??DataTable3_1  ;; "0\n\r"
   \   000001EA   ........           BL       printf
   2008                      }
   2009              
   2010                      printf("RT1    Illegal Command");
   \                     ??list_rt_ints_console_36:
   \   000001EE   ....               LDR.N    R0,??DataTable13_46
   \   000001F0   ........           BL       printf
   2011                      if(!(i & (1<<6))) {	
   \   000001F4   6806               LSLS     R0,R5,#+25
   \   000001F6   02D4               BMI.N    ??list_rt_ints_console_40
   2012                              // int disabled 
   2013                              print_null();
   \   000001F8   ........           BL       print_null
   \   000001FC   11E0               B.N      ??list_rt_ints_console_41
   2014                      }
   2015                      else {
   2016                              // int enabled 
   2017                              print_sp1sp();
   \                     ??list_rt_ints_console_40:
   \   000001FE   ........           BL       print_sp1sp
   2018                              // pin output? 
   2019                              if(j & (1<<6)) print_b1sp();
   \   00000202   7006               LSLS     R0,R6,#+25
   \   00000204   02D5               BPL.N    ??list_rt_ints_console_42
   \   00000206   ........           BL       print_b1sp
   \   0000020A   01E0               B.N      ??list_rt_ints_console_43
   2020                              else print_b0sp(); 
   \                     ??list_rt_ints_console_42:
   \   0000020C   ........           BL       print_b0sp
   2021                              // pending? 
   2022                              if(k & (1<<6)) printf("1\n\r");
   \                     ??list_rt_ints_console_43:
   \   00000210   6006               LSLS     R0,R4,#+25
   \   00000212   03D5               BPL.N    ??list_rt_ints_console_44
   \   00000214   ....               ADR.N    R0,??DataTable3  ;; "1\n\r"
   \   00000216   ........           BL       printf
   \   0000021A   02E0               B.N      ??list_rt_ints_console_41
   2023                              else printf("0\n\r"); 
   \                     ??list_rt_ints_console_44:
   \   0000021C   ....               ADR.N    R0,??DataTable3_1  ;; "0\n\r"
   \   0000021E   ........           BL       printf
   2024                      }
   2025              
   2026                      printf("RT1 Broadcast Msg Rcvd");
   \                     ??list_rt_ints_console_41:
   \   00000222   ....               LDR.N    R0,??DataTable13_47
   \   00000224   ........           BL       printf
   2027                      if(!(i & (1<<5))) {	
   \   00000228   A806               LSLS     R0,R5,#+26
   \   0000022A   02D4               BMI.N    ??list_rt_ints_console_45
   2028                              // int disabled 
   2029                              print_null();
   \   0000022C   ........           BL       print_null
   \   00000230   11E0               B.N      ??list_rt_ints_console_46
   2030                      }
   2031                      else {
   2032                              // int enabled 
   2033                              print_sp1sp();
   \                     ??list_rt_ints_console_45:
   \   00000232   ........           BL       print_sp1sp
   2034                              // pin output? 
   2035                              if(j & (1<<5)) print_b1sp();
   \   00000236   B006               LSLS     R0,R6,#+26
   \   00000238   02D5               BPL.N    ??list_rt_ints_console_47
   \   0000023A   ........           BL       print_b1sp
   \   0000023E   01E0               B.N      ??list_rt_ints_console_48
   2036                              else print_b0sp(); 
   \                     ??list_rt_ints_console_47:
   \   00000240   ........           BL       print_b0sp
   2037                              // pending? 
   2038                              if(k & (1<<5)) printf("1\n\r");
   \                     ??list_rt_ints_console_48:
   \   00000244   A006               LSLS     R0,R4,#+26
   \   00000246   03D5               BPL.N    ??list_rt_ints_console_49
   \   00000248   ....               ADR.N    R0,??DataTable3  ;; "1\n\r"
   \   0000024A   ........           BL       printf
   \   0000024E   02E0               B.N      ??list_rt_ints_console_46
   2039                              else printf("0\n\r"); 
   \                     ??list_rt_ints_console_49:
   \   00000250   ....               ADR.N    R0,??DataTable3_1  ;; "0\n\r"
   \   00000252   ........           BL       printf
   2040                      }
   2041              
   2042                      printf("RT1 MessageErrorStatus");
   \                     ??list_rt_ints_console_46:
   \   00000256   ....               LDR.N    R0,??DataTable13_48
   \   00000258   ........           BL       printf
   2043                      if(!(i & (1<<4))) {	
   \   0000025C   E806               LSLS     R0,R5,#+27
   \   0000025E   02D4               BMI.N    ??list_rt_ints_console_50
   2044                              // int disabled 
   2045                              print_null();
   \   00000260   ........           BL       print_null
   \   00000264   11E0               B.N      ??list_rt_ints_console_51
   2046                      }
   2047                      else {
   2048                              // int enabled 
   2049                              print_sp1sp();
   \                     ??list_rt_ints_console_50:
   \   00000266   ........           BL       print_sp1sp
   2050                              // pin output? 
   2051                              if(j & (1<<4)) print_b1sp();
   \   0000026A   F006               LSLS     R0,R6,#+27
   \   0000026C   02D5               BPL.N    ??list_rt_ints_console_52
   \   0000026E   ........           BL       print_b1sp
   \   00000272   01E0               B.N      ??list_rt_ints_console_53
   2052                              else print_b0sp(); 
   \                     ??list_rt_ints_console_52:
   \   00000274   ........           BL       print_b0sp
   2053                              // pending? 
   2054                              if(k & (1<<4)) printf("1\n\r");
   \                     ??list_rt_ints_console_53:
   \   00000278   E006               LSLS     R0,R4,#+27
   \   0000027A   03D5               BPL.N    ??list_rt_ints_console_54
   \   0000027C   ....               ADR.N    R0,??DataTable3  ;; "1\n\r"
   \   0000027E   ........           BL       printf
   \   00000282   02E0               B.N      ??list_rt_ints_console_51
   2055                              else printf("0\n\r"); 
   \                     ??list_rt_ints_console_54:
   \   00000284   ....               ADR.N    R0,??DataTable3_1  ;; "0\n\r"
   \   00000286   ........           BL       printf
   2056                      }
   2057              
   2058                      printf("RT1  Int When Accessed");
   \                     ??list_rt_ints_console_51:
   \   0000028A   ....               LDR.N    R0,??DataTable13_49
   \   0000028C   ........           BL       printf
   2059                      if(!(i & (1<<3))) {	
   \   00000290   2807               LSLS     R0,R5,#+28
   \   00000292   02D4               BMI.N    ??list_rt_ints_console_55
   2060                              // int disabled 
   2061                              print_null();
   \   00000294   ........           BL       print_null
   \   00000298   11E0               B.N      ??list_rt_ints_console_56
   2062                      }
   2063                      else {
   2064                              // int enabled 
   2065                              print_sp1sp();
   \                     ??list_rt_ints_console_55:
   \   0000029A   ........           BL       print_sp1sp
   2066                              // pin output? 
   2067                              if(j & (1<<3)) print_b1sp();
   \   0000029E   3007               LSLS     R0,R6,#+28
   \   000002A0   02D5               BPL.N    ??list_rt_ints_console_57
   \   000002A2   ........           BL       print_b1sp
   \   000002A6   01E0               B.N      ??list_rt_ints_console_58
   2068                              else print_b0sp(); 
   \                     ??list_rt_ints_console_57:
   \   000002A8   ........           BL       print_b0sp
   2069                              // pending? 
   2070                              if(k & (1<<3)) printf("1\n\r");
   \                     ??list_rt_ints_console_58:
   \   000002AC   2007               LSLS     R0,R4,#+28
   \   000002AE   03D5               BPL.N    ??list_rt_ints_console_59
   \   000002B0   ....               ADR.N    R0,??DataTable3  ;; "1\n\r"
   \   000002B2   ........           BL       printf
   \   000002B6   02E0               B.N      ??list_rt_ints_console_56
   2071                              else printf("0\n\r"); 
   \                     ??list_rt_ints_console_59:
   \   000002B8   ....               ADR.N    R0,??DataTable3_1  ;; "0\n\r"
   \   000002BA   ........           BL       printf
   2072                      }
   2073              
   2074                      printf("     Reserved Bits 2-0");
   \                     ??list_rt_ints_console_56:
   \   000002BE   ....               LDR.N    R0,??DataTable13_50
   \   000002C0   ........           BL       printf
   2075                      print_dddn();
   \   000002C4   ........           BL       print_dddn
   2076                      print_line();
   \   000002C8   ........           BL       print_line
   2077                      printf("Note: Reading the RT Pending Interrupt Register clears it!\n\r");
   \   000002CC   ....               LDR.N    R0,??DataTable13_51
   \   000002CE   ........           BL       printf
   2078                      
   2079          	#endif // (RT1_ena||RT2_ena)
   2080          	print_menuprompt();
   \   000002D2   ........           BL       print_menuprompt
   2081          
   2082          	// return value read from the RT Pending Interrupt Register, now cleared 
   2083          	return k;
   \   000002D6   2000               MOVS     R0,R4
   \   000002D8   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000002DA   70BD               POP      {R4-R6,PC}       ;; return
   2084          
   2085          }	// end list_rt_ints_console()
   2086          
   2087          
   2088          
   2089          
   2090          //---------------------------------------------------------------------------
   2091          //   brief	this function checks for keyboard input and
   2092          //		decodes it, acts on it, when it occurs
   2093          //---------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
   2094          void chk_key_input(void) {
   \                     chk_key_input:
   \   00000000   10B5               PUSH     {R4,LR}
   2095          
   2096              char key;
   2097          
   2098              
   2099              // poll USART Channel Status Reg for Rx Ready 
   2100              if(USART_IsRxReady(BOARD_USART_BASE)) {
   \   00000002   ....               LDR.N    R0,??DataTable13_2  ;; 0x40094000
   \   00000004   ........           BL       USART_IsRxReady
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   43D0               BEQ.N    ??chk_key_input_0
   2101                  // got key press at computer keyboard,
   2102                  // read USART Receive Holding register
   2103                  key = USART_GetChar(BOARD_USART_BASE);
   \   0000000C   ....               LDR.N    R0,??DataTable13_2  ;; 0x40094000
   \   0000000E   ........           BL       USART_GetChar
   \   00000012   0400               MOVS     R4,R0
   2104                
   2105                  //-----------------------------------
   2106                  
   2107                  if (watch) {
   \   00000014   ....               LDR.N    R0,??DataTable13_52
   \   00000016   0078               LDRB     R0,[R0, #+0]
   \   00000018   0028               CMP      R0,#+0
   \   0000001A   3BD1               BNE.N    ??chk_key_input_0
   2108                      // Memory Watch mode enabled
   2109          
   2110                    
   2111                  } // end if(watch)
   2112                  
   2113                  else { // Memory Watch mode disabled, normal menu mode...
   2114                    
   2115                      switch(key) {
   \   0000001C   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   2000               MOVS     R0,R4
   \   00000020   3628               CMP      R0,#+54
   \   00000022   27D0               BEQ.N    ??chk_key_input_1
   \   00000024   3828               CMP      R0,#+56
   \   00000026   28D0               BEQ.N    ??chk_key_input_2
   \   00000028   4128               CMP      R0,#+65
   \   0000002A   1CD0               BEQ.N    ??chk_key_input_3
   \   0000002C   4428               CMP      R0,#+68
   \   0000002E   1AD0               BEQ.N    ??chk_key_input_3
   \   00000030   4D28               CMP      R0,#+77
   \   00000032   12D0               BEQ.N    ??chk_key_input_4
   \   00000034   5228               CMP      R0,#+82
   \   00000036   16D0               BEQ.N    ??chk_key_input_3
   \   00000038   5528               CMP      R0,#+85
   \   0000003A   14D0               BEQ.N    ??chk_key_input_3
   \   0000003C   5728               CMP      R0,#+87
   \   0000003E   12D0               BEQ.N    ??chk_key_input_3
   \   00000040   6128               CMP      R0,#+97
   \   00000042   10D0               BEQ.N    ??chk_key_input_3
   \   00000044   6428               CMP      R0,#+100
   \   00000046   0ED0               BEQ.N    ??chk_key_input_3
   \   00000048   6D28               CMP      R0,#+109
   \   0000004A   06D0               BEQ.N    ??chk_key_input_4
   \   0000004C   7228               CMP      R0,#+114
   \   0000004E   0AD0               BEQ.N    ??chk_key_input_3
   \   00000050   7528               CMP      R0,#+117
   \   00000052   08D0               BEQ.N    ??chk_key_input_3
   \   00000054   7728               CMP      R0,#+119
   \   00000056   06D0               BEQ.N    ??chk_key_input_3
   \   00000058   12E0               B.N      ??chk_key_input_5
   2116                          
   2117                          case 'm':
   2118                          case 'M':
   2119                              watch = 0;
   \                     ??chk_key_input_4:
   \   0000005A   ....               LDR.N    R0,??DataTable13_52
   \   0000005C   0021               MOVS     R1,#+0
   \   0000005E   0170               STRB     R1,[R0, #+0]
   2120                              show_menu();
   \   00000060   ........           BL       show_menu
   2121                          break;
   \   00000064   12E0               B.N      ??chk_key_input_6
   2122                          
   2123                          // the W keys are only recognized if HI-6131
   2124          
   2125                          case 'w':
   2126                          case 'W':
   2127                              
   2128                          // these keys are only recognized in Memory Watch mode
   2129                          case 'r':
   2130                          case 'R':
   2131                          case 'u':
   2132                          case 'U':
   2133                          case 'd':
   2134                          case 'D':
   2135                          case 'a':
   2136                          case 'A':
   2137                              // formfeed
   2138                              putchar(12); 	
   \                     ??chk_key_input_3:
   \   00000066   0C20               MOVS     R0,#+12
   \   00000068   ........           BL       putchar
   2139                              printf("\n\r Invalid Choice. Press 'M' for menu, or press any valid menu key. >> ");
   \   0000006C   ....               LDR.N    R0,??DataTable13_53
   \   0000006E   ........           BL       printf
   2140                          break;
   \   00000072   0BE0               B.N      ??chk_key_input_6
   2141                                
   2142                           #if(BC_ena) 
   2143                                case '1':	
   2144                                    // Generate a BC external trigger pulse for the HI-613x
   2145                                    bc_trigger();
   2146                                    // message completion delay, 1.5ms
   2147                                    Delay_us(1500);
   2148                                    // console output reg and RAM info for last completed msg
   2149                                    bc_last_msg_console();
   2150                                break;
   2151                        
   2152                                case '2': 		
   2153                                    list_bc_config();
   2154                                break;
   2155                            
   2156                                case '3': 
   2157                                    // output Cond Code / GP Flag reg to console via UART
   2158                                    list_bc_ccgpf_reg();
   2159                                break;
   2160                                
   2161                                case '7':
   2162                                    // display bc interrupt status
   2163                                    list_bc_ints_console();
   2164                                break;
   2165                                
   2166                            #endif // (BC_ena) 
   2167                            
   2168                            #if(SMT_ena || IMT_ena)
   2169                                case '4': 		
   2170                                    list_mt_config();
   2171                                break;
   2172                
   2173                                case '5': 		
   2174                                    mt_last_msg_console();
   2175                                break;
   2176                            #endif // (SMT_ena || IMT_ena)
   2177                            
   2178                            case '6':
   2179                                // display hw interrupt status
   2180                                list_hw_ints_console();
   \                     ??chk_key_input_1:
   \   00000074   ........           BL       list_hw_ints_console
   2181                            break;
   \   00000078   08E0               B.N      ??chk_key_input_6
   2182                            
   2183                            #if(RT1_ena || RT2_ena)
   2184                                case '8':
   2185                                    // display rt interrupt status
   2186                                    list_rt_ints_console();
   \                     ??chk_key_input_2:
   \   0000007A   ........           BL       list_rt_ints_console
   2187                                break;
   \   0000007E   05E0               B.N      ??chk_key_input_6
   2188                            #endif // (RT1_ena || RT2_ena)
   2189                            
   2190                            #if(SMT_ena || IMT_ena)
   2191                                case '9':
   2192                                    // display mt interrupt status
   2193                                    list_mt_ints_console();
   2194                                break;
   2195                            #endif // (SMT_ena || IMT_ena)
   2196                            
   2197                            
   2198                            default:
   2199                                // ignore unrecognized keys
   2200                                // formfeed
   2201                                putchar(12); 	
   \                     ??chk_key_input_5:
   \   00000080   0C20               MOVS     R0,#+12
   \   00000082   ........           BL       putchar
   2202                                printf("\n\r Invalid Choice. Press 'M' for menu, or press any valid menu key. >> ");
   \   00000086   ....               LDR.N    R0,??DataTable13_53
   \   00000088   ........           BL       printf
   2203                            break;
   2204                            
   2205                      } // end switch(key)
   2206                      
   2207                      // prevent warning: waddr as declared but never referenced
   2208                      waddr = waddr;
   \                     ??chk_key_input_6:
   \   0000008C   ....               LDR.N    R0,??DataTable13_54
   \   0000008E   ....               LDR.N    R1,??DataTable13_54
   \   00000090   0988               LDRH     R1,[R1, #+0]
   \   00000092   0180               STRH     R1,[R0, #+0]
   2209                                                    
   2210                  }  // end else !watch
   2211                  
   2212              }  // end if(USART_IsRxReady(BOARD_USART_BASE))
   2213                              
   2214          } // end chk_key_input()
   \                     ??chk_key_input_0:
   \   00000094   10BD               POP      {R4,PC}          ;; return
   2215                              
   2216                                                                                                           
   2217                                                 
   2218          //----------------------------------------------------------------------------
   2219          //    used by above function, this function converts a char 0-15 into 0x0-0xF
   2220          //----------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
   2221          unsigned char ascii2int(char ch) {
   \                     ascii2int:
   \   00000000   0100               MOVS     R1,R0
   2222              unsigned char hex;
   2223              if((ch >='0') && (ch<='9')) hex = ch - '0';
   \   00000002   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   3029               CMP      R1,#+48
   \   00000006   06D3               BCC.N    ??ascii2int_0
   \   00000008   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   3A29               CMP      R1,#+58
   \   0000000C   03D2               BCS.N    ??ascii2int_0
   \   0000000E   B1F13002           SUBS     R2,R1,#+48
   \   00000012   1000               MOVS     R0,R2
   \   00000014   15E0               B.N      ??ascii2int_1
   2224              else if ((ch >='A') && (ch<='F')) hex = ch - 'A' + 10;
   \                     ??ascii2int_0:
   \   00000016   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000018   4129               CMP      R1,#+65
   \   0000001A   06D3               BCC.N    ??ascii2int_2
   \   0000001C   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001E   4729               CMP      R1,#+71
   \   00000020   03D2               BCS.N    ??ascii2int_2
   \   00000022   B1F13702           SUBS     R2,R1,#+55
   \   00000026   1000               MOVS     R0,R2
   \   00000028   0BE0               B.N      ??ascii2int_1
   2225              else if ((ch >='a') && (ch<='f')) hex = ch - 'a' + 10;
   \                     ??ascii2int_2:
   \   0000002A   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002C   6129               CMP      R1,#+97
   \   0000002E   06D3               BCC.N    ??ascii2int_3
   \   00000030   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000032   6729               CMP      R1,#+103
   \   00000034   03D2               BCS.N    ??ascii2int_3
   \   00000036   B1F15702           SUBS     R2,R1,#+87
   \   0000003A   1000               MOVS     R0,R2
   \   0000003C   01E0               B.N      ??ascii2int_1
   2226              else hex = 0;
   \                     ??ascii2int_3:
   \   0000003E   0022               MOVS     R2,#+0
   \   00000040   1000               MOVS     R0,R2
   2227              return hex;
   \                     ??ascii2int_1:
   \   00000042   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   7047               BX       LR               ;; return
   2228          }
   2229                                                 
   2230                                                 
   2231                                                 
   2232                                                 
   2233                                                 
   2234          //-----------------------------------------------------------------
   2235          //    these functions give printf for text strings used
   2236          //    many times. reduces ROM needed for text storage
   2237          //-----------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
   2238          void print_null(void) {
   \                     print_null:
   \   00000000   80B5               PUSH     {R7,LR}
   2239          	printf("    0           -           -\n\r");
   \   00000002   ....               LDR.N    R0,??DataTable13_55
   \   00000004   ........           BL       printf
   2240          }
   \   00000008   01BD               POP      {R0,PC}          ;; return
   2241          
   2242          

   \                                 In section .text, align 2, keep-with-next
   2243          void print_sp1sp(void) {
   \                     print_sp1sp:
   \   00000000   80B5               PUSH     {R7,LR}
   2244          	printf("    1           ");
   \   00000002   ....               LDR.N    R0,??DataTable13_56
   \   00000004   ........           BL       printf
   2245          }
   \   00000008   01BD               POP      {R0,PC}          ;; return
   2246          
   2247          

   \                                 In section .text, align 2, keep-with-next
   2248          void print_b1sp(void) {
   \                     print_b1sp:
   \   00000000   80B5               PUSH     {R7,LR}
   2249          	printf("1           ");
   \   00000002   ....               LDR.N    R0,??DataTable13_57
   \   00000004   ........           BL       printf
   2250          }
   \   00000008   01BD               POP      {R0,PC}          ;; return
   2251          
   2252          

   \                                 In section .text, align 2, keep-with-next
   2253          void print_b0sp(void) {
   \                     print_b0sp:
   \   00000000   80B5               PUSH     {R7,LR}
   2254          	printf("0           ");
   \   00000002   ....               LDR.N    R0,??DataTable13_58
   \   00000004   ........           BL       printf
   2255          }
   \   00000008   01BD               POP      {R0,PC}          ;; return
   2256          
   2257          

   \                                 In section .text, align 2, keep-with-next
   2258          void print_dddn(void) {
   \                     print_dddn:
   \   00000000   80B5               PUSH     {R7,LR}
   2259          	printf("    -           -           -\n\r");
   \   00000002   ....               LDR.N    R0,??DataTable13_59
   \   00000004   ........           BL       printf
   2260          }
   \   00000008   01BD               POP      {R0,PC}          ;; return
   2261          
   2262          

   \                                 In section .text, align 2, keep-with-next
   2263          void print_dd0n(void) {
   \                     print_dd0n:
   \   00000000   80B5               PUSH     {R7,LR}
   2264          	printf("    -           -           0\n\r");
   \   00000002   ....               LDR.N    R0,??DataTable13_60
   \   00000004   ........           BL       printf
   2265          }
   \   00000008   01BD               POP      {R0,PC}          ;; return
   2266          
   2267          

   \                                 In section .text, align 2, keep-with-next
   2268          void print_dd1n(void) {
   \                     print_dd1n:
   \   00000000   80B5               PUSH     {R7,LR}
   2269          	printf("    -           -           1\n\r");
   \   00000002   ....               LDR.N    R0,??DataTable13_61
   \   00000004   ........           BL       printf
   2270          }
   \   00000008   01BD               POP      {R0,PC}          ;; return
   2271          

   \                                 In section .text, align 2, keep-with-next
   2272          void print_menuprompt(void) {
   \                     print_menuprompt:
   \   00000000   80B5               PUSH     {R7,LR}
   2273          	printf("Press 'M' for menu, or press any valid menu key. >> ");
   \   00000002   ....               LDR.N    R0,??DataTable13_62
   \   00000004   ........           BL       printf
   2274          }
   \   00000008   01BD               POP      {R0,PC}          ;; return
   2275          

   \                                 In section .text, align 2, keep-with-next
   2276          void print_line(void) {
   \                     print_line:
   \   00000000   80B5               PUSH     {R7,LR}
   2277          	printf("===========================================================\n\r");
   \   00000002   ....               LDR.N    R0,??DataTable13_63
   \   00000004   ........           BL       printf
   2278          }
   \   00000008   01BD               POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0A0A0D00           DC8      "\n\n\r"

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0A0D0000           DC8      0x0A, 0x0D, 0x00, 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   310A0D00           DC8      "1\n\r"

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   300A0D00           DC8      "0\n\r"

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   310A0D00           DC8      "1\n\r"

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   300A0D00           DC8      "0\n\r"

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   ........           DC32     `?<Constant {{2097152, (AT91S_PIO *)1074662400,`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   006CDC02           DC32     0x2dc6c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   00400940           DC32     0x40094000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   ........           DC32     `?<Constant "\\n\\r*******************...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   ........           DC32     `?<Constant "   Holt Integrated Ci...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   ........           DC32     `?<Constant "10:24:06">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   ........           DC32     `?<Constant "Jun 18 2012">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   ........           DC32     `?<Constant "        Compiled: %s ...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \   00000000   ........           DC32     `?<Constant "*********************...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_9:
   \   00000000   ........           DC32     `?<Constant "   BC Off  ">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_10:
   \   00000000   ........           DC32     `?<Constant "MT Off   ">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_11:
   \   00000000   ........           DC32     `?<Constant "RT1 On   ">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_12:
   \   00000000   ........           DC32     `?<Constant "RT2 On">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_13:
   \   00000000   ........           DC32     `?<Constant " Press \\'6\\' to list HW...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_14:
   \   00000000   ........           DC32     `?<Constant " Press \\'8\\' to list RT...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_15:
   \   00000000   ........           DC32     `?<Constant " NOTE: Options 6-9 cl...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_16:
   \   00000000   ........           DC32     `?<Constant "\\n\\r Hardware Interrupt...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_17:
   \   00000000   ........           DC32     pH6130

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_18:
   \   00000000   ........           DC32     `?<Constant "HI-6131 Host SPI Erro...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_19:
   \   00000000   ........           DC32     `?<Constant "EE Chksum/Corr RAM Err">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_20:
   \   00000000   ........           DC32     `?<Constant "RAM Init/UncorrRAM Err">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_21:
   \   00000000   ........           DC32     `?<Constant "Loopback Fail on Bus A">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_22:
   \   00000000   ........           DC32     `?<Constant "Loopback Fail on Bus B">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_23:
   \   00000000   ........           DC32     `?<Constant "MT Timetag Ct Rollover">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_24:
   \   00000000   ........           DC32     `?<Constant "BC Timetag Ct Rollover">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_25:
   \   00000000   ........           DC32     `?<Constant "RT2 Timetag Valu Match">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_26:
   \   00000000   ........           DC32     `?<Constant "RT1 Timetag Valu Match">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_27:
   \   00000000   ........           DC32     `?<Constant "MT Timetag Value Match">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_28:
   \   00000000   ........           DC32     `?<Constant "BC Timetag Value Match">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_29:
   \   00000000   ........           DC32     `?<Constant "  RT2 Addr Parity Fail">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_30:
   \   00000000   ........           DC32     `?<Constant "  RT1 Addr Parity Fail">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_31:
   \   00000000   ........           DC32     `?<Constant " Check Pending RT Ints">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_32:
   \   00000000   ........           DC32     `?<Constant " Check Pending MT Ints">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_33:
   \   00000000   ........           DC32     `?<Constant " Check Pending BC Ints">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_34:
   \   00000000   ........           DC32     `?<Constant "Note: Reading the HW ...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_35:
   \   00000000   ........           DC32     `?<Constant "Press \\'M\\' for menu, o...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_36:
   \   00000000   ........           DC32     `?<Constant "\\n\\r Remote Terminal In...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_37:
   \   00000000   ........           DC32     `?<Constant "RT2  Reset RT mode cmd">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_38:
   \   00000000   ........           DC32     `?<Constant "RT2  Index Equals Zero">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_39:
   \   00000000   ........           DC32     `?<Constant "RT2    Illegal Command">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_40:
   \   00000000   ........           DC32     `?<Constant "RT2 Broadcast Msg Rcvd">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_41:
   \   00000000   ........           DC32     `?<Constant "RT2 MessageErrorStatus">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_42:
   \   00000000   ........           DC32     `?<Constant "RT2  Int When Accessed">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_43:
   \   00000000   ........           DC32     `?<Constant "        Reserved Bit 9">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_44:
   \   00000000   ........           DC32     `?<Constant "RT1  Reset RT mode cmd">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_45:
   \   00000000   ........           DC32     `?<Constant "RT1  Index Equals Zero">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_46:
   \   00000000   ........           DC32     `?<Constant "RT1    Illegal Command">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_47:
   \   00000000   ........           DC32     `?<Constant "RT1 Broadcast Msg Rcvd">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_48:
   \   00000000   ........           DC32     `?<Constant "RT1 MessageErrorStatus">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_49:
   \   00000000   ........           DC32     `?<Constant "RT1  Int When Accessed">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_50:
   \   00000000   ........           DC32     `?<Constant "     Reserved Bits 2-0">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_51:
   \   00000000   ........           DC32     `?<Constant "Note: Reading the RT ...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_52:
   \   00000000   ........           DC32     watch

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_53:
   \   00000000   ........           DC32     `?<Constant "\\n\\r Invalid Choice. Pr...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_54:
   \   00000000   ........           DC32     waddr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_55:
   \   00000000   ........           DC32     `?<Constant "    0           -    ...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_56:
   \   00000000   ........           DC32     `?<Constant "    1           ">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_57:
   \   00000000   ........           DC32     `?<Constant "1           ">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_58:
   \   00000000   ........           DC32     `?<Constant "0           ">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_59:
   \   00000000   ........           DC32     `?<Constant "    -           -    ...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_60:
   \   00000000   ........           DC32     `?<Constant "    -           -    ...">_1`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_61:
   \   00000000   ........           DC32     `?<Constant "    -           -    ...">_2`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_62:
   \   00000000   ........           DC32     `?<Constant "Press \\'M\\' for menu, o...">_1`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_63:
   \   00000000   ........           DC32     `?<Constant "=====================...">`

   \                                 In section .rodata, align 4
   \                     `?<Constant {{2097152, (AT91S_PIO *)1074662400,`:
   \   00000000   00002000000C       DC32 2097152, 400E0C00H
   \              0E40        
   \   00000008   0A0000000000       DC8 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   0000001B   0000000000         DC8 0, 0, 0, 0, 0
   \   00000020   00001000000C       DC32 1048576, 400E0C00H
   \              0E40        
   \   00000028   0A0000000000       DC8 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   0000003B   0000000000         DC8 0, 0, 0, 0, 0
   \   00000040   00008000000C       DC32 8388608, 400E0C00H
   \              0E40        
   \   00000048   0A0100000000       DC8 10, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   0000005B   0000000000         DC8 0, 0, 0, 0, 0
   \   00000060   00004000000C       DC32 4194304, 400E0C00H
   \              0E40        
   \   00000068   0A0100000000       DC8 10, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   0000007B   0000000000         DC8 0, 0, 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\r*******************...">`:
   \   00000000   0A0D2A2A2A2A       DC8 0AH, 0DH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH
   \              2A2A        
   \   00000008   2A2A2A2A2A2A       DC8 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH
   \              2A2A        
   \   00000010   2A2A2A2A2A2A       DC8 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH
   \              2A2A        
   \   00000018   2A2A2A2A2A2A       DC8 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH
   \              2A2A        
   \   00000020   2A2A2A2A2A2A       DC8 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH
   \              2A2A        
   \   00000028   2A2A2A2A2A2A       DC8 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH
   \              2A2A        
   \   00000030   2A2A2A0A0D00       DC8 2AH, 2AH, 2AH, 0AH, 0DH, 0
   \   00000036   0000               DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "   Holt Integrated Ci...">`:
   \   00000000   202020486F6C       DC8 20H, 20H, 20H, 48H, 6FH, 6CH, 74H, 20H
   \              7420        
   \   00000008   496E74656772       DC8 49H, 6EH, 74H, 65H, 67H, 72H, 61H, 74H
   \              6174        
   \   00000010   656420436972       DC8 65H, 64H, 20H, 43H, 69H, 72H, 63H, 75H
   \              6375        
   \   00000018   697473204849       DC8 69H, 74H, 73H, 20H, 48H, 49H, 2DH, 36H
   \              2D36        
   \   00000020   3133305F3430       DC8 31H, 33H, 30H, 5FH, 34H, 30H, 20H, 45H
   \              2045        
   \   00000028   42492050726F       DC8 42H, 49H, 20H, 50H, 72H, 6FH, 6AH, 65H
   \              6A65        
   \   00000030   63742020200A       DC8 63H, 74H, 20H, 20H, 20H, 0AH, 0DH, 0
   \              0D00        

   \                                 In section .rodata, align 4
   \                     `?<Constant "        Compiled: %s ...">`:
   \   00000000   202020202020       DC8 "        Compiled: %s %s        \012\015"
   \              2020436F6D70
   \              696C65643A20
   \              257320257320
   \              202020202020
   \              200A0D00    
   \   00000022   0000               DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Jun 18 2012">`:
   \   00000000   4A756E203138       DC8 "Jun 18 2012"
   \              203230313200

   \                                 In section .rodata, align 4
   \                     `?<Constant "10:24:06">`:
   \   00000000   31303A32343A       DC8 "10:24:06"
   \              303600      
   \   00000009   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "*********************...">`:
   \   00000000   2A2A2A2A2A2A       DC8 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH
   \              2A2A        
   \   00000008   2A2A2A2A2A2A       DC8 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH
   \              2A2A        
   \   00000010   2A2A2A2A2A2A       DC8 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH
   \              2A2A        
   \   00000018   2A2A2A2A2A2A       DC8 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH
   \              2A2A        
   \   00000020   2A2A2A2A2A2A       DC8 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH
   \              2A2A        
   \   00000028   2A2A2A2A2A2A       DC8 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH
   \              2A2A        
   \   00000030   2A0A0A0D00         DC8 2AH, 0AH, 0AH, 0DH, 0
   \   00000035   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "   BC Off  ">`:
   \   00000000   202020424320       DC8 "   BC Off  "
   \              4F6666202000

   \                                 In section .rodata, align 4
   \                     `?<Constant "MT Off   ">`:
   \   00000000   4D54204F6666       DC8 "MT Off   "
   \              20202000    
   \   0000000A   0000               DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "RT1 On   ">`:
   \   00000000   525431204F6E       DC8 "RT1 On   "
   \              20202000    
   \   0000000A   0000               DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "RT2 On">`:
   \   00000000   525432204F6E       DC8 "RT2 On"
   \              00          
   \   00000007   00                 DC8 0

   \                                 In section .rodata, align 4
   \   00000000   0A0A0D00           DC8 "\012\012\015"

   \                                 In section .rodata, align 4
   \                     `?<Constant " Press \\'6\\' to list HW...">`:
   \   00000000   205072657373       DC8 " Press '6' to list HW interrupt status...\012\015"
   \              202736272074
   \              6F206C697374
   \              20485720696E
   \              746572727570
   \              742073746174
   \              75732E2E2E0A
   \              0D00        

   \                                 In section .rodata, align 4
   \                     `?<Constant " Press \\'8\\' to list RT...">`:
   \   00000000   205072657373       DC8 " Press '8' to list RT interrupt status...\012\015"
   \              202738272074
   \              6F206C697374
   \              20525420696E
   \              746572727570
   \              742073746174
   \              75732E2E2E0A
   \              0D00        

   \                                 In section .rodata, align 4
   \                     `?<Constant " NOTE: Options 6-9 cl...">`:
   \   00000000   204E4F54453A       DC8 20H, 4EH, 4FH, 54H, 45H, 3AH, 20H, 4FH
   \              204F        
   \   00000008   7074696F6E73       DC8 70H, 74H, 69H, 6FH, 6EH, 73H, 20H, 36H
   \              2036        
   \   00000010   2D3920636C65       DC8 2DH, 39H, 20H, 63H, 6CH, 65H, 61H, 72H
   \              6172        
   \   00000018   207468652061       DC8 20H, 74H, 68H, 65H, 20H, 61H, 63H, 63H
   \              6363        
   \   00000020   657373656420       DC8 65H, 73H, 73H, 65H, 64H, 20H, 50H, 65H
   \              5065        
   \   00000028   6E64696E6720       DC8 6EH, 64H, 69H, 6EH, 67H, 20H, 49H, 6EH
   \              496E        
   \   00000030   746572727570       DC8 74H, 65H, 72H, 72H, 75H, 70H, 74H, 20H
   \              7420        
   \   00000038   526567697374       DC8 52H, 65H, 67H, 69H, 73H, 74H, 65H, 72H
   \              6572        
   \   00000040   210A0D00           DC8 21H, 0AH, 0DH, 0

   \                                 In section .rodata, align 4
   \   00000000   0A0D00             DC8 "\012\015"
   \   00000003   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\r Hardware Interrupt...">`:
   \   00000000   0A0D20486172       DC8 0AH, 0DH, 20H, 48H, 61H, 72H, 64H, 77H
   \              6477        
   \   00000008   61726520496E       DC8 61H, 72H, 65H, 20H, 49H, 6EH, 74H, 65H
   \              7465        
   \   00000010   727275707473       DC8 72H, 72H, 75H, 70H, 74H, 73H, 20H, 20H
   \              2020        
   \   00000018   20456E61626C       DC8 20H, 45H, 6EH, 61H, 62H, 6CH, 65H, 64H
   \              6564        
   \   00000020   3F2020205069       DC8 3FH, 20H, 20H, 20H, 50H, 69H, 6EH, 20H
   \              6E20        
   \   00000028   4F7574707574       DC8 4FH, 75H, 74H, 70H, 75H, 74H, 3FH, 20H
   \              3F20        
   \   00000030   202050656E64       DC8 20H, 20H, 50H, 65H, 6EH, 64H, 69H, 6EH
   \              696E        
   \   00000038   673F0A0D00         DC8 67H, 3FH, 0AH, 0DH, 0
   \   0000003D   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "HI-6131 Host SPI Erro...">`:
   \   00000000   48492D363133       DC8 48H, 49H, 2DH, 36H, 31H, 33H, 31H, 20H
   \              3120        
   \   00000008   486F73742053       DC8 48H, 6FH, 73H, 74H, 20H, 53H, 50H, 49H
   \              5049        
   \   00000010   204572726F72       DC8 20H, 45H, 72H, 72H, 6FH, 72H, 20H, 20H
   \              2020        
   \   00000018   20206E2F6120       DC8 20H, 20H, 6EH, 2FH, 61H, 20H, 20H, 20H
   \              2020        
   \   00000020   202020202020       DC8 20H, 20H, 20H, 20H, 20H, 20H, 6EH, 2FH
   \              6E2F        
   \   00000028   612020202020       DC8 61H, 20H, 20H, 20H, 20H, 20H, 20H, 20H
   \              2020        
   \   00000030   20206E2F610A       DC8 20H, 20H, 6EH, 2FH, 61H, 0AH, 0DH, 0
   \              0D00        

   \                                 In section .rodata, align 4
   \                     `?<Constant "EE Chksum/Corr RAM Err">`:
   \   00000000   45452043686B       DC8 "EE Chksum/Corr RAM Err"
   \              73756D2F436F
   \              72722052414D
   \              2045727200  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \   00000000   310A0D00           DC8 "1\012\015"

   \                                 In section .rodata, align 4
   \   00000000   300A0D00           DC8 "0\012\015"

   \                                 In section .rodata, align 4
   \                     `?<Constant "RAM Init/UncorrRAM Err">`:
   \   00000000   52414D20496E       DC8 "RAM Init/UncorrRAM Err"
   \              69742F556E63
   \              6F727252414D
   \              2045727200  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Loopback Fail on Bus A">`:
   \   00000000   4C6F6F706261       DC8 "Loopback Fail on Bus A"
   \              636B20466169
   \              6C206F6E2042
   \              7573204100  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Loopback Fail on Bus B">`:
   \   00000000   4C6F6F706261       DC8 "Loopback Fail on Bus B"
   \              636B20466169
   \              6C206F6E2042
   \              7573204200  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "MT Timetag Ct Rollover">`:
   \   00000000   4D542054696D       DC8 "MT Timetag Ct Rollover"
   \              657461672043
   \              7420526F6C6C
   \              6F76657200  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "BC Timetag Ct Rollover">`:
   \   00000000   42432054696D       DC8 "BC Timetag Ct Rollover"
   \              657461672043
   \              7420526F6C6C
   \              6F76657200  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "RT2 Timetag Valu Match">`:
   \   00000000   525432205469       DC8 "RT2 Timetag Valu Match"
   \              6D6574616720
   \              56616C75204D
   \              6174636800  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "RT1 Timetag Valu Match">`:
   \   00000000   525431205469       DC8 "RT1 Timetag Valu Match"
   \              6D6574616720
   \              56616C75204D
   \              6174636800  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "MT Timetag Value Match">`:
   \   00000000   4D542054696D       DC8 "MT Timetag Value Match"
   \              657461672056
   \              616C7565204D
   \              6174636800  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "BC Timetag Value Match">`:
   \   00000000   42432054696D       DC8 "BC Timetag Value Match"
   \              657461672056
   \              616C7565204D
   \              6174636800  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "  RT2 Addr Parity Fail">`:
   \   00000000   202052543220       DC8 "  RT2 Addr Parity Fail"
   \              416464722050
   \              617269747920
   \              4661696C00  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "  RT1 Addr Parity Fail">`:
   \   00000000   202052543120       DC8 "  RT1 Addr Parity Fail"
   \              416464722050
   \              617269747920
   \              4661696C00  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant " Check Pending RT Ints">`:
   \   00000000   20436865636B       DC8 " Check Pending RT Ints"
   \              2050656E6469
   \              6E6720525420
   \              496E747300  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant " Check Pending MT Ints">`:
   \   00000000   20436865636B       DC8 " Check Pending MT Ints"
   \              2050656E6469
   \              6E67204D5420
   \              496E747300  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant " Check Pending BC Ints">`:
   \   00000000   20436865636B       DC8 " Check Pending BC Ints"
   \              2050656E6469
   \              6E6720424320
   \              496E747300  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Note: Reading the HW ...">`:
   \   00000000   4E6F74653A20       DC8 4EH, 6FH, 74H, 65H, 3AH, 20H, 52H, 65H
   \              5265        
   \   00000008   6164696E6720       DC8 61H, 64H, 69H, 6EH, 67H, 20H, 74H, 68H
   \              7468        
   \   00000010   652048572050       DC8 65H, 20H, 48H, 57H, 20H, 50H, 65H, 6EH
   \              656E        
   \   00000018   64696E672049       DC8 64H, 69H, 6EH, 67H, 20H, 49H, 6EH, 74H
   \              6E74        
   \   00000020   657272757074       DC8 65H, 72H, 72H, 75H, 70H, 74H, 20H, 52H
   \              2052        
   \   00000028   656769737465       DC8 65H, 67H, 69H, 73H, 74H, 65H, 72H, 20H
   \              7220        
   \   00000030   636C65617273       DC8 63H, 6CH, 65H, 61H, 72H, 73H, 20H, 69H
   \              2069        
   \   00000038   74210A0D00         DC8 74H, 21H, 0AH, 0DH, 0
   \   0000003D   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Press \\'M\\' for menu, o...">`:
   \   00000000   507265737320       DC8 50H, 72H, 65H, 73H, 73H, 20H, 27H, 4DH
   \              274D        
   \   00000008   2720666F7220       DC8 27H, 20H, 66H, 6FH, 72H, 20H, 6DH, 65H
   \              6D65        
   \   00000010   6E752C206F72       DC8 6EH, 75H, 2CH, 20H, 6FH, 72H, 20H, 70H
   \              2070        
   \   00000018   726573732061       DC8 72H, 65H, 73H, 73H, 20H, 61H, 6EH, 79H
   \              6E79        
   \   00000020   2076616C6964       DC8 20H, 76H, 61H, 6CH, 69H, 64H, 20H, 6DH
   \              206D        
   \   00000028   656E75206B65       DC8 65H, 6EH, 75H, 20H, 6BH, 65H, 79H, 2EH
   \              792E        
   \   00000030   20202000           DC8 20H, 20H, 20H, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\r Remote Terminal In...">`:
   \   00000000   0A0D2052656D       DC8 0AH, 0DH, 20H, 52H, 65H, 6DH, 6FH, 74H
   \              6F74        
   \   00000008   65205465726D       DC8 65H, 20H, 54H, 65H, 72H, 6DH, 69H, 6EH
   \              696E        
   \   00000010   616C20496E74       DC8 61H, 6CH, 20H, 49H, 6EH, 74H, 73H, 20H
   \              7320        
   \   00000018   20456E61626C       DC8 20H, 45H, 6EH, 61H, 62H, 6CH, 65H, 64H
   \              6564        
   \   00000020   3F2020205069       DC8 3FH, 20H, 20H, 20H, 50H, 69H, 6EH, 20H
   \              6E20        
   \   00000028   4F7574707574       DC8 4FH, 75H, 74H, 70H, 75H, 74H, 3FH, 20H
   \              3F20        
   \   00000030   202050656E64       DC8 20H, 20H, 50H, 65H, 6EH, 64H, 69H, 6EH
   \              696E        
   \   00000038   673F0A0D00         DC8 67H, 3FH, 0AH, 0DH, 0
   \   0000003D   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "RT2  Reset RT mode cmd">`:
   \   00000000   525432202052       DC8 "RT2  Reset RT mode cmd"
   \              657365742052
   \              54206D6F6465
   \              20636D6400  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "RT2  Index Equals Zero">`:
   \   00000000   525432202049       DC8 "RT2  Index Equals Zero"
   \              6E6465782045
   \              7175616C7320
   \              5A65726F00  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "RT2    Illegal Command">`:
   \   00000000   525432202020       DC8 "RT2    Illegal Command"
   \              20496C6C6567
   \              616C20436F6D
   \              6D616E6400  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "RT2 Broadcast Msg Rcvd">`:
   \   00000000   525432204272       DC8 "RT2 Broadcast Msg Rcvd"
   \              6F6164636173
   \              74204D736720
   \              5263766400  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "RT2 MessageErrorStatus">`:
   \   00000000   525432204D65       DC8 "RT2 MessageErrorStatus"
   \              737361676545
   \              72726F725374
   \              6174757300  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "RT2  Int When Accessed">`:
   \   00000000   525432202049       DC8 "RT2  Int When Accessed"
   \              6E7420576865
   \              6E2041636365
   \              7373656400  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "        Reserved Bit 9">`:
   \   00000000   202020202020       DC8 "        Reserved Bit 9"
   \              202052657365
   \              727665642042
   \              6974203900  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "RT1  Reset RT mode cmd">`:
   \   00000000   525431202052       DC8 "RT1  Reset RT mode cmd"
   \              657365742052
   \              54206D6F6465
   \              20636D6400  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "RT1  Index Equals Zero">`:
   \   00000000   525431202049       DC8 "RT1  Index Equals Zero"
   \              6E6465782045
   \              7175616C7320
   \              5A65726F00  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "RT1    Illegal Command">`:
   \   00000000   525431202020       DC8 "RT1    Illegal Command"
   \              20496C6C6567
   \              616C20436F6D
   \              6D616E6400  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "RT1 Broadcast Msg Rcvd">`:
   \   00000000   525431204272       DC8 "RT1 Broadcast Msg Rcvd"
   \              6F6164636173
   \              74204D736720
   \              5263766400  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "RT1 MessageErrorStatus">`:
   \   00000000   525431204D65       DC8 "RT1 MessageErrorStatus"
   \              737361676545
   \              72726F725374
   \              6174757300  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "RT1  Int When Accessed">`:
   \   00000000   525431202049       DC8 "RT1  Int When Accessed"
   \              6E7420576865
   \              6E2041636365
   \              7373656400  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "     Reserved Bits 2-0">`:
   \   00000000   202020202052       DC8 "     Reserved Bits 2-0"
   \              657365727665
   \              642042697473
   \              20322D3000  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Note: Reading the RT ...">`:
   \   00000000   4E6F74653A20       DC8 4EH, 6FH, 74H, 65H, 3AH, 20H, 52H, 65H
   \              5265        
   \   00000008   6164696E6720       DC8 61H, 64H, 69H, 6EH, 67H, 20H, 74H, 68H
   \              7468        
   \   00000010   652052542050       DC8 65H, 20H, 52H, 54H, 20H, 50H, 65H, 6EH
   \              656E        
   \   00000018   64696E672049       DC8 64H, 69H, 6EH, 67H, 20H, 49H, 6EH, 74H
   \              6E74        
   \   00000020   657272757074       DC8 65H, 72H, 72H, 75H, 70H, 74H, 20H, 52H
   \              2052        
   \   00000028   656769737465       DC8 65H, 67H, 69H, 73H, 74H, 65H, 72H, 20H
   \              7220        
   \   00000030   636C65617273       DC8 63H, 6CH, 65H, 61H, 72H, 73H, 20H, 69H
   \              2069        
   \   00000038   74210A0D00         DC8 74H, 21H, 0AH, 0DH, 0
   \   0000003D   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\r Invalid Choice. Pr...">`:
   \   00000000   0A0D20496E76       DC8 0AH, 0DH, 20H, 49H, 6EH, 76H, 61H, 6CH
   \              616C        
   \   00000008   69642043686F       DC8 69H, 64H, 20H, 43H, 68H, 6FH, 69H, 63H
   \              6963        
   \   00000010   652E20507265       DC8 65H, 2EH, 20H, 50H, 72H, 65H, 73H, 73H
   \              7373        
   \   00000018   20274D272066       DC8 20H, 27H, 4DH, 27H, 20H, 66H, 6FH, 72H
   \              6F72        
   \   00000020   206D656E752C       DC8 20H, 6DH, 65H, 6EH, 75H, 2CH, 20H, 6FH
   \              206F        
   \   00000028   722070726573       DC8 72H, 20H, 70H, 72H, 65H, 73H, 73H, 20H
   \              7320        
   \   00000030   616E79207661       DC8 61H, 6EH, 79H, 20H, 76H, 61H, 6CH, 69H
   \              6C69        
   \   00000038   64206D656E75       DC8 64H, 20H, 6DH, 65H, 6EH, 75H, 20H, 6BH
   \              206B        
   \   00000040   65792E203E3E       DC8 65H, 79H, 2EH, 20H, 3EH, 3EH, 20H, 0
   \              2000        

   \                                 In section .rodata, align 4
   \                     `?<Constant "    0           -    ...">`:
   \   00000000   202020203020       DC8 "    0           -           -\012\015"
   \              202020202020
   \              202020202D20
   \              202020202020
   \              202020202D0A
   \              0D00        

   \                                 In section .rodata, align 4
   \                     `?<Constant "    1           ">`:
   \   00000000   202020203120       DC8 "    1           "
   \              202020202020
   \              2020202000  
   \   00000011   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "1           ">`:
   \   00000000   312020202020       DC8 "1           "
   \              202020202020
   \              00          
   \   0000000D   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "0           ">`:
   \   00000000   302020202020       DC8 "0           "
   \              202020202020
   \              00          
   \   0000000D   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "    -           -    ...">`:
   \   00000000   202020202D20       DC8 "    -           -           -\012\015"
   \              202020202020
   \              202020202D20
   \              202020202020
   \              202020202D0A
   \              0D00        

   \                                 In section .rodata, align 4
   \                     `?<Constant "    -           -    ...">_1`:
   \   00000000   202020202D20       DC8 "    -           -           0\012\015"
   \              202020202020
   \              202020202D20
   \              202020202020
   \              20202020300A
   \              0D00        

   \                                 In section .rodata, align 4
   \                     `?<Constant "    -           -    ...">_2`:
   \   00000000   202020202D20       DC8 "    -           -           1\012\015"
   \              202020202020
   \              202020202D20
   \              202020202020
   \              20202020310A
   \              0D00        

   \                                 In section .rodata, align 4
   \                     `?<Constant "Press \\'M\\' for menu, o...">_1`:
   \   00000000   507265737320       DC8 50H, 72H, 65H, 73H, 73H, 20H, 27H, 4DH
   \              274D        
   \   00000008   2720666F7220       DC8 27H, 20H, 66H, 6FH, 72H, 20H, 6DH, 65H
   \              6D65        
   \   00000010   6E752C206F72       DC8 6EH, 75H, 2CH, 20H, 6FH, 72H, 20H, 70H
   \              2070        
   \   00000018   726573732061       DC8 72H, 65H, 73H, 73H, 20H, 61H, 6EH, 79H
   \              6E79        
   \   00000020   2076616C6964       DC8 20H, 76H, 61H, 6CH, 69H, 64H, 20H, 6DH
   \              206D        
   \   00000028   656E75206B65       DC8 65H, 6EH, 75H, 20H, 6BH, 65H, 79H, 2EH
   \              792E        
   \   00000030   203E3E2000         DC8 20H, 3EH, 3EH, 20H, 0
   \   00000035   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "=====================...">`:
   \   00000000   3D3D3D3D3D3D       DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              3D3D        
   \   00000008   3D3D3D3D3D3D       DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              3D3D        
   \   00000010   3D3D3D3D3D3D       DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              3D3D        
   \   00000018   3D3D3D3D3D3D       DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              3D3D        
   \   00000020   3D3D3D3D3D3D       DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              3D3D        
   \   00000028   3D3D3D3D3D3D       DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              3D3D        
   \   00000030   3D3D3D3D3D3D       DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              3D3D        
   \   00000038   3D3D3D0A0D00       DC8 3DH, 3DH, 3DH, 0AH, 0DH, 0
   \   0000003E   0000               DC8 0, 0
   2279          
   2280          

   Maximum stack usage in bytes:

     Function             .cstack
     --------             -------
     ConfigureUsart1         136
     ascii2int                 0
     chk_key_input             8
     list_hw_ints_console     16
     list_rt_ints_console     16
     print_b0sp                8
     print_b1sp                8
     print_dd0n                8
     print_dd1n                8
     print_dddn                8
     print_line                8
     print_menuprompt          8
     print_null                8
     print_sp1sp               8
     show_menu                 8


   Section sizes:

     Function/Label                                 Bytes
     --------------                                 -----
     waddr                                             2
     watch                                             1
     ConfigureUsart1                                  76
     show_menu                                       126
     list_hw_ints_console                            798
     list_rt_ints_console                            732
     chk_key_input                                   150
     ascii2int                                        70
     print_null                                       10
     print_sp1sp                                      10
     print_b1sp                                       10
     print_b0sp                                       10
     print_dddn                                       10
     print_dd0n                                       10
     print_dd1n                                       10
     print_menuprompt                                 10
     print_line                                       10
     ??DataTable1                                      4
     ??DataTable1_1                                    4
     ??DataTable2                                      4
     ??DataTable2_1                                    4
     ??DataTable3                                      4
     ??DataTable3_1                                    4
     ??DataTable13                                     4
     ??DataTable13_1                                   4
     ??DataTable13_2                                   4
     ??DataTable13_3                                   4
     ??DataTable13_4                                   4
     ??DataTable13_5                                   4
     ??DataTable13_6                                   4
     ??DataTable13_7                                   4
     ??DataTable13_8                                   4
     ??DataTable13_9                                   4
     ??DataTable13_10                                  4
     ??DataTable13_11                                  4
     ??DataTable13_12                                  4
     ??DataTable13_13                                  4
     ??DataTable13_14                                  4
     ??DataTable13_15                                  4
     ??DataTable13_16                                  4
     ??DataTable13_17                                  4
     ??DataTable13_18                                  4
     ??DataTable13_19                                  4
     ??DataTable13_20                                  4
     ??DataTable13_21                                  4
     ??DataTable13_22                                  4
     ??DataTable13_23                                  4
     ??DataTable13_24                                  4
     ??DataTable13_25                                  4
     ??DataTable13_26                                  4
     ??DataTable13_27                                  4
     ??DataTable13_28                                  4
     ??DataTable13_29                                  4
     ??DataTable13_30                                  4
     ??DataTable13_31                                  4
     ??DataTable13_32                                  4
     ??DataTable13_33                                  4
     ??DataTable13_34                                  4
     ??DataTable13_35                                  4
     ??DataTable13_36                                  4
     ??DataTable13_37                                  4
     ??DataTable13_38                                  4
     ??DataTable13_39                                  4
     ??DataTable13_40                                  4
     ??DataTable13_41                                  4
     ??DataTable13_42                                  4
     ??DataTable13_43                                  4
     ??DataTable13_44                                  4
     ??DataTable13_45                                  4
     ??DataTable13_46                                  4
     ??DataTable13_47                                  4
     ??DataTable13_48                                  4
     ??DataTable13_49                                  4
     ??DataTable13_50                                  4
     ??DataTable13_51                                  4
     ??DataTable13_52                                  4
     ??DataTable13_53                                  4
     ??DataTable13_54                                  4
     ??DataTable13_55                                  4
     ??DataTable13_56                                  4
     ??DataTable13_57                                  4
     ??DataTable13_58                                  4
     ??DataTable13_59                                  4
     ??DataTable13_60                                  4
     ??DataTable13_61                                  4
     ??DataTable13_62                                  4
     ??DataTable13_63                                  4
     ?<Constant {{2097152, (AT91S_PIO *)1074662400,  128
     ?<Constant "\n\r*******************...">         56
     ?<Constant "   Holt Integrated Ci...">           56
     ?<Constant "        Compiled: %s ...">           36
     ?<Constant "Jun 18 2012">                        12
     ?<Constant "10:24:06">                           12
     ?<Constant "*********************...">           56
     ?<Constant "   BC Off  ">                        12
     ?<Constant "MT Off   ">                          12
     ?<Constant "RT1 On   ">                          12
     ?<Constant "RT2 On">                              8
     ?<Constant "\n\n\r">                              4
     ?<Constant " Press \'6\' to list HW...">         44
     ?<Constant " Press \'8\' to list RT...">         44
     ?<Constant " NOTE: Options 6-9 cl...">           68
     ?<Constant "\n\r">                                4
     ?<Constant "\n\r Hardware Interrupt...">         64
     ?<Constant "HI-6131 Host SPI Erro...">           56
     ?<Constant "EE Chksum/Corr RAM Err">             24
     ?<Constant "1\n\r">                               4
     ?<Constant "0\n\r">                               4
     ?<Constant "RAM Init/UncorrRAM Err">             24
     ?<Constant "Loopback Fail on Bus A">             24
     ?<Constant "Loopback Fail on Bus B">             24
     ?<Constant "MT Timetag Ct Rollover">             24
     ?<Constant "BC Timetag Ct Rollover">             24
     ?<Constant "RT2 Timetag Valu Match">             24
     ?<Constant "RT1 Timetag Valu Match">             24
     ?<Constant "MT Timetag Value Match">             24
     ?<Constant "BC Timetag Value Match">             24
     ?<Constant "  RT2 Addr Parity Fail">             24
     ?<Constant "  RT1 Addr Parity Fail">             24
     ?<Constant " Check Pending RT Ints">             24
     ?<Constant " Check Pending MT Ints">             24
     ?<Constant " Check Pending BC Ints">             24
     ?<Constant "Note: Reading the HW ...">           64
     ?<Constant "Press \'M\' for menu, o...">         52
     ?<Constant "\n\r Remote Terminal In...">         64
     ?<Constant "RT2  Reset RT mode cmd">             24
     ?<Constant "RT2  Index Equals Zero">             24
     ?<Constant "RT2    Illegal Command">             24
     ?<Constant "RT2 Broadcast Msg Rcvd">             24
     ?<Constant "RT2 MessageErrorStatus">             24
     ?<Constant "RT2  Int When Accessed">             24
     ?<Constant "        Reserved Bit 9">             24
     ?<Constant "RT1  Reset RT mode cmd">             24
     ?<Constant "RT1  Index Equals Zero">             24
     ?<Constant "RT1    Illegal Command">             24
     ?<Constant "RT1 Broadcast Msg Rcvd">             24
     ?<Constant "RT1 MessageErrorStatus">             24
     ?<Constant "RT1  Int When Accessed">             24
     ?<Constant "     Reserved Bits 2-0">             24
     ?<Constant "Note: Reading the RT ...">           64
     ?<Constant "\n\r Invalid Choice. Pr...">         72
     ?<Constant "    0           -    ...">           32
     ?<Constant "    1           ">                   20
     ?<Constant "1           ">                       16
     ?<Constant "0           ">                       16
     ?<Constant "    -           -    ...">           32
     ?<Constant "    -           -    ...">_1         32
     ?<Constant "    -           -    ...">_2         32
     ?<Constant "Press \'M\' for menu, o...">_1       56
     ?<Constant "=====================...">           64

 
     3 bytes in section .bss
 2 004 bytes in section .rodata
 2 322 bytes in section .text
 
 2 322 bytes of CODE  memory
 2 004 bytes of CONST memory
     3 bytes of DATA  memory

Errors: none
Warnings: none
