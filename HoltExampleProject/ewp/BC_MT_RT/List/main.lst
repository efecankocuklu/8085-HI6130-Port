###############################################################################
#                                                                             #
#                                                       17/May/2012  09:55:11 #
# IAR ANSI C/C++ Compiler V6.21.1.32794/W32 KICKSTART for ARM                 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Program Files\IAR Systems\Embedded Workbench 6.0      #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-31 Demo 1_3 Combo\main.c                         #
#    Command line =  "C:\Program Files\IAR Systems\Embedded Workbench 6.0     #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-31 Demo 1_3 Combo\main.c" -D at91sam3u4 -D       #
#                    flash -D TRACE_LEVEL=4 -D HOST_BUS_INTERFACE=1 -D        #
#                    BC_ena=1 -D RT2_ena=1 -D RT1_ena=1 -D SMT_ena=1 -D       #
#                    IMT_ena=0 -lC "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 6.0 Kickstart_2\arm\examples\Atmel\at91sam3u-e #
#                    k\_Holt HI-6130-31 Demo 1_3 Combo\ewp\BC_MT_RT\List\"    #
#                    --remarks --diag_suppress Pe826,Pe1375,Pe068 -o          #
#                    "C:\Program Files\IAR Systems\Embedded Workbench 6.0     #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-31 Demo 1_3 Combo\ewp\BC_MT_RT\Obj\" --no_cse    #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench 6.0                 #
#                    Kickstart_2\arm\INC\c\DLib_Config_Full.h" -I             #
#                    "C:\Program Files\IAR Systems\Embedded Workbench 6.0     #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-31 Demo 1_3 Combo\ewp\..\..\..\at91lib/periphera #
#                    ls\" -I "C:\Program Files\IAR Systems\Embedded           #
#                    Workbench 6.0 Kickstart_2\arm\examples\Atmel\at91sam3u-e #
#                    k\_Holt HI-6130-31 Demo 1_3                              #
#                    Combo\ewp\..\..\..\at91lib/components\" -I "C:\Program   #
#                    Files\IAR Systems\Embedded Workbench 6.0                 #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-31 Demo 1_3 Combo\ewp\..\..\..\at91lib\" -I      #
#                    "C:\Program Files\IAR Systems\Embedded Workbench 6.0     #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-31 Demo 1_3 Combo\ewp\..\..\..\external_libs\"   #
#                    -I "C:\Program Files\IAR Systems\Embedded Workbench 6.0  #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-31 Demo 1_3 Combo\ewp\..\..\..\at91lib/boards/at #
#                    91sam3u-ek\" --cpu_mode thumb -On --use_c++_inline       #
#    List file    =  C:\Program Files\IAR Systems\Embedded Workbench 6.0      #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-31 Demo 1_3 Combo\ewp\BC_MT_RT\List\main.lst     #
#    Object file  =  C:\Program Files\IAR Systems\Embedded Workbench 6.0      #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-31 Demo 1_3 Combo\ewp\BC_MT_RT\Obj\main.o        #
#                                                                             #
#                                                                             #
###############################################################################

C:\Program Files\IAR Systems\Embedded Workbench 6.0 Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt HI-6130-31 Demo 1_3 Combo\main.c
      1          /* ----------------------------------------------------------------------------
      2           *            HOLT INTEGRATED CIRCUITS Applications Engineering
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2011, Holt Integrated Circuits
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Holt's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY HOLT "AS IS" AND ANY EXPRESSED OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL HOLT BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          
     31          //------------------------------------------------------------------------------
     32          //         Headers
     33          //------------------------------------------------------------------------------
     34          // standard Atmel/IAR headers
     35          #include <board.h>
     36          #include <pio/pio.h>
     37          #include <tc/tc.h>
     38          #include <irq/irq.h>
     39          #include <utility/trace.h>
     40          #include <intrinsics.h>
     41          
     42          // Holt project headers
     43          #include "board_613x.h"
     44          #include "613x_bc.h"
     45          #include "613x_mt.h"
     46          #include "613x_rt.h"
     47          #include "613x_regs.h"
     48          #include "613x_initialization.h"
     49          
     50          #if (HOST_BUS_INTERFACE)                    
     51          #include "board_6130.h"
     52          #include "device_6130.h"
     53          
     54          #else // HOST SPI INTERFACE
     55          #include "board_6131.h"
     56          #include "device_6131.h"
     57          #endif
     58          
     59          #if(CONSOLE_IO)
     60          #include "console.h"
     61          #endif
     62          
     63          
     64          //------------------------------------------------------------------------------
     65          //         Global variables
     66          //------------------------------------------------------------------------------
     67          
     68          #if (HOST_BUS_INTERFACE)                    
     69          // This does not apply to SPI interface HI-6131...
     70          // HI-6130 register structure base address
     71          // you can highlight pH6130 below and drag it into a 
     72          // Watch Window in IAR Embedded Workbench for ARM:

   \                                 In section .rodata, align 4
     73          const H6130 pH6130 = HI6130_BASE;
   \                     pH6130:
   \   00000000   00000060           DC32 60000000H
     74          
     75          #if(RT1_ena)
     76          // you can highlight pRT1d or pRT1i below and drag into a 
     77          // Watch Window in IAR Embedded Workbench for ARM:

   \                                 In section .rodata, align 4
     78          const RT1d pRT1d = RT1_DTABLE_BASE;
   \                     pRT1d:
   \   00000000   00080060           DC32 60000800H

   \                                 In section .rodata, align 4
     79          const RT1i pRT1i = RT1_ITABLE_BASE;
   \                     pRT1i:
   \   00000000   00040060           DC32 60000400H
     80          #endif // (RT1_ena)
     81          
     82          #if(RT2_ena)
     83          // you can highlight pRT2d or pRT2i below and drag into a 
     84          // Watch Window in IAR Embedded Workbench for ARM:

   \                                 In section .rodata, align 4
     85          const RT2d pRT2d = RT2_DTABLE_BASE;
   \                     pRT2d:
   \   00000000   000C0060           DC32 60000C00H

   \                                 In section .rodata, align 4
     86          const RT2i pRT2i = RT2_ITABLE_BASE;
   \                     pRT2i:
   \   00000000   00060060           DC32 60000600H
     87          #endif // (RT2_ena)
     88          
     89          #if(BC_ena)
     90          // you can highlight pGPQ or pBCil below and drag into a 
     91          // Watch Window in IAR Embedded Workbench for ARM:

   \                                 In section .data, align 4
     92          GPQ pGPQ = (GPQ) GPQ_BASE_BUS_ADDR;
   \                     pGPQ:
   \   00000000   00180060           DC32 60001800H

   \                                 In section .rodata, align 4
     93          const BCil pBCil = BC_ILIST_BASE;
   \                     pBCil:
   \   00000000   E0360060           DC32 600036E0H

   \                                 In section .rodata, align 4
     94          const BCstack pBCstack = BC_STACK_BASE; 
   \                     pBCstack:
   \   00000000   007C0060           DC32 60007C00H

   \                                 In section .rodata, align 4
     95          const BCstack2RT pBCstack2RT = BC_2RTSTACK_BASE; 
   \                     pBCstack2RT:
   \   00000000   807C0060           DC32 60007C80H
     96          #endif // (BC_ena)
     97          
     98          #if(SMT_ena)

   \                                 In section .data, align 4
     99          DSTK pDSTK = (DSTK) DSTACK_BASE_BUS_ADDR;
   \                     pDSTK:
   \   00000000   00C00060           DC32 6000C000H

   \                                 In section .rodata, align 4
    100          const ScSTK pScSTK = SMT_CMDSTACK_BASE;
   \                     pScSTK:
   \   00000000   00A80060           DC32 6000A800H

   \                                 In section .rodata, align 4
    101          const MTF pMTF = MT_FTABLE_BASE;
   \                     pMTF:
   \   00000000   00020060           DC32 60000200H

   \                                 In section .rodata, align 4
    102          const AddrList pAddrList = MT_ALIST_BASE;
   \                     pAddrList:
   \   00000000   60010060           DC32 60000160H
    103          #endif // (SMT_ena)
    104          
    105          #if(IMT_ena)
    106          const MTF pMTF = MT_FTABLE_BASE;
    107          const AddrList pAddrList = MT_ALIST_BASE;
    108          PktHdr pPktHdr;
    109          IPMB pIPMB;
    110          #endif // (IMT_ena)
    111          
    112          #else  // HOST_SPI_INTERFACE
    113          extern char spi_busy, spi_irq;
    114          #endif // HOST_SPI_INTERFACE
    115          
    116          
    117          //------------------------------------------------------------------------------
    118          //         Functions
    119          //------------------------------------------------------------------------------
    120          
    121          
    122          //------------------------------------------------------------------------------
    123          /// Application entry point. ARM I/O and the Holt HI-613x device are configured,
    124          /// then execution waits in an endless loop.
    125          
    126          /// IAR intrinsic functions used in this program:
    127          ///         __disable_irq();
    128          ///         __enable_irq();
    129          /// These require intrinsics.h header file
    130          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    131          void main(void) {
   \                     main:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   A0B0               SUB      SP,SP,#+128
    132            
    133              unsigned short j, ttconfig = 0, runbits = 0;
   \   00000004   0025               MOVS     R5,#+0
   \   00000006   0026               MOVS     R6,#+0
    134              const Pin pinAUTOEN =  PIN_AUTOEN;
   \   00000008   18A8               ADD      R0,SP,#+96
   \   0000000A   5B49               LDR.N    R1,??main_0
   \   0000000C   2022               MOVS     R2,#+32
   \   0000000E   ........           BL       __aeabi_memcpy4
    135              const Pin pinCOPYREQ = PIN_CPYREQ;
   \   00000012   10A8               ADD      R0,SP,#+64
   \   00000014   5949               LDR.N    R1,??main_0+0x4
   \   00000016   2022               MOVS     R2,#+32
   \   00000018   ........           BL       __aeabi_memcpy4
    136              const Pin pinNMR = PIN_NMR;
   \   0000001C   08A8               ADD      R0,SP,#+32
   \   0000001E   5849               LDR.N    R1,??main_0+0x8
   \   00000020   2022               MOVS     R2,#+32
   \   00000022   ........           BL       __aeabi_memcpy4
    137              #if(RT1_ena||RT2_ena)
    138              const Pin pinNSW1 = PIN_NSW1;
   \   00000026   00A8               ADD      R0,SP,#+0
   \   00000028   5649               LDR.N    R1,??main_0+0xC
   \   0000002A   2022               MOVS     R2,#+32
   \   0000002C   ........           BL       __aeabi_memcpy4
    139              #endif
    140              
    141              __disable_interrupt(); // until initialization is complete
   \   00000030   72B6               CPSID    I
    142          
    143              // first priority: reset pin to 0 for HI-613x nMR, then configure that MCU pin as output
    144              AT91C_BASE_PIOC->PIO_CODR = nMR;  
   \   00000032   5548               LDR.N    R0,??main_0+0x10  ;; 0x400e1034
   \   00000034   5FF00071           MOVS     R1,#+33554432
   \   00000038   0160               STR      R1,[R0, #+0]
    145              PIO_Configure(&pinNMR,1);
   \   0000003A   0121               MOVS     R1,#+1
   \   0000003C   08A8               ADD      R0,SP,#+32
   \   0000003E   ........           BL       PIO_Configure
    146                    
    147              // Configure ARM's other general purpose I/O pins and timer(s) 
    148              ConfigureGpio();
   \   00000042   ........           BL       ConfigureGpio
    149              init_timer();
   \   00000046   ........           BL       init_timer
    150              // enable the MCU nRST external reset
    151              AT91C_BASE_RSTC->RSTC_RMR= 0xA5000F01; 
   \   0000004A   5048               LDR.N    R0,??main_0+0x14  ;; 0x400e1208
   \   0000004C   5049               LDR.N    R1,??main_0+0x18  ;; 0xa5000f01
   \   0000004E   0160               STR      R1,[R0, #+0]
    152              
    153              // Initialize processor for selected interface to HI-613X device,
    154              // either parallel bus interface (HI-6130) or SPI interface (HI-6131)
    155              #if (HOST_BUS_INTERFACE)
    156                  Configure_ARM_MCU_ExtBus();
   \   00000050   ........           BL       Configure_ARM_MCU_ExtBus
    157          	
    158              #else  // HOST SPI INTERFACE
    159          	Configure_ARM_MCU_SPI();        
    160              #endif
    161          
    162              #if (CONSOLE_IO)
    163                  ConfigureUsart1();
   \   00000054   ........           BL       ConfigureUsart1
    164                  printf("\n\n\n\n\n\n\r Holt Integrated Circuits HI-6130/31 Project \n\r");
   \   00000058   4E48               LDR.N    R0,??main_0+0x1C
   \   0000005A   ........           BL       printf
    165                  printf(" Ver: 1.3     Compiled: %s %s    ", __DATE__, __TIME__ );
   \   0000005E   4E4A               LDR.N    R2,??main_0+0x20
   \   00000060   4E49               LDR.N    R1,??main_0+0x24
   \   00000062   4F48               LDR.N    R0,??main_0+0x28
   \   00000064   ........           BL       printf
    166              #endif
    167          
    168              // Anywhere from 0 to 4 terminals might be enabled by the 4 DIP switches on
    169              // the evaluation board. Next function call checks states for BC, RT1, RT2,
    170              // and MT DIP switches. For each switch = 1 (terminal enabled) the function
    171              // verifies that the corresponding compiler run-time switch is also ON. For
    172              // example: if BCENA DIP switch = 1 then BC_ENA (in file 613x_initialization.h)
    173              // must be defined ON (non-zero). Error trap occurs (flashing the red LED) if:
    174              //
    175              //  * one or more terminals has switch = 1 but compiler run-time switch defined OFF 
    176              //  * one or more terminals has switch = 0 but compiler run-time switch defined ON
    177              //  * all 4 DIP switches = 0, nothing is enabled
    178              // 
    179              // If error-free, function writes terminal enable bits into the Master Configuration 
    180              // register, then returns a 16-bit word having a run bit set for each enabled
    181              // DIP switch, used later to start terminal operation after initialization.
    182                  
    183              // program writes these bits to the Master Configuration register later...
    184              runbits = enable_check();
   \   00000068   ........           BL       enable_check
   \   0000006C   0600               MOVS     R6,R0
    185                  
    186              // Next function call uses an in-line delay. This affects completion time for hard reset 
    187              // (ARM microprocessor power-up reset (POR), or assertion of the board's RESET button. 
    188              // This delay does not affect time for "HI-613x only" hard reset, or HI-613x soft reset.
    189          
    190              //  flash an LED to indicate how initialization will proceed: 
    191              if(PIO_Get(&pinAUTOEN)){
   \   0000006E   18A8               ADD      R0,SP,#+96
   \   00000070   ........           BL       PIO_Get
   \   00000074   0028               CMP      R0,#+0
   \   00000076   05D0               BEQ.N    ??main_1
    192                 // AUTOEN == 1 (self init from EEPROM)
    193                 #if (CONSOLE_IO)
    194                    printf("\n\n\r       Auto-Initializing from EEPROM  \n\n\r");
   \   00000078   4A48               LDR.N    R0,??main_0+0x2C
   \   0000007A   ........           BL       printf
    195                 #endif
    196                 Flash_Red_LED();
   \   0000007E   ........           BL       Flash_Red_LED
   \   00000082   04E0               B.N      ??main_2
    197              }    
    198              else {   
    199                 // AUTOEN == 0 (host initialization)
    200                 #if (CONSOLE_IO)
    201                    printf("\n\n\r       Host is Initializing Regs & RAM \n\n\r");
   \                     ??main_1:
   \   00000084   4848               LDR.N    R0,??main_0+0x30
   \   00000086   ........           BL       printf
    202                 #endif
    203                 Flash_Green_LED();
   \   0000008A   ........           BL       Flash_Green_LED
    204              }
    205                  
    206              // Next actions are determined by states of the AUTOEN (auto-initialize) 
    207              // DIP switch and EECOPY Request DIP switch (labeled "COPYRQ"). AUTOEN is a 
    208              // HI-613x input, COPYRQ is a microprocessor input. The two switches COPYRQ and 
    209              // AUTOEN should never both be high (There is no point in auto-initializing the
    210              // HI-613x from EEPROM then copying the just-initialized setup to EEPROM again!) 
    211          
    212              //           D I P    S W I T C H    S E T T I N G    T A B L E
    213              //  ------------------------------------------------------------------------		
    214              //            |      AUTOEN = 0         |          AUTOEN = 1
    215              //  ----------|-------------------------|-----------------------------------
    216              //    COPYRQ  | Host initializes 613x   |   EEPROM initializes 613x
    217              //     = 0    | No EEPROM involvement   |   No Host involvement
    218              //            | Normal host initialize  |   Normal auto-initialize sequence
    219              //  ----------|-------------------------|-----------------------------------
    220              //    COPYRQ  | Host initializes 613x   |   EEPROM initializes 613x
    221              //      = 1   | then EECOPY to EEPROM   |   then EECOPY to EEPROM 
    222              //            | (Normal EEPROM copy)    |   (Senseless sequence)
    223              //	------------------------------------------------------------------------
    224          		
    225              // Reset HI-613x. If device AUTOEN pin is high, it will auto-initialize
    226              // the device registers and RAM from serial EEPROM. In this case, execution
    227              // comes back here only after the HI-613x READY output goes high...
    228              reset_613x();
   \                     ??main_2:
   \   0000008E   ........           BL       reset_613x
    229          
    230              // If error-free auto-init occurred after master reset, next function call 
    231              // returns "0". if auto-initialize occurred with errors, the function call 
    232              // does NOT return (local error trap). If auto-initialize was not enabled,
    233              // this program initializes device RAM and registers below.
    234          	
    235              // Although possible to do so, "intialize from EEPROM" process in this program 
    236              // does not automatically start execution for terminal devices. Instead,
    237              // whether auto-init or host init, the program simulaneously starts execution for 
    238              // all enabled devices (BC,MT,RT1,RT2) when "runbits" are written into the Master
    239              // Configuration register below...          
    240                         
    241              if(autoinit_check()) {
   \   00000092   ........           BL       autoinit_check
   \   00000096   0028               CMP      R0,#+0
   \   00000098   4FD0               BEQ.N    ??main_3
    242          
    243                  // if function call above returned with non-zero result, the terminal was 
    244                  // NOT automatically initialized after reset, BUT numerous registers now
    245                  // contain non-zero default values. The host will now initialize...
    246                
    247                  // having met enable_check() requirements above, write the terminal 
    248                  // enable bits for BC or RT(s) into the Master Config register 0. (The
    249                  // MT has only a run bit, not an enable bit.)
    250                  #if (HOST_BUS_INTERFACE)
    251                  pH6130->MASTER_CONFIG_REG = runbits & (BCENA|RT1ENA|RT2ENA);
   \   0000009A   16F48650           ANDS     R0,R6,#0x10C0
   \   0000009E   4349               LDR.N    R1,??main_0+0x34
   \   000000A0   0968               LDR      R1,[R1, #+0]
   \   000000A2   0880               STRH     R0,[R1, #+0]
    252                  
    253                  #else  // HOST SPI INTERFACE
    254                  j = runbits & (BCENA|RT1ENA|RT2ENA);
    255          	Write_6131LowReg(MASTER_CONFIG_REG, j, 1);
    256                  #endif
    257          
    258                  // modify runbits to just contain "start execution" bits, to be written last
    259                  runbits &= ~(BCENA|RT1ENA|RT2ENA);
   \   000000A4   4EF63F70           MOVW     R0,#+61247
   \   000000A8   0640               ANDS     R6,R0,R6
    260                      
    261                  // Select common configuration options that apply to all BC, MT, RT1, RT2. 
    262                  initialize_613x_shared();
   \   000000AA   ........           BL       initialize_613x_shared
    263                  
    264                  // Terminal-specific options are initialized next... 
    265                  // Below, variable "ttconfig" is used for time tag counter configuration. 
    266          	// If enabled, the MT has a dedicated 16-bit or 48-bit time counter.
    267          	// MT time tag resolution is selected by MT Configuration Reg, bit 0. 
    268          	// We select the MT counter clock source below, factored into "ttconfig".
    269          		
    270          	// The BC,RT1 and RT2 have independent time tag counters, but share 
    271          	// a common clock source, selected below, factored into "ttconfig". The RT1 
    272          	// and RT2 time counters are always 16-bit. The BC time counter is
    273          	// either 16- or 32-bit, selected below.        
    274                    
    275                  //------------------------------------------------------------------------
    276                  
    277                  #if(BC_ena)
    278          
    279          	    initialize_613x_BC();
   \   000000AE   ........           BL       initialize_613x_BC
    280                      initialize_bc_msg_blocks();
   \   000000B2   ........           BL       initialize_bc_msg_blocks
    281          	    initialize_bc_instruction_list();
   \   000000B6   ........           BL       initialize_bc_instruction_list
    282          
    283                      // select BC time tag resolution, either 16-bit or 32-bit (BTTAG16 or BTTAG32)
    284                      
    285                      #ifdef BC_TTAG_HI_RES
    286                          ttconfig |= BTTAG32;
   \   000000BA   55F00805           ORRS     R5,R5,#0x8
    287                      #else
    288                          ttconfig |= BTTAG16;
    289                      #endif
    290          
    291                      // Select internally-generated time tag clock used by BC,RT1 and RT2
    292                      // Choices are 2U,4U,8U,16U,32U or 64U (microseconds)
    293                      ttconfig |= TTAG_64U;
   \   000000BE   55F00705           ORRS     R5,R5,#0x7
    294          
    295                  #endif	// end BC init. 
    296          
    297                  //------------------------------------------------------------------------
    298          
    299                  #if(RT1_ena)
    300          	    // verify RT1 Op Status Reg shows a valid RT address. This function call
    301          	    // does not return if register reflects address parity error or if the
    302          	    // register reads back zero value, an invalid result (local error trap)
    303                      
    304          	    if (RTAddr_okay(1)) {
   \   000000C2   0120               MOVS     R0,#+1
   \   000000C4   ........           BL       RTAddr_okay
   \   000000C8   0028               CMP      R0,#+0
   \   000000CA   08D0               BEQ.N    ??main_4
    305                     
    306                          // host now initializes HI-613x regs, RAM tables, for RT1 
    307                          initialize_613x_RT1();				
   \   000000CC   ........           BL       initialize_613x_RT1
    308                          
    309          	        // write test data to assigned transmit buffers
    310          	        write_dummy_tx_data_RT1();
   \   000000D0   ........           BL       write_dummy_tx_data_RT1
    311                          
    312          	        // RT1 and RT2 always use 16-bit time tag resolution.
    313                          // if not already selected above for BC, (i.e. if BC is not used), 
    314                          // select RT1 and RT2 time tag clock which otherwise is shared with BC.
    315                          // Choices are 2U,4U,8U,16U,32U or 64U (microseconds)
    316          	        if(!ttconfig) ttconfig = TTAG_64U;
   \   000000D4   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000D6   002D               CMP      R5,#+0
   \   000000D8   01D1               BNE.N    ??main_4
   \   000000DA   0720               MOVS     R0,#+7
   \   000000DC   0500               MOVS     R5,R0
    317                      }			
    318                   
    319                  #endif    // end RT1 init. RT1 does not start until the RT1STEX register bit is set
    320          
    321                  //------------------------------------------------------------------------
    322          
    323                  #if(RT2_ena)
    324          
    325          	    // verify RT2 Op Status Reg shows a valid RT address. This function call
    326          	    // does not return if register reflects address parity error or if the
    327          	    // register reads back zero value, an invalid result (local error trap)
    328          	    if (RTAddr_okay(2)) {
   \                     ??main_4:
   \   000000DE   0220               MOVS     R0,#+2
   \   000000E0   ........           BL       RTAddr_okay
   \   000000E4   0028               CMP      R0,#+0
   \   000000E6   08D0               BEQ.N    ??main_5
    329                     
    330                          // host now initializes HI-613x regs, RAM tables, for RT2
    331                          initialize_613x_RT2();				
   \   000000E8   ........           BL       initialize_613x_RT2
    332          
    333          	        // write test data to assigned transmit buffers
    334          	        write_dummy_tx_data_RT2();
   \   000000EC   ........           BL       write_dummy_tx_data_RT2
    335          				
    336          	        // RT1 and RT2 always use 16-bit time tag resolution.
    337          	        // if not already selected above for BC or RT1, (i.e. if BC & RT1 not used), 
    338                          // select RT2 time tag clock which otherwise is shared with BC and RT1.
    339                          // Choices are 2U,4U,8U,16U,32U or 64U (microseconds)
    340          	        if(!ttconfig) ttconfig = TTAG_64U;
   \   000000F0   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000F2   002D               CMP      R5,#+0
   \   000000F4   01D1               BNE.N    ??main_5
   \   000000F6   0720               MOVS     R0,#+7
   \   000000F8   0500               MOVS     R5,R0
    341                     }			
    342                   
    343                  #endif    // end RT2 init. RT2 does not start until the RT2STEX register bit is set
    344          
    345                  //------------------------------------------------------------------------
    346               
    347                  #if(SMT_ena||IMT_ena)
    348          
    349                      // Host now initializes Simple Monitor or IRIG-106 Bus Monitor, as selected in 
    350                      // file 613x_initialization.h. Next call traps error if MTRUN pin disables MT.
    351                      initialize_613x_MT();				
   \                     ??main_5:
   \   000000FA   ........           BL       initialize_613x_MT
    352          
    353                      // dedicated MT time tag clock selection:
    354          
    355                      #if(IMT_ena) 
    356                          // IRIG-106 monitor (IMT) always uses 48-bit time tag resolution.
    357                          // two IRIG-106 monitor time tag clock options: MTTAG_OFF or MTTAG_100N (100ns)
    358                          // "OFF" is helpful in debug, to prevent "maximum packet time" end-of-packet.
    359                          j = MTTAG_OFF; // MTTAG_100N;
    360                          ttconfig |= j;
    361          
    362                      #else 
    363          	        // SMT simple monitor time tag clock options: MTTAG_OFF, MTTAG_100N (100ns)
    364                          // or MTTAG_2U,4U,8U,16U,32U or 64U (microseconds)
    365                	        ttconfig |= MTTAG_64U;
   \   000000FE   55F07005           ORRS     R5,R5,#0x70
    366                          
    367                          // SMT can use 16-bit or 48-bit time tag resolution, selected in
    368                          // the MT Configuration register...
    369          
    370                          #ifdef SMT_TTAG_HI_RES
    371                              j = SMT_TTAG48;
   \   00000102   0220               MOVS     R0,#+2
   \   00000104   0400               MOVS     R4,R0
    372                          #else
    373                              j= SMT_TTAG16;
    374                          #endif
    375          
    376                          // read-modify-write the MT Configuration Register
    377                          #if (HOST_BUS_INTERFACE) 
    378                          pH6130->MT_CONFIG_REG |= j;              
   \   00000106   2948               LDR.N    R0,??main_0+0x34
   \   00000108   0068               LDR      R0,[R0, #+0]
   \   0000010A   B0F85200           LDRH     R0,[R0, #+82]
   \   0000010E   2043               ORRS     R0,R4,R0
   \   00000110   2649               LDR.N    R1,??main_0+0x34
   \   00000112   0968               LDR      R1,[R1, #+0]
   \   00000114   A1F85200           STRH     R0,[R1, #+82]
    379          
    380                          #else // HOST_SPI_INTERFACE
    381                          j |= Read_6131LowReg(MT_CONFIG_REG, 1);
    382                          Write_6131LowReg(MT_CONFIG_REG, j , 1);
    383                          #endif                    
    384                                                  
    385                      #endif
    386          						
    387                  #endif	// end MT init. Monitor does not start until MTENA register bit is set below
    388                   
    389                  //------------------------------------------------------------------------
    390                  
    391                  // write the Time Tag Configuration Register
    392                  #if (HOST_BUS_INTERFACE) 
    393                  pH6130->TTAG_CONFIG_REG = ttconfig;              
   \   00000118   2448               LDR.N    R0,??main_0+0x34
   \   0000011A   0068               LDR      R0,[R0, #+0]
   \   0000011C   A0F87250           STRH     R5,[R0, #+114]
    394          
    395                  #else // HOST_SPI_INTERFACE
    396                  Write_6131LowReg(TTAG_CONFIG_REG, ttconfig, 0);
    397                  #endif
    398          
    399          	if (PIO_Get(&pinCOPYREQ)) {
   \   00000120   10A8               ADD      R0,SP,#+64
   \   00000122   ........           BL       PIO_Get
   \   00000126   0028               CMP      R0,#+0
   \   00000128   07D0               BEQ.N    ??main_3
    400                      // "COPY REQUEST" DIP switch is high. Write serial EEPROM using parameter 0 
    401          	    // so the various start bits in the Master Configuraton Register are 
    402                      // NOT automatically set by subsequent auto-initialization cycles.
    403                     #if (CONSOLE_IO)
    404                          printf("       Copying Registers & RAM to EEPROM  \n\r");                       
   \   0000012A   2148               LDR.N    R0,??main_0+0x38
   \   0000012C   ........           BL       printf
    405                          printf("    Be sure to turn off COPYREQ DIP switch. \n\n\r");                       
   \   00000130   2048               LDR.N    R0,??main_0+0x3C
   \   00000132   ........           BL       printf
    406                      #endif
    407          	    write_init_eeprom();
   \   00000136   ........           BL       write_init_eeprom
    408                  }
    409                    
    410              }   // end:if (autoinit_check())
    411                      
    412              // flash both green bus LEDs to signify initialization complete
    413              AT91C_BASE_PIOC->PIO_CODR = nLEDA|nLEDB;  // LEDs ON
   \                     ??main_3:
   \   0000013A   1348               LDR.N    R0,??main_0+0x10  ;; 0x400e1034
   \   0000013C   5FF04041           MOVS     R1,#-1073741824
   \   00000140   0160               STR      R1,[R0, #+0]
    414              Delay_x100ms(3);
   \   00000142   0320               MOVS     R0,#+3
   \   00000144   ........           BL       Delay_x100ms
    415              AT91C_BASE_PIOC->PIO_SODR = nLEDA|nLEDB;  // LEDs OFF
   \   00000148   1B48               LDR.N    R0,??main_0+0x40  ;; 0x400e1030
   \   0000014A   5FF04041           MOVS     R1,#-1073741824
   \   0000014E   0160               STR      R1,[R0, #+0]
    416                  
    417              // we disabled interrupts during initialization, 
    418              // now enable them before starting terminal execution
    419              __enable_interrupt();
   \   00000150   62B6               CPSIE    I
    420              
    421              // write the Master Configuraton Register to start the
    422              // terminal(s) initialized above, to begin operation.
    423              // do not overwrite previously initialized common features
    424              #if (HOST_BUS_INTERFACE)         
    425          	pH6130->MASTER_CONFIG_REG |= runbits;         
   \   00000152   1648               LDR.N    R0,??main_0+0x34
   \   00000154   0068               LDR      R0,[R0, #+0]
   \   00000156   0088               LDRH     R0,[R0, #+0]
   \   00000158   3043               ORRS     R0,R6,R0
   \   0000015A   1449               LDR.N    R1,??main_0+0x34
   \   0000015C   0968               LDR      R1,[R1, #+0]
   \   0000015E   0880               STRH     R0,[R1, #+0]
    426          
    427              #else //  HOST_SPI_INTERFACE        
    428          	spi_busy = 0;
    429          	spi_irq = 0;
    430          	j = runbits | Read_6131LowReg(MASTER_CONFIG_REG, 1);
    431          	Write_6131LowReg(MASTER_CONFIG_REG, j, 1);      
    432              #endif
    433                  
    434                #if (CONSOLE_IO)
    435                    show_menu();
   \   00000160   ........           BL       show_menu
    436                    // Infinite loop
    437                    while (1) {
    438                        // poll USART1 to detect and act on console key input at computer keyboard...
    439                        chk_key_input();
   \                     ??main_6:
   \   00000164   ........           BL       chk_key_input
    440                        
    441                        #if(RT1_ena||RT2_ena)
    442                            // if MCU board SW1 button is pressed, update RT1 and RT2 status bits
    443                            // based on Terminal Flag and Busy DIP switch settings
    444                            if(!PIO_Get(&pinNSW1)) modify_RT_status_bits();
   \   00000168   00A8               ADD      R0,SP,#+0
   \   0000016A   ........           BL       PIO_Get
   \   0000016E   0028               CMP      R0,#+0
   \   00000170   F8D1               BNE.N    ??main_6
   \   00000172   ........           BL       modify_RT_status_bits
   \   00000176   F5E7               B.N      ??main_6
   \                     ??main_0:
   \   00000178   ........           DC32     `?<Constant {16, (AT91S_PIO *)1074662912, 11, 2`
   \   0000017C   ........           DC32     `?<Constant {8, (AT91S_PIO *)1074662912, 11, 2}`
   \   00000180   ........           DC32     `?<Constant {33554432, (AT91S_PIO *)1074663424,`
   \   00000184   ........           DC32     `?<Constant {131072, (AT91S_PIO *)1074662912, 1`
   \   00000188   34100E40           DC32     0x400e1034
   \   0000018C   08120E40           DC32     0x400e1208
   \   00000190   010F00A5           DC32     0xa5000f01
   \   00000194   ........           DC32     `?<Constant "\\n\\n\\n\\n\\n\\n\\r Holt Integrat...">`
   \   00000198   ........           DC32     `?<Constant "09:55:11">`
   \   0000019C   ........           DC32     `?<Constant "May 17 2012">`
   \   000001A0   ........           DC32     `?<Constant " Ver: 1.3     Compile...">`
   \   000001A4   ........           DC32     `?<Constant "\\n\\n\\r       Auto-Initia...">`
   \   000001A8   ........           DC32     `?<Constant "\\n\\n\\r       Host is Ini...">`
   \   000001AC   ........           DC32     pH6130
   \   000001B0   ........           DC32     `?<Constant "       Copying Regist...">`
   \   000001B4   ........           DC32     `?<Constant "    Be sure to turn o...">`
   \   000001B8   30100E40           DC32     0x400e1030
    445                        #endif
    446          
    447                    }   // end while 
    448                    
    449                    
    450                #else // not using console IO...
    451                    // Infinite loop
    452                    while (1) {
    453                        #if(BC_ena)
    454                            bc_switch_tests();
    455                        #endif // BC_ena
    456                            
    457                        #if(RT1_ena||RT2_ena)
    458                            // if MCU board SW1 button is pressed, update RT1 and RT2 status bits
    459                            // based on Terminal Flag and Busy DIP switch settings
    460                            if(!PIO_Get(&pinNSW1)) modify_RT_status_bits();
    461                        #endif
    462                            
    463                    }   // end while
    464          
    465                #endif
    466             
    467          }     // end main()

   \                                 In section .rodata, align 4
   \                     `?<Constant {16, (AT91S_PIO *)1074662912, 11, 2`:
   \   00000000   10000000000E       DC32 16, 400E0E00H
   \              0E40        
   \   00000008   0B0200000000       DC8 11, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \   0000001A   000000000000       DC8 0, 0, 0, 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant {8, (AT91S_PIO *)1074662912, 11, 2}`:
   \   00000000   08000000000E       DC32 8, 400E0E00H
   \              0E40        
   \   00000008   0B0200000000       DC8 11, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \   0000001A   000000000000       DC8 0, 0, 0, 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant {33554432, (AT91S_PIO *)1074663424,`:
   \   00000000   000000020010       DC32 33554432, 400E1000H
   \              0E40        
   \   00000008   0C0300000000       DC8 12, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   0000001B   0000000000         DC8 0, 0, 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant {131072, (AT91S_PIO *)1074662912, 1`:
   \   00000000   00000200000E       DC32 131072, 400E0E00H
   \              0E40        
   \   00000008   0B0202000000       DC8 11, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   0000001B   0000000000         DC8 0, 0, 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\n\\n\\n\\n\\n\\r Holt Integrat...">`:
   \   00000000   0A0A0A0A0A0A       DC8 0AH, 0AH, 0AH, 0AH, 0AH, 0AH, 0DH, 20H
   \              0D20        
   \   00000008   486F6C742049       DC8 48H, 6FH, 6CH, 74H, 20H, 49H, 6EH, 74H
   \              6E74        
   \   00000010   656772617465       DC8 65H, 67H, 72H, 61H, 74H, 65H, 64H, 20H
   \              6420        
   \   00000018   436972637569       DC8 43H, 69H, 72H, 63H, 75H, 69H, 74H, 73H
   \              7473        
   \   00000020   2048492D3631       DC8 20H, 48H, 49H, 2DH, 36H, 31H, 33H, 30H
   \              3330        
   \   00000028   2F3331205072       DC8 2FH, 33H, 31H, 20H, 50H, 72H, 6FH, 6AH
   \              6F6A        
   \   00000030   656374200A0D       DC8 65H, 63H, 74H, 20H, 0AH, 0DH, 0
   \              00          
   \   00000037   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant " Ver: 1.3     Compile...">`:
   \   00000000   205665723A20       DC8 " Ver: 1.3     Compiled: %s %s    "
   \              312E33202020
   \              2020436F6D70
   \              696C65643A20
   \              257320257320
   \              20202000    
   \   00000022   0000               DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "May 17 2012">`:
   \   00000000   4D6179203137       DC8 "May 17 2012"
   \              203230313200

   \                                 In section .rodata, align 4
   \                     `?<Constant "09:55:11">`:
   \   00000000   30393A35353A       DC8 "09:55:11"
   \              313100      
   \   00000009   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\n\\r       Auto-Initia...">`:
   \   00000000   0A0A0D202020       DC8 "\012\012\015       Auto-Initializing from EEPROM  \012\012\015"
   \              202020204175
   \              746F2D496E69
   \              7469616C697A
   \              696E67206672
   \              6F6D20454550
   \              524F4D20200A
   \              0A0D00      
   \   0000002D   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\n\\r       Host is Ini...">`:
   \   00000000   0A0A0D202020       DC8 "\012\012\015       Host is Initializing Regs & RAM \012\012\015"
   \              20202020486F
   \              737420697320
   \              496E69746961
   \              6C697A696E67
   \              205265677320
   \              262052414D20
   \              0A0A0D00    
   \   0000002E   0000               DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "       Copying Regist...">`:
   \   00000000   202020202020       DC8 "       Copying Registers & RAM to EEPROM  \012\015"
   \              20436F707969
   \              6E6720526567
   \              697374657273
   \              20262052414D
   \              20746F204545
   \              50524F4D2020
   \              0A0D00      
   \   0000002D   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "    Be sure to turn o...">`:
   \   00000000   202020204265       DC8 "    Be sure to turn off COPYREQ DIP switch. \012\012\015"
   \              207375726520
   \              746F20747572
   \              6E206F666620
   \              434F50595245
   \              512044495020
   \              737769746368
   \              2E200A0A0D00
    468          
    469          
    470          // end of file
    471          

   Maximum stack usage in bytes:

     Function .cstack
     -------- -------
     main        144


   Section sizes:

     Function/Label                                 Bytes
     --------------                                 -----
     pH6130                                            4
     pRT1d                                             4
     pRT1i                                             4
     pRT2d                                             4
     pRT2i                                             4
     pGPQ                                              4
     pBCil                                             4
     pBCstack                                          4
     pBCstack2RT                                       4
     pDSTK                                             4
     pScSTK                                            4
     pMTF                                              4
     pAddrList                                         4
     main                                            444
     ?<Constant {16, (AT91S_PIO *)1074662912, 11, 2   32
     ?<Constant {8, (AT91S_PIO *)1074662912, 11, 2}   32
     ?<Constant {33554432, (AT91S_PIO *)1074663424,   32
     ?<Constant {131072, (AT91S_PIO *)1074662912, 1   32
     ?<Constant "\n\n\n\n\n\n\r Holt Integrat...">    56
     ?<Constant " Ver: 1.3     Compile...">           36
     ?<Constant "May 17 2012">                        12
     ?<Constant "09:55:11">                           12
     ?<Constant "\n\n\r       Auto-Initia...">        48
     ?<Constant "\n\n\r       Host is Ini...">        48
     ?<Constant "       Copying Regist...">           48
     ?<Constant "    Be sure to turn o...">           48

 
   8 bytes in section .data
 480 bytes in section .rodata
 444 bytes in section .text
 
 444 bytes of CODE  memory
 480 bytes of CONST memory
   8 bytes of DATA  memory

Errors: none
Warnings: none
