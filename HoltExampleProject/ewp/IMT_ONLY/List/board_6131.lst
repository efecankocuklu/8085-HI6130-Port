###############################################################################
#                                                                             #
#                                                       22/May/2012  13:43:40 #
# IAR ANSI C/C++ Compiler V6.21.1.32794/W32 KICKSTART for ARM                 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Program Files\IAR Systems\Embedded Workbench 6.0      #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 1_0\board_6131.c                     #
#    Command line =  "C:\Program Files\IAR Systems\Embedded Workbench 6.0     #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 1_0\board_6131.c" -D at91sam3u4 -D   #
#                    flash -D TRACE_LEVEL=4 -D BC_ena=0 -D RT2_ena=0 -D       #
#                    RT1_ena=0 -D SMT_ena=0 -D IMT_ena=1 -lC "C:\Program      #
#                    Files\IAR Systems\Embedded Workbench 6.0                 #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 1_0\ewp\IMT_ONLY\List\" --remarks    #
#                    --diag_suppress Pe826,Pe1375,Pe068 -o "C:\Program        #
#                    Files\IAR Systems\Embedded Workbench 6.0                 #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 1_0\ewp\IMT_ONLY\Obj\" --no_cse      #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench 6.0                 #
#                    Kickstart_2\arm\INC\c\DLib_Config_Full.h" -I             #
#                    "C:\Program Files\IAR Systems\Embedded Workbench 6.0     #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 1_0\ewp\..\..\..\at91lib/peripherals #
#                    \" -I "C:\Program Files\IAR Systems\Embedded Workbench   #
#                    6.0 Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt    #
#                    HI-6130-40 EBI Demo 1_0\ewp\..\..\..\at91lib/components\ #
#                    " -I "C:\Program Files\IAR Systems\Embedded Workbench    #
#                    6.0 Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt    #
#                    HI-6130-40 EBI Demo 1_0\ewp\..\..\..\at91lib\" -I        #
#                    "C:\Program Files\IAR Systems\Embedded Workbench 6.0     #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 1_0\ewp\..\..\..\external_libs\" -I  #
#                    "C:\Program Files\IAR Systems\Embedded Workbench 6.0     #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 1_0\ewp\..\..\..\at91lib/boards/at91 #
#                    sam3u-ek\" --cpu_mode thumb -On --use_c++_inline         #
#    List file    =  C:\Program Files\IAR Systems\Embedded Workbench 6.0      #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 1_0\ewp\IMT_ONLY\List\board_6131.lst #
#    Object file  =  C:\Program Files\IAR Systems\Embedded Workbench 6.0      #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 1_0\ewp\IMT_ONLY\Obj\board_6131.o    #
#                                                                             #
#                                                                             #
###############################################################################

C:\Program Files\IAR Systems\Embedded Workbench 6.0 Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt HI-6130-40 EBI Demo 1_0\board_6131.c
      1          
      2          //
      3          //  file	board_6131.c
      4          //  brief	This file contains routines for the Atmel AT91SAM3U4 processor's
      5          // 		SPI (specifically SPI0) peripheral, operating as SPI Master. The 
      6          //		Holt HI-6131 acts as SPI slave device. File contains initialization
      7          //		functions, as well as example functions that utilize HI-6131 SPI 
      8          //		op codes to read/write HI-6131 registers and RAM. If using a 
      9          //		different microprocessor, translate the hardware control sequences 
     10          //		to match the hardware used, but most microprocessor SPI peripherals 
     11          //		operate similiarly. 
     12          //
     13          //
     14          //		IMPORTANT: Edit file 613x_initialization.h to define either:
     15          //
     16          //		HOST_BUS-INTERFACE  YES  sets compilation for HI-6130 (bus)
     17          //				    NO   sets compilation for HI-6131 (SPI)
     18          //
     19          //		This file compiles only when HOST_BUS_INTERFACE == NO for HI-6131
     20          //
     21          //		 
     22          //		HOLT DISCLAIMER
     23          //
     24          //		THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     25          //		EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
     26          //		OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
     27          //		NONINFRINGEMENT. 
     28          //		IN NO EVENT SHALL HOLT, INC BE LIABLE FOR ANY CLAIM, DAMAGES
     29          //		OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
     30          //		OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
     31          //		SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     32          //
     33          //		Copyright (C) 2009-2011 by  HOLT, Inc.
     34          //		All Rights Reserved.
     35          //
     36          //
     37          //	LIST OF FUNCTIONS
     38          //	Direct-Addressed Read/Write Operations
     39          // 	======================================
     40          //	Write_6131LowReg( ) writes word to single register, registers 0 - 63 only
     41          //	Read_6131LowReg( ) reads word from single register, registers 0 - 15 only
     42          //
     43          //	Read/write Operations Using the Memory Address Pointer
     44          //	======================================================
     45          //	Write_6131_1word( ) writes word to a single register or RAM location
     46          //	Read_6131_1word( ) reads word from a single register or RAM location
     47          //
     48          //	Write_6131( ) writes N words to sequential register or RAM locations
     49          //	Read_6131( ) reads N words from sequential register or RAM locations
     50          //
     51          //	these modify mem addr pointer relative to its current value, then perform read or write...
     52          //	Write_6131_Buffer( ) writes N words to sequential register or RAM locations
     53          //	Read_6131_Buffer( ) reads N words from sequential register or RAM locations
     54          //
     55          //	Read_Current_Control_Word( ) returns descriptor Control Word for the current/last command
     56          //	Read_This_Control_Word() returns a specified descriptor Control Word
     57          //	ReadWord_Adv4( ) returns data addressed by Memory Address Pointer, then adds 4 to ptr
     58          //	Read_Last_IIW( ) returns the last Interrupt Information Word written to log buffer
     59          //	Increase_Mem_Ptr( ) adds 1,2, or 4 to current Memory Address Pointer value in reg 15
     60          //
     61          //	Special Complex Functions
     62          //	=========================
     63          //	Fill_6131RAM_Offset( ) writes each RAM address with its address/offset value
     64          //	Fill_6131RAM( ) writes a specified range of addresses with a fixed value
     65          //	mem_dump( ) copies a 256-word block from HI-6131 reg/RAM to processor internal RAM
     66          //	spi_demo( ) demonstrates various SPI function calls
     67          //
     68          
     69          
     70          //------------------------------------------------------------------------------
     71          //         Headers
     72          //------------------------------------------------------------------------------
     73          #include <pio/pio.h>
     74          #include <spi/spi.h>
     75          #include <intrinsics.h>
     76          #include "613x_initialization.h"
     77          #include "board_6131.h"
     78          #include "device_6131.h"
     79          #include <stdio.h>
     80          
     81          //------------------------------------------------------------------------------
     82          //         Defines
     83          //------------------------------------------------------------------------------
     84          
     85          // none  
     86          
     87          //------------------------------------------------------------------------------
     88          //         Local variables
     89          //------------------------------------------------------------------------------
     90          
     91          // Pins used by SPI

   \                                 In section .rodata, align 4
     92          static const Pin pinsSPI[]  = {BOARD_6131_SPI_PINS, BOARD_6131_NPCS_PIN};
   \                     pinsSPI:
   \   00000000   00200000000C       DC32 8192, 400E0C00H
   \              0E40        
   \   00000008   0A0000000000       DC8 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   0000001B   0000000000         DC8 0, 0, 0, 0, 0
   \   00000020   00400000000C       DC32 16384, 400E0C00H
   \              0E40        
   \   00000028   0A0000000000       DC8 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   0000003B   0000000000         DC8 0, 0, 0, 0, 0
   \   00000040   00800000000C       DC32 32768, 400E0C00H
   \              0E40        
   \   00000048   0A0000000000       DC8 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   0000005B   0000000000         DC8 0, 0, 0, 0, 0
   \   00000060   00000100000C       DC32 65536, 400E0C00H
   \              0E40        
   \   00000068   0A0301000000       DC8 10, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   0000007B   0000000000         DC8 0, 0, 0, 0, 0
     93          
     94          // HI-6131 /CS pin
     95          //static const Pin pinNss[]  = {BOARD_6131_NPCS_PIN};
     96          
     97          //------------------------------------------------------------------------------
     98          //         Global Variables
     99          //------------------------------------------------------------------------------
    100          
    101          

   \                                 In section .bss, align 1
    102          unsigned char spi_busy, spi_irq;
   \                     spi_busy:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     spi_irq:
   \   00000000                      DS8 1
    103          
    104          //	Array for storing 16-bit words read from HI-6131 RAM or registers. Several functions 
    105          //	below read data from one or more sequential addresses. The reserved array size in 
    106          //	this declaration can be adjusted to match project requirements. 

   \                                 In section .bss, align 4
    107          unsigned short read_data[256]; 
   \                     read_data:
   \   00000000                      DS8 512
    108          
    109          //------------------------------------------------------------------------------
    110          //         Functions
    111          //------------------------------------------------------------------------------
    112          
    113          
    114          //	This function transmits the parameter 8-bit op code of the type that 
    115          //      does not read or write following data word(s):
    116          //
    117          //      Op Code     Action
    118          //       0xD8       Enable Memory Address Pointer 1 (MAP1) reg address 0x000B
    119          //       0xD9       Enable Memory Address Pointer 2 (MAP2) reg address 0x000C
    120          //       0xDA       Enable Memory Address Pointer 3 (MAP3) reg address 0x000D
    121          //       0xDB       Enable Memory Address Pointer 4 (MAP4) reg address 0x000E
    122          //       0xD0       Add 1 to currently-enabled Memory Address Pointer value
    123          //       0xD2       Add 2 to currently-enabled Memory Address Pointer value
    124          //       0xD4       Add 4 to currently-enabled Memory Address Pointer value
    125          //
    126          //      Any other op code value will give unpredictable results. The op code
    127          //      is transmited a byte at a time. The data characters received during 
    128          //      op code transmission are discarded.
    129          //
    130          //		The MCU's SPI mode register is written with option WDRBT = 0 so Master
    131          //		can initialize a new transfer whether/not SPI RxData register has unread
    132          //		data. To speed up SPI operations by taking advantnage of the WDRBT
    133          //		option, several statements are commented-out in the function below.
    134          //

   \                                 In section .text, align 2, keep-with-next
    135          void SPIopcode( unsigned char opcode)  {
   \                     SPIopcode:
   \   00000000   10B4               PUSH     {R4}
    136                  
    137              AT91S_SPI *spi = BOARD_6131_SPI_BASE;
   \   00000002   ........           LDR.W    R1,??DataTable12  ;; 0x40008000
    138              unsigned short dummy;
    139                  
    140              __disable_interrupt();	 
   \   00000006   72B6               CPSID    I
    141              // Assert SPI chip select
    142              AT91C_BASE_PIOA->PIO_CODR = SPI_nCS; // faster than PIO_Clear(pinNss);
   \   00000008   ........           LDR.W    R3,??DataTable12_1  ;; 0x400e0c34
   \   0000000C   5FF48034           MOVS     R4,#+65536
   \   00000010   1C60               STR      R4,[R3, #+0]
    143              // Wait for TDR and shifter = empty
    144              while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
   \                     ??SPIopcode_0:
   \   00000012   0B69               LDR      R3,[R1, #+16]
   \   00000014   9B05               LSLS     R3,R3,#+22
   \   00000016   FCD5               BPL.N    ??SPIopcode_0
    145              // Send SPI op code 
    146              spi->SPI_TDR = opcode | SPI_PCS(BOARD_6131_NPCS);
   \   00000018   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   50F46023           ORRS     R3,R0,#0xE0000
   \   0000001E   CB60               STR      R3,[R1, #+12]
    147              // Wait for TDRE flag (Tx Data Register Empty)
    148              while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??SPIopcode_1:
   \   00000020   0B69               LDR      R3,[R1, #+16]
   \   00000022   9B07               LSLS     R3,R3,#+30
   \   00000024   FCD5               BPL.N    ??SPIopcode_1
    149              // Wait for RDRF flag (Rx Data Register Full)
    150              while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
   \                     ??SPIopcode_2:
   \   00000026   0B69               LDR      R3,[R1, #+16]
   \   00000028   DB07               LSLS     R3,R3,#+31
   \   0000002A   FCD5               BPL.N    ??SPIopcode_2
    151              // without this next delay, the ARM SPI reads wrong value in RDR!
    152              // I see good data shifting out from HI-6131 but RxData register value is wrong
    153              for (dummy=0; dummy<2; dummy++);
   \   0000002C   0023               MOVS     R3,#+0
   \   0000002E   1A00               MOVS     R2,R3
   \                     ??SPIopcode_3:
   \   00000030   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000032   022A               CMP      R2,#+2
   \   00000034   01D2               BCS.N    ??SPIopcode_4
   \   00000036   521C               ADDS     R2,R2,#+1
   \   00000038   FAE7               B.N      ??SPIopcode_3
    154              // Read received data char in Rx buffer, discard it 
    155              dummy = spi->SPI_RDR & 0xFFFF;
   \                     ??SPIopcode_4:
   \   0000003A   8B68               LDR      R3,[R1, #+8]
   \   0000003C   1A00               MOVS     R2,R3
    156              // prevent warning: variable dummy was set but never used
    157              dummy = dummy;
    158              // negate slave chip select
    159              AT91C_BASE_PIOA->PIO_SODR = SPI_nCS; // faster than PIO_Set(pinNss);
   \   0000003E   ........           LDR.W    R3,??DataTable13  ;; 0x400e0c30
   \   00000042   5FF48034           MOVS     R4,#+65536
   \   00000046   1C60               STR      R4,[R3, #+0]
    160          	__enable_interrupt();
   \   00000048   62B6               CPSIE    I
    161          }
   \   0000004A   10BC               POP      {R4}
   \   0000004C   7047               BX       LR               ;; return
    162          
    163          
    164          
    165          
    166          // This function writes a single 16-bit value to a specified HI-6131 register 0-63.
    167          // The function transmits an 8-bit op code, then transmits the data a byte at a time. 
    168          // All data characters received during op code and data transmission are discarded.
    169          //
    170          // To avoid disruption during SPI transfers, interrupts that use SPI must be 
    171          // temporarily disabled, delaying IRQ recognition until __enable_interrupt() occurs.
    172          //      
    173          // Either the calling routine issues __disable_interrupt() before calling this function, 
    174          // or the __disable_interrupt() and __enable_interrupt() calls are performed here. This 
    175          // choice determines where IRQ recognition	occurs. When series of spi function calls are 
    176          // chained to perform larger tasks, it may be desirable to disable/enable IRQs at the 
    177          // higher level (param irq_mgmt = 0)
    178          //
    179          // 	param 	data is the 16-bit word to be written to the target register
    180          // 	param 	reg_number is the target register address, 0 through 63 ONLY.
    181          //      param	irq_mgmt. if zero, the calling routine manages irq enable/disable.
    182          //			  if non-zero, this function locally calls __disable_interrupt() 
    183          //                        and __enable_interrupt().
    184          //
    185          //		The MCU's SPI mode register is written with option WDRBT = 0 so Master
    186          //		can initialize a new transfer whether/not SPI RxData register has unread
    187          //		data. To speed up SPI operations by taking advantnage of the WDRBT
    188          //		option, several statements are commented-out in the function below.
    189          //

   \                                 In section .text, align 2, keep-with-next
    190          unsigned char Write_6131LowReg(unsigned char reg_number, unsigned short data, unsigned char irq_mgmt) {
   \                     Write_6131LowReg:
   \   00000000   78B4               PUSH     {R3-R6}
   \   00000002   0300               MOVS     R3,R0
    191          
    192              AT91S_SPI *spi = BOARD_6131_SPI_BASE;
   \   00000004   ........           LDR.W    R4,??DataTable12  ;; 0x40008000
    193          	unsigned short i;
    194          	//unsigned short dummy;
    195              volatile unsigned char bufferTX[2];
    196                  
    197          	if(reg_number > 63) return('F');	// illegal parameter 		
   \   00000008   DBB2               UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000000A   402B               CMP      R3,#+64
   \   0000000C   01D3               BCC.N    ??Write_6131LowReg_0
   \   0000000E   4620               MOVS     R0,#+70
   \   00000010   35E0               B.N      ??Write_6131LowReg_1
    198          
    199              bufferTX[0] = (char)(data >> 8);        // upper data byte  
   \                     ??Write_6131LowReg_0:
   \   00000012   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000014   080A               LSRS     R0,R1,#+8
   \   00000016   8DF80000           STRB     R0,[SP, #+0]
    200              bufferTX[1] = (char)data;               // lower data byte 
   \   0000001A   0800               MOVS     R0,R1
   \   0000001C   8DF80100           STRB     R0,[SP, #+1]
    201                  
    202              // disable interrupts, if IRQs managed at this level
    203          	if(irq_mgmt)  __disable_interrupt();	 
   \   00000020   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000022   002A               CMP      R2,#+0
   \   00000024   00D0               BEQ.N    ??Write_6131LowReg_2
   \   00000026   72B6               CPSID    I
    204              // Assert SPI chip select
    205              AT91C_BASE_PIOA->PIO_CODR = SPI_nCS; // faster than PIO_Clear(pinNss);                        
   \                     ??Write_6131LowReg_2:
   \   00000028   ........           LDR.W    R0,??DataTable12_1  ;; 0x400e0c34
   \   0000002C   5FF48036           MOVS     R6,#+65536
   \   00000030   0660               STR      R6,[R0, #+0]
    206              // Wait for TDR and shifter = empty
    207              while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
   \                     ??Write_6131LowReg_3:
   \   00000032   2069               LDR      R0,[R4, #+16]
   \   00000034   8005               LSLS     R0,R0,#+22
   \   00000036   FCD5               BPL.N    ??Write_6131LowReg_3
    208              // Send 8-bit SPI op code = 0x80 + reg_number
    209              spi->SPI_TDR = (0x80 + reg_number) | SPI_PCS(BOARD_6131_NPCS);
   \   00000038   DBB2               UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000003A   13F18000           ADDS     R0,R3,#+128
   \   0000003E   50F46020           ORRS     R0,R0,#0xE0000
   \   00000042   E060               STR      R0,[R4, #+12]
    210              // Wait for TDRE flag (Tx Data Register Empty)
    211              while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Write_6131LowReg_4:
   \   00000044   2069               LDR      R0,[R4, #+16]
   \   00000046   8007               LSLS     R0,R0,#+30
   \   00000048   FCD5               BPL.N    ??Write_6131LowReg_4
    212              // Wait for RDRF flag (Rx Data Register Full)
    213              // while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
    214              // Read and discard received data char in Rx buffer
    215              // dummy = spi->SPI_RDR & 0xFFFF;
    216          
    217              // transmit 2 data bytes
    218              for (i = 0; i < 2; i++) {
   \   0000004A   0020               MOVS     R0,#+0
   \   0000004C   0500               MOVS     R5,R0
   \                     ??Write_6131LowReg_5:
   \   0000004E   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000050   022D               CMP      R5,#+2
   \   00000052   0AD2               BCS.N    ??Write_6131LowReg_6
    219                  // Wait for TDR and shifter = empty
    220                  // while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
    221                  // transmit next byte
    222                  spi->SPI_TDR = bufferTX[i] | SPI_PCS(BOARD_6131_NPCS);
   \   00000054   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000056   00A8               ADD      R0,SP,#+0
   \   00000058   285C               LDRB     R0,[R5, R0]
   \   0000005A   50F46020           ORRS     R0,R0,#0xE0000
   \   0000005E   E060               STR      R0,[R4, #+12]
    223                  // Wait for TDRE flag (Tx Data Register Empty)
    224                  while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Write_6131LowReg_7:
   \   00000060   2069               LDR      R0,[R4, #+16]
   \   00000062   8007               LSLS     R0,R0,#+30
   \   00000064   FCD5               BPL.N    ??Write_6131LowReg_7
    225                  // Wait for RDRF flag (Rx Data Register Full)
    226                  // while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
    227                  // Read and discard received data char in Rx buffer
    228                  // dummy = spi->SPI_RDR & 0xFFFF;
    229                  // prevent warning: variable dummy was set but never used
    230                  // dummy = dummy;
    231              }    
   \   00000066   6D1C               ADDS     R5,R5,#+1
   \   00000068   F1E7               B.N      ??Write_6131LowReg_5
    232              // negate slave chip select
    233              AT91C_BASE_PIOA->PIO_SODR = SPI_nCS; // faster than PIO_Set(pinNss);
   \                     ??Write_6131LowReg_6:
   \   0000006A   ........           LDR.W    R0,??DataTable13  ;; 0x400e0c30
   \   0000006E   5FF48036           MOVS     R6,#+65536
   \   00000072   0660               STR      R6,[R0, #+0]
    234              // re-enable interrupts, if IRQs managed at this level 
    235          	if(irq_mgmt)  __enable_interrupt();	
   \   00000074   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000076   002A               CMP      R2,#+0
   \   00000078   00D0               BEQ.N    ??Write_6131LowReg_8
   \   0000007A   62B6               CPSIE    I
    236                  
    237          	return('P');
   \                     ??Write_6131LowReg_8:
   \   0000007C   5020               MOVS     R0,#+80
   \                     ??Write_6131LowReg_1:
   \   0000007E   72BC               POP      {R1,R4-R6}
   \   00000080   7047               BX       LR               ;; return
    238          }
    239                  
    240          
    241          // 	This function reads a single 16-bit value from a specified HI-6131 register 0-15.
    242          //	The function transmits an 8-bit op code, then receives the data word as two 
    243          //	bytes. The data is returned as a word. The data character received during 
    244          //	op code transmission is discarded.
    245          //
    246          //	Either the calling routine issues __disable_interrupt() before calling this function, 
    247          //  or the __disable_interrupt() and __enable_interrupt() calls are performed here. This 
    248          //  choice determines where IRQ recognition	occurs. When series of spi function calls are 
    249          //  chained to perform larger tasks, it may be desirable to disable/enable IRQs at the 
    250          //  higher level (param irq_mgmt = 0)
    251          //
    252          // 	param 	reg_number is the target register address, 0 through 15 ONLY.
    253          //      param	irq_mgmt. if zero, the calling routine manages irq enable/disable.
    254          //			  if non-zero, this function locally calls __disable_interrupt() 
    255          //                        and __enable_interrupt().
    256          //
    257          //		The MCU's SPI mode register is written with option WDRBT = 0 so Master
    258          //		can initialize a new transfer whether/not SPI RxData register has unread
    259          //		data. To speed up SPI operations by taking advantnage of the WDRBT
    260          //		option, several statements are commented-out in the function below.
    261          //

   \                                 In section .text, align 2, keep-with-next
    262          unsigned short Read_6131LowReg(unsigned char reg_number, unsigned char irq_mgmt) {
   \                     Read_6131LowReg:
   \   00000000   78B4               PUSH     {R3-R6}
   \   00000002   0200               MOVS     R2,R0
    263                 
    264              AT91S_SPI *spi = BOARD_6131_SPI_BASE;
   \   00000004   ........           LDR.W    R3,??DataTable12  ;; 0x40008000
    265              unsigned short data, i;
    266              volatile unsigned char bufferRX[2];
    267                  
    268              if(reg_number > 15) return('F');  // illegal parameter 		
   \   00000008   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000A   102A               CMP      R2,#+16
   \   0000000C   01D3               BCC.N    ??Read_6131LowReg_0
   \   0000000E   4620               MOVS     R0,#+70
   \   00000010   49E0               B.N      ??Read_6131LowReg_1
    269          
    270              // disable interrupts, if IRQs managed at this level
    271              if(irq_mgmt)  __disable_interrupt();	 
   \                     ??Read_6131LowReg_0:
   \   00000012   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0029               CMP      R1,#+0
   \   00000016   00D0               BEQ.N    ??Read_6131LowReg_2
   \   00000018   72B6               CPSID    I
    272              // Assert SPI chip select
    273              AT91C_BASE_PIOA->PIO_CODR = SPI_nCS; // faster than PIO_Clear(pinNss); 
   \                     ??Read_6131LowReg_2:
   \   0000001A   ........           LDR.W    R0,??DataTable12_1  ;; 0x400e0c34
   \   0000001E   5FF48036           MOVS     R6,#+65536
   \   00000022   0660               STR      R6,[R0, #+0]
    274              // Wait for TDR and shifter = empty
    275              while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
   \                     ??Read_6131LowReg_3:
   \   00000024   1869               LDR      R0,[R3, #+16]
   \   00000026   8005               LSLS     R0,R0,#+22
   \   00000028   FCD5               BPL.N    ??Read_6131LowReg_3
    276              // Send 8-bit SPI op code = reg_number << 2
    277              spi->SPI_TDR = (reg_number << 2) | SPI_PCS(BOARD_6131_NPCS);
   \   0000002A   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000002C   9000               LSLS     R0,R2,#+2
   \   0000002E   50F46020           ORRS     R0,R0,#0xE0000
   \   00000032   D860               STR      R0,[R3, #+12]
    278              // Wait for TDRE flag (Tx Data Register Empty)
    279              while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Read_6131LowReg_4:
   \   00000034   1869               LDR      R0,[R3, #+16]
   \   00000036   8007               LSLS     R0,R0,#+30
   \   00000038   FCD5               BPL.N    ??Read_6131LowReg_4
    280              // Wait for RDRF flag (Rx Data Register Full)
    281              while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
   \                     ??Read_6131LowReg_5:
   \   0000003A   1869               LDR      R0,[R3, #+16]
   \   0000003C   C007               LSLS     R0,R0,#+31
   \   0000003E   FCD5               BPL.N    ??Read_6131LowReg_5
    282              // Read received data char in Rx buffer, discard/overwrite below
    283              bufferRX[0] = spi->SPI_RDR;// & 0xFF;
   \   00000040   9868               LDR      R0,[R3, #+8]
   \   00000042   8DF80000           STRB     R0,[SP, #+0]
    284          
    285              // receive 2 bytes register data, transmit 2 dummy data bytes
    286              for (i = 0; i < 2; i++) {
   \   00000046   0020               MOVS     R0,#+0
   \   00000048   0500               MOVS     R5,R0
   \                     ??Read_6131LowReg_6:
   \   0000004A   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004C   022D               CMP      R5,#+2
   \   0000004E   18D2               BCS.N    ??Read_6131LowReg_7
    287                  // Wait for TDR and shifter = empty
    288                  while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
   \                     ??Read_6131LowReg_8:
   \   00000050   1869               LDR      R0,[R3, #+16]
   \   00000052   8005               LSLS     R0,R0,#+22
   \   00000054   FCD5               BPL.N    ??Read_6131LowReg_8
    289                  // transmit dummy data to receive next byte
    290                  spi->SPI_TDR = 0x00 | SPI_PCS(BOARD_6131_NPCS);
   \   00000056   5FF46020           MOVS     R0,#+917504
   \   0000005A   D860               STR      R0,[R3, #+12]
    291                  // Wait for TDRE flag (Tx Data Register Empty)
    292                  while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Read_6131LowReg_9:
   \   0000005C   1869               LDR      R0,[R3, #+16]
   \   0000005E   8007               LSLS     R0,R0,#+30
   \   00000060   FCD5               BPL.N    ??Read_6131LowReg_9
    293                  // Wait for RDRF flag (Rx Data Register Full)
    294                  while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
   \                     ??Read_6131LowReg_10:
   \   00000062   1869               LDR      R0,[R3, #+16]
   \   00000064   C007               LSLS     R0,R0,#+31
   \   00000066   FCD5               BPL.N    ??Read_6131LowReg_10
    295                  // without this next delay, the ARM SPI reads wrong value in RDR!
    296                  // I see good data shifting out from HI-6131 but RxData register value is wrong
    297                  for (data=0; data<2; data++);
   \   00000068   0020               MOVS     R0,#+0
   \   0000006A   0400               MOVS     R4,R0
   \                     ??Read_6131LowReg_11:
   \   0000006C   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000006E   022C               CMP      R4,#+2
   \   00000070   01D2               BCS.N    ??Read_6131LowReg_12
   \   00000072   641C               ADDS     R4,R4,#+1
   \   00000074   FAE7               B.N      ??Read_6131LowReg_11
    298                  // Read received data char in Rx buffer
    299                  bufferRX[i] = spi->SPI_RDR;// & 0xFF;
   \                     ??Read_6131LowReg_12:
   \   00000076   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000078   00A8               ADD      R0,SP,#+0
   \   0000007A   9E68               LDR      R6,[R3, #+8]
   \   0000007C   2E54               STRB     R6,[R5, R0]
    300              }    
   \   0000007E   6D1C               ADDS     R5,R5,#+1
   \   00000080   E3E7               B.N      ??Read_6131LowReg_6
    301              // negate slave chip select
    302              AT91C_BASE_PIOA->PIO_SODR = SPI_nCS; // faster than PIO_Set(pinNss);
   \                     ??Read_6131LowReg_7:
   \   00000082   ........           LDR.W    R0,??DataTable13  ;; 0x400e0c30
   \   00000086   5FF48036           MOVS     R6,#+65536
   \   0000008A   0660               STR      R6,[R0, #+0]
    303              // re-enable interrupts, if IRQs managed at this level 
    304              if(irq_mgmt)  __enable_interrupt();	
   \   0000008C   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000008E   0029               CMP      R1,#+0
   \   00000090   00D0               BEQ.N    ??Read_6131LowReg_13
   \   00000092   62B6               CPSIE    I
    305              // concantenate (merge) 2 data bytes into 16-bit value
    306              data =  (unsigned int)bufferRX[0] << 8;
   \                     ??Read_6131LowReg_13:
   \   00000094   9DF80000           LDRB     R0,[SP, #+0]
   \   00000098   0002               LSLS     R0,R0,#+8
   \   0000009A   0400               MOVS     R4,R0
    307              data |= (unsigned int)bufferRX[1];
   \   0000009C   9DF80100           LDRB     R0,[SP, #+1]
   \   000000A0   0443               ORRS     R4,R0,R4
    308                  
    309              return data;
   \   000000A2   2000               MOVS     R0,R4
   \   000000A4   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??Read_6131LowReg_1:
   \   000000A6   72BC               POP      {R1,R4-R6}
   \   000000A8   7047               BX       LR               ;; return
    310          }
    311            
    312          
    313          
    314          
    315          //  This function writes a single 16-bit word to the address indicated by the 
    316          //  current value in the already-enabled HI-6131 Memory Address Pointer register. 
    317          // The function transmits an 8-bit op code then the data word a byte at a time. 
    318          // Data characters received during op code and data transmission are discarded.
    319          // The Memory Address Pointer auto-increments after writing the data
    320          //
    321          // Either the calling routine issues __disable_interrupt() before calling this function, 
    322          //  or the __disable_interrupt() and __enable_interrupt() calls are performed here. This 
    323          //  choice determines where IRQ recognition	occurs. When series of spi function calls are 
    324          //  chained to perform larger tasks, it may be desirable to disable/enable IRQs at the 
    325          //  higher level (param irq_mgmt = 0)
    326          //
    327          // param 	data is the 16-bit word to be written
    328          // param	irq_mgmt. if zero, the calling routine manages irq enable/disable.
    329          //			  if non-zero, this function locally calls __disable_interrupt() 
    330          //                        and __enable_interrupt().
    331          //

   \                                 In section .text, align 2, keep-with-next
    332          void Write_6131_1word(unsigned short data, unsigned char irq_mgmt)  {
   \                     Write_6131_1word:
   \   00000000   78B4               PUSH     {R3-R6}
    333          
    334              AT91S_SPI *spi = BOARD_6131_SPI_BASE;
   \   00000002   ........           LDR.W    R2,??DataTable12  ;; 0x40008000
    335              unsigned short i;
    336              unsigned short dummy;
    337              volatile unsigned char bufferTX[2];
    338                  
    339              // upper data byte
    340              bufferTX[0] = (char)(data >> 8);          
   \   00000006   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000008   050A               LSRS     R5,R0,#+8
   \   0000000A   8DF80050           STRB     R5,[SP, #+0]
    341              // lower data byte
    342              bufferTX[1] = (char)data;               
   \   0000000E   0500               MOVS     R5,R0
   \   00000010   8DF80150           STRB     R5,[SP, #+1]
    343                  
    344              // disable interrupts, if IRQs managed at this level
    345              if(irq_mgmt)  __disable_interrupt();	 
   \   00000014   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0029               CMP      R1,#+0
   \   00000018   00D0               BEQ.N    ??Write_6131_1word_0
   \   0000001A   72B6               CPSID    I
    346              // Assert SPI chip select
    347              AT91C_BASE_PIOA->PIO_CODR = SPI_nCS; // faster than PIO_Clear(pinNss);                        
   \                     ??Write_6131_1word_0:
   \   0000001C   ........           LDR.W    R5,??DataTable12_1  ;; 0x400e0c34
   \   00000020   5FF48036           MOVS     R6,#+65536
   \   00000024   2E60               STR      R6,[R5, #+0]
    348              // Wait for TDR and shifter = empty
    349              while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
   \                     ??Write_6131_1word_1:
   \   00000026   1569               LDR      R5,[R2, #+16]
   \   00000028   AD05               LSLS     R5,R5,#+22
   \   0000002A   FCD5               BPL.N    ??Write_6131_1word_1
    350              // Send 8-bit SPI op code 0xC0: write using enabled MAP current value
    351              spi->SPI_TDR = 0xC0 | SPI_PCS(BOARD_6131_NPCS);
   \   0000002C   ........           LDR.W    R5,??DataTable13_1  ;; 0xe00c0
   \   00000030   D560               STR      R5,[R2, #+12]
    352              // Wait for TDRE flag (Tx Data Register Empty)
    353              while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Write_6131_1word_2:
   \   00000032   1569               LDR      R5,[R2, #+16]
   \   00000034   AD07               LSLS     R5,R5,#+30
   \   00000036   FCD5               BPL.N    ??Write_6131_1word_2
    354              // Wait for RDRF flag (Rx Data Register Full)
    355              while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
   \                     ??Write_6131_1word_3:
   \   00000038   1569               LDR      R5,[R2, #+16]
   \   0000003A   ED07               LSLS     R5,R5,#+31
   \   0000003C   FCD5               BPL.N    ??Write_6131_1word_3
    356              // Read and discard received data char in Rx buffer
    357              dummy = spi->SPI_RDR & 0xFFFF;
   \   0000003E   9568               LDR      R5,[R2, #+8]
   \   00000040   2C00               MOVS     R4,R5
    358          
    359              // transmit 2 data bytes
    360              for (i = 0; i < 2; i++) {
   \   00000042   0025               MOVS     R5,#+0
   \   00000044   2B00               MOVS     R3,R5
   \                     ??Write_6131_1word_4:
   \   00000046   9BB2               UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000048   022B               CMP      R3,#+2
   \   0000004A   0FD2               BCS.N    ??Write_6131_1word_5
    361                  // Wait for TDR and shifter = empty
    362                  // while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
    363                  // transmit next byte
    364                  spi->SPI_TDR = bufferTX[i] | SPI_PCS(BOARD_6131_NPCS);
   \   0000004C   9BB2               UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000004E   00AD               ADD      R5,SP,#+0
   \   00000050   5D5D               LDRB     R5,[R3, R5]
   \   00000052   55F46025           ORRS     R5,R5,#0xE0000
   \   00000056   D560               STR      R5,[R2, #+12]
    365                  // Wait for TDRE flag (Tx Data Register Empty)
    366                  while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Write_6131_1word_6:
   \   00000058   1569               LDR      R5,[R2, #+16]
   \   0000005A   AD07               LSLS     R5,R5,#+30
   \   0000005C   FCD5               BPL.N    ??Write_6131_1word_6
    367                  // Wait for RDRF flag (Rx Data Register Full)
    368                  while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
   \                     ??Write_6131_1word_7:
   \   0000005E   1569               LDR      R5,[R2, #+16]
   \   00000060   ED07               LSLS     R5,R5,#+31
   \   00000062   FCD5               BPL.N    ??Write_6131_1word_7
    369                  // Read and discard received data char in Rx buffer
    370                  dummy = spi->SPI_RDR;
   \   00000064   9568               LDR      R5,[R2, #+8]
   \   00000066   2C00               MOVS     R4,R5
    371              }    
   \   00000068   5B1C               ADDS     R3,R3,#+1
   \   0000006A   ECE7               B.N      ??Write_6131_1word_4
    372              // prevent warning: variable dummy was set but never used
    373              dummy = dummy;        
    374              // negate slave chip select
    375              AT91C_BASE_PIOA->PIO_SODR = SPI_nCS; // faster than PIO_Set(pinNss);
   \                     ??Write_6131_1word_5:
   \   0000006C   ........           LDR.W    R5,??DataTable15  ;; 0x400e0c30
   \   00000070   5FF48036           MOVS     R6,#+65536
   \   00000074   2E60               STR      R6,[R5, #+0]
    376              // re-enable interrupts, if IRQs managed at this level 
    377              if(irq_mgmt)  __enable_interrupt();	
   \   00000076   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000078   0029               CMP      R1,#+0
   \   0000007A   00D0               BEQ.N    ??Write_6131_1word_8
   \   0000007C   62B6               CPSIE    I
    378                  
    379              return;
   \                     ??Write_6131_1word_8:
   \   0000007E   71BC               POP      {R0,R4-R6}
   \   00000080   7047               BX       LR               ;; return
    380          }
    381                  
    382          
    383          
    384          
    385          // This function reads one 16-bit register or RAM location, indicated by
    386          // the address value in the HI-6131 Memory Address Pointer register. 
    387          // The function transmits an 8-bit op code, then reads and returns the 
    388          // data using SPI, a byte at a time. Bytes are merged into returned word.
    389          //
    390          // Either the calling routine issues __disable_interrupt() before calling this function, 
    391          //  or the __disable_interrupt() and __enable_interrupt() calls are performed here. This 
    392          //  choice determines where IRQ recognition	occurs. When series of spi function calls are 
    393          //  chained to perform larger tasks, it may be desirable to disable/enable IRQs at the 
    394          //  higher level (param irq_mgmt = 0)
    395          //
    396          //  param  irq_mgmt. if zero, the calling routine manages irq enable/disable.
    397          //                   if non-zero, this function locally calls __disable_interrupt() 
    398          //                   and __enable_interrupt().
    399          //
    400          // The MCU's SPI mode register is written with option WDRBT = 0 so Master
    401          // can initialize a new transfer whether/not SPI RxData register has unread
    402          // data. To speed up SPI operations by taking advantnage of the WDRBT
    403          // option, several statements are commented-out in the function below.
    404          //

   \                                 In section .text, align 2, keep-with-next
    405          unsigned short Read_6131_1word(unsigned char irq_mgmt) {
   \                     Read_6131_1word:
   \   00000000   38B4               PUSH     {R3-R5}
   \   00000002   0100               MOVS     R1,R0
    406                 
    407              AT91S_SPI *spi = BOARD_6131_SPI_BASE;
   \   00000004   ........           LDR.W    R2,??DataTable12  ;; 0x40008000
    408              unsigned short data, i;
    409              volatile unsigned char bufferRX[2];
    410                  
    411              // disable interrupts, if IRQs managed at this level
    412              if(irq_mgmt)  __disable_interrupt();	 
   \   00000008   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0029               CMP      R1,#+0
   \   0000000C   00D0               BEQ.N    ??Read_6131_1word_0
   \   0000000E   72B6               CPSID    I
    413                 
    414              // Assert SPI chip select
    415              AT91C_BASE_PIOA->PIO_CODR = SPI_nCS; // faster than PIO_Clear(pinNss); 
   \                     ??Read_6131_1word_0:
   \   00000010   ........           LDR.W    R4,??DataTable12_1  ;; 0x400e0c34
   \   00000014   5FF48035           MOVS     R5,#+65536
   \   00000018   2560               STR      R5,[R4, #+0]
    416              // Wait for TDR and shifter = empty
    417              while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
   \                     ??Read_6131_1word_1:
   \   0000001A   1469               LDR      R4,[R2, #+16]
   \   0000001C   A405               LSLS     R4,R4,#+22
   \   0000001E   FCD5               BPL.N    ??Read_6131_1word_1
    418              // Send 8-bit SPI read op code 0x40
    419              spi->SPI_TDR = 0x40 | SPI_PCS(BOARD_6131_NPCS);
   \   00000020   ........           LDR.W    R4,??DataTable13_2  ;; 0xe0040
   \   00000024   D460               STR      R4,[R2, #+12]
    420              // Wait for TDRE flag (Tx Data Register Empty)
    421              while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Read_6131_1word_2:
   \   00000026   1469               LDR      R4,[R2, #+16]
   \   00000028   A407               LSLS     R4,R4,#+30
   \   0000002A   FCD5               BPL.N    ??Read_6131_1word_2
    422              // Wait for RDRF flag (Rx Data Register Full)
    423              while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
   \                     ??Read_6131_1word_3:
   \   0000002C   1469               LDR      R4,[R2, #+16]
   \   0000002E   E407               LSLS     R4,R4,#+31
   \   00000030   FCD5               BPL.N    ??Read_6131_1word_3
    424              // Read received data char in Rx buffer, overwrite/discard it below
    425              bufferRX[0] = spi->SPI_RDR & 0xFFFF;
   \   00000032   9468               LDR      R4,[R2, #+8]
   \   00000034   8DF80040           STRB     R4,[SP, #+0]
    426          
    427              // receive 2 bytes register data, transmit 2 dummy data bytes
    428              for (i = 0; i < 2; i++) {
   \   00000038   0024               MOVS     R4,#+0
   \   0000003A   2300               MOVS     R3,R4
   \                     ??Read_6131_1word_4:
   \   0000003C   9BB2               UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000003E   022B               CMP      R3,#+2
   \   00000040   18D2               BCS.N    ??Read_6131_1word_5
    429                  // Wait for TDR and shifter = empty
    430                  while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
   \                     ??Read_6131_1word_6:
   \   00000042   1469               LDR      R4,[R2, #+16]
   \   00000044   A405               LSLS     R4,R4,#+22
   \   00000046   FCD5               BPL.N    ??Read_6131_1word_6
    431                  // transmit dummy data byte 0x00 to start receive
    432                  spi->SPI_TDR = 0x00 | SPI_PCS(BOARD_6131_NPCS);
   \   00000048   5FF46024           MOVS     R4,#+917504
   \   0000004C   D460               STR      R4,[R2, #+12]
    433                  // Wait for TDRE flag (Tx Data Register Empty)
    434                  while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Read_6131_1word_7:
   \   0000004E   1469               LDR      R4,[R2, #+16]
   \   00000050   A407               LSLS     R4,R4,#+30
   \   00000052   FCD5               BPL.N    ??Read_6131_1word_7
    435                  // Wait for RDRF flag (Rx Data Register Full)
    436                  while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
   \                     ??Read_6131_1word_8:
   \   00000054   1469               LDR      R4,[R2, #+16]
   \   00000056   E407               LSLS     R4,R4,#+31
   \   00000058   FCD5               BPL.N    ??Read_6131_1word_8
    437                  // without this next delay, the ARM SPI reads wrong value in RDR!
    438                  // I see good data shifting out from HI-6131 but RxData register value is wrong
    439                  for (data=0; data<5; data++);
   \   0000005A   0024               MOVS     R4,#+0
   \   0000005C   2000               MOVS     R0,R4
   \                     ??Read_6131_1word_9:
   \   0000005E   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000060   0528               CMP      R0,#+5
   \   00000062   01D2               BCS.N    ??Read_6131_1word_10
   \   00000064   401C               ADDS     R0,R0,#+1
   \   00000066   FAE7               B.N      ??Read_6131_1word_9
    440                 // Read received data char in Rx buffer
    441                  bufferRX[i] = spi->SPI_RDR;
   \                     ??Read_6131_1word_10:
   \   00000068   9BB2               UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000006A   00AC               ADD      R4,SP,#+0
   \   0000006C   9568               LDR      R5,[R2, #+8]
   \   0000006E   1D55               STRB     R5,[R3, R4]
    442              }    
   \   00000070   5B1C               ADDS     R3,R3,#+1
   \   00000072   E3E7               B.N      ??Read_6131_1word_4
    443              // negate slave chip select
    444              AT91C_BASE_PIOA->PIO_SODR = SPI_nCS; // faster than PIO_Set(pinNss);
   \                     ??Read_6131_1word_5:
   \   00000074   ........           LDR.W    R4,??DataTable15  ;; 0x400e0c30
   \   00000078   5FF48035           MOVS     R5,#+65536
   \   0000007C   2560               STR      R5,[R4, #+0]
    445              // re-enable interrupts, if IRQs managed at this level 
    446              if(irq_mgmt)  __enable_interrupt();	
   \   0000007E   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000080   0029               CMP      R1,#+0
   \   00000082   00D0               BEQ.N    ??Read_6131_1word_11
   \   00000084   62B6               CPSIE    I
    447              // merge 2 data bytes into 16-bit value
    448              data =  (unsigned int)bufferRX[0] << 8;
   \                     ??Read_6131_1word_11:
   \   00000086   9DF80040           LDRB     R4,[SP, #+0]
   \   0000008A   2402               LSLS     R4,R4,#+8
   \   0000008C   2000               MOVS     R0,R4
    449              data |= (unsigned int)bufferRX[1];
   \   0000008E   9DF80140           LDRB     R4,[SP, #+1]
   \   00000092   2043               ORRS     R0,R4,R0
    450                  
    451          	return data;
   \   00000094   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000096   32BC               POP      {R1,R4,R5}
   \   00000098   7047               BX       LR               ;; return
    452          }
    453            
    454           
    455          
    456          // This function writes one or more 16-bit words to the starting address indicated
    457          // by the current value in the HI-6131 Memory Address Pointer register. The function
    458          // transmits an 8-bit op code, then transmits data words a byte at a time. 
    459          // All data characters received during op code and data transmission are discarded.
    460          //
    461          // Either the calling routine issues __disable_interrupt() before calling this function, 
    462          //  or the __disable_interrupt() and __enable_interrupt() calls are performed here. This 
    463          //  choice determines where IRQ recognition	occurs. When series of spi function calls are 
    464          //  chained to perform larger tasks, it may be desirable to disable/enable IRQs at the 
    465          //  higher level (param irq_mgmt = 0)
    466          //
    467          // Note: Because this function may perform long N-word transfers, it is typically 
    468          // used with parameter irq_mgmt = 1. In this mode, IRQs are disabled during spi intervals,
    469          // but IRQs are periodically enabled between whole word transfers. The function will 
    470          // recover from vectored spi-using interrupts (recognized only between written data words) 
    471          // when these IRQs use the demonstrated "spi_busy spi_irq" handshake. Such IRQs are 
    472          // detected and a new SPI op code is issued to permit this function to continue to completion.
    473          //
    474          // 	param 	write_data[] array containing 16-bit words to be written, write_data[0] is written first
    475          // 	param 	number_of_words to be transferred 
    476          // 	param 	inc_pointer_first = 0 begins reading at current Memory Address Pointer addr, 
    477          //                              1 (non-zero) increments Memory Address Pointer before reading
    478          //      param	irq_mgmt. if zero, the calling routine manages irq enable/disable.
    479          //	                  if non-zero, this function locally calls __disable_interrupt() 
    480          //                        and __enable_interrupt().
    481          //
    482          //		The MCU's SPI mode register is written with option WDRBT = 0 so Master
    483          //		can initialize a new transfer whether/not SPI RxData register has unread
    484          //		data. To speed up SPI operations by taking advantnage of the WDRBT
    485          //		option, several statements are commented-out in the function below.
    486          //

   \                                 In section .text, align 2, keep-with-next
    487          void Write_6131(unsigned short write_data[], unsigned char inc_pointer_first, unsigned char irq_mgmt) {
   \                     Write_6131:
   \   00000000   F0B4               PUSH     {R4-R7}
    488          
    489              AT91S_SPI *spi = BOARD_6131_SPI_BASE;
   \   00000002   ........           LDR.W    R3,??DataTable12  ;; 0x40008000
    490              unsigned short i, len;
    491              //unsigned short dummy;
    492              unsigned char opcode;
    493                  
    494              // disable interrupts, if IRQs managed at this level
    495              if(irq_mgmt)  __disable_interrupt();	 
   \   00000006   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000008   002A               CMP      R2,#+0
   \   0000000A   00D0               BEQ.N    ??Write_6131_0
   \   0000000C   72B6               CPSID    I
    496                  
    497              if(inc_pointer_first) opcode = 0xC8;
   \                     ??Write_6131_0:
   \   0000000E   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0029               CMP      R1,#+0
   \   00000012   02D0               BEQ.N    ??Write_6131_1
   \   00000014   C827               MOVS     R7,#+200
   \   00000016   3E00               MOVS     R6,R7
   \   00000018   01E0               B.N      ??Write_6131_2
    498              else opcode = 0xC0;
   \                     ??Write_6131_1:
   \   0000001A   C027               MOVS     R7,#+192
   \   0000001C   3E00               MOVS     R6,R7
    499                       
    500              if(irq_mgmt)  __disable_interrupt();
   \                     ??Write_6131_2:
   \   0000001E   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000020   002A               CMP      R2,#+0
   \   00000022   00D0               BEQ.N    ??Write_6131_3
   \   00000024   72B6               CPSID    I
    501              // variable tested by vectored interrupt routine 
    502              spi_busy = 1;				
   \                     ??Write_6131_3:
   \   00000026   ........           LDR.W    R7,??DataTable15_1
   \   0000002A   5FF0010C           MOVS     R12,#+1
   \   0000002E   87F800C0           STRB     R12,[R7, #+0]
    503              // Assert SPI chip select
    504              AT91C_BASE_PIOA->PIO_CODR = SPI_nCS; // faster than PIO_Clear(pinNss); 
   \   00000032   ........           LDR.W    R7,??DataTable12_1  ;; 0x400e0c34
   \   00000036   5FF4803C           MOVS     R12,#+65536
   \   0000003A   C7F800C0           STR      R12,[R7, #+0]
    505              // Wait for TDR and shifter = empty
    506              while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
   \                     ??Write_6131_4:
   \   0000003E   1F69               LDR      R7,[R3, #+16]
   \   00000040   BF05               LSLS     R7,R7,#+22
   \   00000042   FCD5               BPL.N    ??Write_6131_4
    507              // Send SPI op code 
    508              spi->SPI_TDR = opcode | SPI_PCS(BOARD_6131_NPCS);
   \   00000044   F6B2               UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000046   56F46027           ORRS     R7,R6,#0xE0000
   \   0000004A   DF60               STR      R7,[R3, #+12]
    509              // Wait for TDRE flag (Tx Data Register Empty)
    510              while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Write_6131_5:
   \   0000004C   1F69               LDR      R7,[R3, #+16]
   \   0000004E   BF07               LSLS     R7,R7,#+30
   \   00000050   FCD5               BPL.N    ??Write_6131_5
    511              // Wait for RDRF flag (Rx Data Register Full)
    512              // while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
    513              // Read and discard received data char in Rx buffer
    514              // dummy = spi->SPI_RDR & 0xFFFF;
    515                  
    516              len = sizeof(write_data);
   \   00000052   0427               MOVS     R7,#+4
   \   00000054   3D00               MOVS     R5,R7
    517                                                               
    518          	for (i = 0; i < len; i++) 	{
   \   00000056   0027               MOVS     R7,#+0
   \   00000058   3C00               MOVS     R4,R7
   \                     ??Write_6131_6:
   \   0000005A   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000005C   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000005E   AC42               CMP      R4,R5
   \   00000060   38D2               BCS.N    ??Write_6131_7
    519          
    520          		if(irq_mgmt) __enable_interrupt();
   \   00000062   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000064   002A               CMP      R2,#+0
   \   00000066   00D0               BEQ.N    ??Write_6131_8
   \   00000068   62B6               CPSIE    I
    521          		// Before writing the next word, momentarily enable IRQs...
    522          		// A pending IRQ that occurred since last __disable_interrupt() will be recognized here.
    523          		// Its ISR (int.svc routine) will execute, probably using SPI, disrupting 
    524          		// our multi-word transfer. The ISR sets the spi_irq flag, then execution 
    525          		// resumes here, at this __disable_interrupt() call...   
    526          		if(irq_mgmt) __disable_interrupt();			
   \                     ??Write_6131_8:
   \   0000006A   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000006C   002A               CMP      R2,#+0
   \   0000006E   00D0               BEQ.N    ??Write_6131_9
   \   00000070   72B6               CPSID    I
    527          
    528          		if(spi_irq) {
   \                     ??Write_6131_9:
   \   00000072   ........           LDR.W    R7,??DataTable15_2
   \   00000076   3F78               LDRB     R7,[R7, #+0]
   \   00000078   002F               CMP      R7,#+0
   \   0000007A   14D0               BEQ.N    ??Write_6131_10
    529          		    // the multi-word transfer was disturbed, but the interrupt's
    530          	        // ISR should have used a different Memory Address Pointer and
    531                      // reenabled the Memory Address Pointer we were using, so our
    532          			// MAP points to the next word to be written. Issue a new SPI 
    533          			// op code to resume a multi-word write process, starting at the 
    534          			// RAM location addressed by the Memory Address Pointer value. 
    535          
    536                      // Assert SPI chip select since there was an interrupt
    537                      AT91C_BASE_PIOA->PIO_CODR = SPI_nCS; // faster than PIO_Clear(pinNss); 
   \   0000007C   ........           LDR.W    R7,??DataTable12_1  ;; 0x400e0c34
   \   00000080   5FF4803C           MOVS     R12,#+65536
   \   00000084   C7F800C0           STR      R12,[R7, #+0]
    538                      // Wait for TDR and shifter = empty
    539                      while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
   \                     ??Write_6131_11:
   \   00000088   1F69               LDR      R7,[R3, #+16]
   \   0000008A   BF05               LSLS     R7,R7,#+22
   \   0000008C   FCD5               BPL.N    ??Write_6131_11
    540                      // Issue SPI op code 0xC0: write using existing MAP pointer value.
    541                      spi->SPI_TDR = 0xC0 | SPI_PCS(BOARD_6131_NPCS);
   \   0000008E   ........           LDR.W    R7,??DataTable13_1  ;; 0xe00c0
   \   00000092   DF60               STR      R7,[R3, #+12]
    542                      // Wait for TDRE flag (Tx Data Register Empty)
    543                      while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Write_6131_12:
   \   00000094   1F69               LDR      R7,[R3, #+16]
   \   00000096   BF07               LSLS     R7,R7,#+30
   \   00000098   FCD5               BPL.N    ??Write_6131_12
    544                      // Wait for RDRF flag (Rx Data Register Full)
    545                      // while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
    546                      // Read and discard received data char in Rx buffer
    547                      // dummy = spi->SPI_RDR & 0xFFFF;
    548          			spi_irq = 0;
   \   0000009A   ........           LDR.W    R7,??DataTable15_2
   \   0000009E   5FF0000C           MOVS     R12,#+0
   \   000000A2   87F800C0           STRB     R12,[R7, #+0]
    549          		}
    550                          
    551                  // transmit next data word a byte at a time
    552                          
    553                  // Wait for TDR and shifter = empty
    554                  // while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
    555                  // transmit upper byte
    556                  spi->SPI_TDR = ((char)(write_data[i] >> 8)) | SPI_PCS(BOARD_6131_NPCS);
   \                     ??Write_6131_10:
   \   000000A6   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000A8   30F81470           LDRH     R7,[R0, R4, LSL #+1]
   \   000000AC   BFB2               UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000AE   3F0A               LSRS     R7,R7,#+8
   \   000000B0   FFB2               UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000B2   57F46027           ORRS     R7,R7,#0xE0000
   \   000000B6   DF60               STR      R7,[R3, #+12]
    557                  // Wait for TDRE flag (Tx Data Register Empty)
    558                  while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Write_6131_13:
   \   000000B8   1F69               LDR      R7,[R3, #+16]
   \   000000BA   BF07               LSLS     R7,R7,#+30
   \   000000BC   FCD5               BPL.N    ??Write_6131_13
    559                  // Wait for RDRF flag (Rx Data Register Full)
    560                  // while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
    561                  // Read and discard received data char in Rx buffer
    562                  // dummy = spi->SPI_RDR & 0xFFFF;
    563          
    564                  // Wait for TDR and shifter = empty
    565                  // while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
    566                  // transmit lower byte
    567                  spi->SPI_TDR = ((char)(write_data[i])) | SPI_PCS(BOARD_6131_NPCS);
   \   000000BE   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000C0   10F81470           LDRB     R7,[R0, R4, LSL #+1]
   \   000000C4   57F46027           ORRS     R7,R7,#0xE0000
   \   000000C8   DF60               STR      R7,[R3, #+12]
    568                  // Wait for TDRE flag (Tx Data Register Empty)
    569                  while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Write_6131_14:
   \   000000CA   1F69               LDR      R7,[R3, #+16]
   \   000000CC   BF07               LSLS     R7,R7,#+30
   \   000000CE   FCD5               BPL.N    ??Write_6131_14
    570                  // Wait for RDRF flag (Rx Data Register Full)
    571                  // while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
    572                  // Read and discard received data char in Rx buffer
    573                  // dummy = spi->SPI_RDR & 0xFFFF;                            
    574          	}
   \   000000D0   641C               ADDS     R4,R4,#+1
   \   000000D2   C2E7               B.N      ??Write_6131_6
    575              // prevent warning: variable dummy was set but never used
    576              // dummy = dummy;
    577              // negate slave chip select
    578              AT91C_BASE_PIOA->PIO_SODR = SPI_nCS; // faster than PIO_Set(pinNss);
   \                     ??Write_6131_7:
   \   000000D4   ........           LDR.W    R7,??DataTable13  ;; 0x400e0c30
   \   000000D8   5FF4803C           MOVS     R12,#+65536
   \   000000DC   C7F800C0           STR      R12,[R7, #+0]
    579          	spi_busy = 0;
   \   000000E0   ........           LDR.W    R7,??DataTable15_1
   \   000000E4   5FF0000C           MOVS     R12,#+0
   \   000000E8   87F800C0           STRB     R12,[R7, #+0]
    580              // re-enable interrupts, if IRQs managed at this level
    581          	if(irq_mgmt) __enable_interrupt();				 
   \   000000EC   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000EE   002A               CMP      R2,#+0
   \   000000F0   00D0               BEQ.N    ??Write_6131_15
   \   000000F2   62B6               CPSIE    I
    582          
    583          	return;
   \                     ??Write_6131_15:
   \   000000F4   F0BC               POP      {R4-R7}
   \   000000F6   7047               BX       LR               ;; return
    584          }
    585          
    586          
    587          
    588          
    589          // 	This function reads one to 256 sequential 16-bit words beginning at the starting 
    590          //	address indicated by the address value in the HI-6131 Memory Address Pointer register. 
    591          //	The function transmits an 8-bit op code, then reads data words a byte at a time.
    592          //	Words read are stored in global read_data[], starting at read_data[0].
    593          //
    594          //	Either the calling routine issues __disable_interrupt() before calling this function, 
    595          //  or the __disable_interrupt() and __enable_interrupt() calls are performed here. This 
    596          //  choice determines where IRQ recognition	occurs. When series of spi function calls are 
    597          //  chained to perform larger tasks, it may be desirable to disable/enable IRQs at the 
    598          //  higher level (param irq_mgmt = 0)
    599          //
    600          //	Note: Because this function may perform long N-word transfers, it is typically 
    601          //	used with parameter irq_mgmt = 1. In this mode, IRQs are disabled during spi intervals,
    602          //	but IRQs are periodically enabled between whole word transfers. The function will 
    603          //	recover from vectored spi-using interrupts (recognized only between read data words) 
    604          //	when these IRQs use the demonstrated "spi_busy spi_irq" handshake. Such IRQs are 
    605          //	detected and a new SPI op code is issued to permit this function to continue to completion.
    606          // 
    607          // 	param 	number_of_words is the array size 
    608          //  param	irq_mgmt. if zero, the calling routine manages irq enable/disable.
    609          //	                  if non-zero, this function locally calls __disable_interrupt() 
    610          //                    and __enable_interrupt().
    611          //
    612          //	Note: This function is designed to recover from a vectored interrupt (recognized only
    613          //	between read data words) that disturbs the SPI operation. A new SPI op code is issued
    614          //	to permit the operation to continue to completion.
    615          //
    616          //		The MCU's SPI mode register is written with option WDRBT = 0 so Master
    617          //		can initialize a new transfer whether/not SPI RxData register has unread
    618          //		data. To speed up SPI operations by taking advantnage of the WDRBT
    619          //		option, several statements are commented-out in the function below.
    620          //

   \                                 In section .text, align 2, keep-with-next
    621          void Read_6131(unsigned short number_of_words, unsigned char irq_mgmt) {
   \                     Read_6131:
   \   00000000   F8B4               PUSH     {R3-R7}
    622          
    623              AT91S_SPI *spi = BOARD_6131_SPI_BASE;
   \   00000002   ........           LDR.W    R2,??DataTable12  ;; 0x40008000
    624              volatile unsigned char bufferRX[2];
    625              unsigned short dummy;
    626              unsigned short i,j;
    627                  
    628              // disable interrupts, if IRQs managed at this level
    629              if(irq_mgmt)  __disable_interrupt();	 
   \   00000006   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0029               CMP      R1,#+0
   \   0000000A   00D0               BEQ.N    ??Read_6131_0
   \   0000000C   72B6               CPSID    I
    630              // variable tested by vectored interrupt routine
    631              spi_busy = 1;				         
   \                     ??Read_6131_0:
   \   0000000E   ........           LDR.W    R6,??DataTable15_1
   \   00000012   0127               MOVS     R7,#+1
   \   00000014   3770               STRB     R7,[R6, #+0]
    632              // Assert SPI chip select
    633              AT91C_BASE_PIOA->PIO_CODR = SPI_nCS; // faster than PIO_Clear(pinNss); 
   \   00000016   ........           LDR.W    R6,??DataTable12_1  ;; 0x400e0c34
   \   0000001A   5FF48037           MOVS     R7,#+65536
   \   0000001E   3760               STR      R7,[R6, #+0]
    634              // Wait for TDR and shifter = empty
    635              while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
   \                     ??Read_6131_1:
   \   00000020   1669               LDR      R6,[R2, #+16]
   \   00000022   B605               LSLS     R6,R6,#+22
   \   00000024   FCD5               BPL.N    ??Read_6131_1
    636              // Send SPI op code 0x40 to read using existing pointer value
    637              spi->SPI_TDR = 0x40 | SPI_PCS(BOARD_6131_NPCS);
   \   00000026   ........           LDR.W    R6,??DataTable13_2  ;; 0xe0040
   \   0000002A   D660               STR      R6,[R2, #+12]
    638              // Wait for TDRE flag (Tx Data Register Empty)
    639              while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Read_6131_2:
   \   0000002C   1669               LDR      R6,[R2, #+16]
   \   0000002E   B607               LSLS     R6,R6,#+30
   \   00000030   FCD5               BPL.N    ??Read_6131_2
    640              // Wait for RDRF flag (Rx Data Register Full)
    641              while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
   \                     ??Read_6131_3:
   \   00000032   1669               LDR      R6,[R2, #+16]
   \   00000034   F607               LSLS     R6,R6,#+31
   \   00000036   FCD5               BPL.N    ??Read_6131_3
    642              // Read and discard received data char in Rx buffer
    643              dummy = spi->SPI_RDR & 0xFFFF;
   \   00000038   9668               LDR      R6,[R2, #+8]
   \   0000003A   3300               MOVS     R3,R6
    644                  
    645              for (i = 0; i < number_of_words; i++) {
   \   0000003C   0026               MOVS     R6,#+0
   \   0000003E   3400               MOVS     R4,R6
   \                     ??Read_6131_4:
   \   00000040   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000042   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000044   8442               CMP      R4,R0
   \   00000046   22D2               BCS.N    ??Read_6131_5
    646          
    647          	if(irq_mgmt) __enable_interrupt();
   \   00000048   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000004A   0029               CMP      R1,#+0
   \   0000004C   00D0               BEQ.N    ??Read_6131_6
   \   0000004E   62B6               CPSIE    I
    648          	// Before reading the next word, momentarily enable IRQs...
    649          	// A pending IRQ that occurred since last __disable_interrupt() will be recognized here.
    650          	// Its ISR (int.svc routine) will execute, probably using SPI, disrupting 
    651          	// our multi-word transfer. The ISR sets the spi_irq flag, then execution 
    652          	// resumes here, at this next __disable_interrupt() call...   
    653          	if(irq_mgmt) __disable_interrupt();
   \                     ??Read_6131_6:
   \   00000050   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000052   0029               CMP      R1,#+0
   \   00000054   00D0               BEQ.N    ??Read_6131_7
   \   00000056   72B6               CPSID    I
    654          
    655          	if(spi_irq) {
   \                     ??Read_6131_7:
   \   00000058   ........           LDR.W    R6,??DataTable15_2
   \   0000005C   3678               LDRB     R6,[R6, #+0]
   \   0000005E   002E               CMP      R6,#+0
   \   00000060   13D0               BEQ.N    ??Read_6131_8
    656          	    // the multi-word transfer was disturbed, but the interrupt's
    657          	    // ISR should have used a different Memory Address Pointer and
    658                      // reenabled the Memory Address Pointer we were using, so our
    659          	    // MAP points to the next word to be read. Issue a new SPI 
    660          	    // op code to resume a multi-word read process, starting at the 
    661          	    // RAM location addressed by the Memory Address Pointer value. 
    662          	    // Assert SPI chip select
    663          	    AT91C_BASE_PIOA->PIO_CODR = SPI_nCS; // faster than PIO_Clear(pinNss); 
   \   00000062   ........           LDR.W    R6,??DataTable12_1  ;; 0x400e0c34
   \   00000066   5FF48037           MOVS     R7,#+65536
   \   0000006A   3760               STR      R7,[R6, #+0]
    664          	    // Wait for TDR and shifter = empty
    665          	    // while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
    666          	    // Send SPI op code to resume reading using existing pointer value
    667          	    spi->SPI_TDR = 0x40 | SPI_PCS(BOARD_6131_NPCS);
   \   0000006C   ........           LDR.W    R6,??DataTable13_2  ;; 0xe0040
   \   00000070   D660               STR      R6,[R2, #+12]
    668          	    // Wait for TDRE flag (Tx Data Register Empty)
    669          	    while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Read_6131_9:
   \   00000072   1669               LDR      R6,[R2, #+16]
   \   00000074   B607               LSLS     R6,R6,#+30
   \   00000076   FCD5               BPL.N    ??Read_6131_9
    670          	    // Wait for RDRF flag (Rx Data Register Full)
    671          	    while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
   \                     ??Read_6131_10:
   \   00000078   1669               LDR      R6,[R2, #+16]
   \   0000007A   F607               LSLS     R6,R6,#+31
   \   0000007C   FCD5               BPL.N    ??Read_6131_10
    672          	    // Read and discard received data char in Rx buffer
    673          	    dummy = spi->SPI_RDR & 0xFFFF;
   \   0000007E   9668               LDR      R6,[R2, #+8]
   \   00000080   3300               MOVS     R3,R6
    674                      // prevent warning: variable dummy was set but never used
    675                      // dummy = dummy;
    676          	    spi_irq = 0;
   \   00000082   ........           LDR.W    R6,??DataTable15_2
   \   00000086   0027               MOVS     R7,#+0
   \   00000088   3770               STRB     R7,[R6, #+0]
    677          	}
    678              }
   \                     ??Read_6131_8:
   \   0000008A   641C               ADDS     R4,R4,#+1
   \   0000008C   D8E7               B.N      ??Read_6131_4
    679              // receive 2 bytes RAM data, transmit 2 dummy data bytes
    680              for (j = 0; j < 2; i++) {
   \                     ??Read_6131_5:
   \   0000008E   0026               MOVS     R6,#+0
   \   00000090   3500               MOVS     R5,R6
   \                     ??Read_6131_11:
   \   00000092   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000094   022D               CMP      R5,#+2
   \   00000096   2AD2               BCS.N    ??Read_6131_12
    681                  // Wait for TDR and shifter = empty
    682                  // while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
    683                  // transmit dummy data byte 0x00 to start receive
    684                  spi->SPI_TDR = 0x00 | SPI_PCS(BOARD_6131_NPCS);
   \   00000098   5FF46026           MOVS     R6,#+917504
   \   0000009C   D660               STR      R6,[R2, #+12]
    685                  // Wait for TDRE flag (Tx Data Register Empty)
    686                  while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Read_6131_13:
   \   0000009E   1669               LDR      R6,[R2, #+16]
   \   000000A0   B607               LSLS     R6,R6,#+30
   \   000000A2   FCD5               BPL.N    ??Read_6131_13
    687                  // Wait for RDRF flag (Rx Data Register Full)
    688                  while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
   \                     ??Read_6131_14:
   \   000000A4   1669               LDR      R6,[R2, #+16]
   \   000000A6   F607               LSLS     R6,R6,#+31
   \   000000A8   FCD5               BPL.N    ??Read_6131_14
    689                  // without this next delay, the ARM SPI reads wrong value in RDR!
    690                  // I see good data shifting out from HI-6131 but RxData register value is wrong
    691                  for (dummy=0; dummy<2; dummy++);
   \   000000AA   0026               MOVS     R6,#+0
   \   000000AC   3300               MOVS     R3,R6
   \                     ??Read_6131_15:
   \   000000AE   9BB2               UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000B0   022B               CMP      R3,#+2
   \   000000B2   01D2               BCS.N    ??Read_6131_16
   \   000000B4   5B1C               ADDS     R3,R3,#+1
   \   000000B6   FAE7               B.N      ??Read_6131_15
    692                  // Read received data char in Rx buffer
    693                  bufferRX[j] = spi->SPI_RDR & 0xFFFF;
   \                     ??Read_6131_16:
   \   000000B8   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000BA   00AE               ADD      R6,SP,#+0
   \   000000BC   9768               LDR      R7,[R2, #+8]
   \   000000BE   AF55               STRB     R7,[R5, R6]
    694          		
    695                  // merge 2 data bytes into 16-bit value and store
    696                  read_data[i] =  (unsigned int)bufferRX[0] << 8;
   \   000000C0   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000C2   ........           LDR.W    R6,??DataTable15_4
   \   000000C6   9DF80070           LDRB     R7,[SP, #+0]
   \   000000CA   3F02               LSLS     R7,R7,#+8
   \   000000CC   26F81470           STRH     R7,[R6, R4, LSL #+1]
    697                  read_data[i] |= (unsigned int)bufferRX[1];
   \   000000D0   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000D2   ........           LDR.W    R6,??DataTable15_4
   \   000000D6   36F81460           LDRH     R6,[R6, R4, LSL #+1]
   \   000000DA   9DF80170           LDRB     R7,[SP, #+1]
   \   000000DE   3E43               ORRS     R6,R7,R6
   \   000000E0   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000E2   ........           LDR.W    R7,??DataTable15_4
   \   000000E6   27F81460           STRH     R6,[R7, R4, LSL #+1]
    698              }
   \   000000EA   641C               ADDS     R4,R4,#+1
   \   000000EC   D1E7               B.N      ??Read_6131_11
    699              spi_busy = 0;
   \                     ??Read_6131_12:
   \   000000EE   ........           LDR.W    R6,??DataTable15_1
   \   000000F2   0027               MOVS     R7,#+0
   \   000000F4   3770               STRB     R7,[R6, #+0]
    700              // negate slave chip select
    701              AT91C_BASE_PIOA->PIO_SODR = SPI_nCS; // faster than PIO_Set(pinNss);
   \   000000F6   ........           LDR.W    R6,??DataTable15  ;; 0x400e0c30
   \   000000FA   5FF48037           MOVS     R7,#+65536
   \   000000FE   3760               STR      R7,[R6, #+0]
    702              // re-enable interrupts, if IRQs managed at this level 
    703              if(irq_mgmt)  __enable_interrupt();	
   \   00000100   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000102   0029               CMP      R1,#+0
   \   00000104   00D0               BEQ.N    ??Read_6131_17
   \   00000106   62B6               CPSIE    I
    704          }
   \                     ??Read_6131_17:
   \   00000108   F1BC               POP      {R0,R4-R7}
   \   0000010A   7047               BX       LR               ;; return
    705          
    706          
    707          
    708          // 	After changing the Memory Address Pointer register in the HI-6131, this function writes one 
    709          //	or more 16-bit words into sequential RAM. Before writing data, the pre-existing pointer value 
    710          //	can be first increased by 0, 1 or 2, based on a passed parameter. Once adjusted, the value
    711          //	in the newly addressed RAM location (assumed to be a data buffer address) is itself copied 
    712          //	to the Memory Address Pointer. Then a multi-word write sequence begins and continues until the 
    713          //	specified number of words is written.
    714          //
    715          //	Design Intent: This function is used imediately after reading an RT Descriptor Table Control Word. 
    716          //	Because of auto-increment, the Memory Address Pointer points to the word following the Control 
    717          //	Word. Based on Control Word value tests performed before this function call, the program needs 
    718          //	to write data to one of the receive data buffers addressed by the three locations following the 
    719          //	Control Word. The choice of parameter "inc_pointer_first" selects 1 of 3 pointers to be copied
    720          //	to the Memory Address Pointer (reg 15) then "N" data words are written to the selected buffer:
    721          //
    722          //
    723          //                      Descriptor Block     value of parameter   copied to Memory Address
    724          //                      (4 words)            inc_pointer_first    Pointer before writing begins
    725          //                      ==================   =================    =============================
    726          //	THIS WORD READ -->  Control Word                    
    727          //	JUST BEFORE         Data Pointer A              0              Data Buffer A addr
    728          //      FUNCTION CALL       Data Pointer B              1              Data Buffer B addr
    729          //                          Broadcast Data Ptr          2              Broadcast Data Buffer addr
    730          //
    731          //
    732          //
    733          //	Note: Because this function may perform long N-word transfers, it is typically 
    734          //	used with parameter irq_mgmt = 1. In this mode, IRQs are disabled during spi intervals,
    735          //	but IRQs are periodically enabled between whole word transfers. The function will 
    736          //	recover from vectored spi-using interrupts (recognized only between written data words) 
    737          //	when these IRQs use the demonstrated "spi_busy spi_irq" handshake. Such IRQs are 
    738          //	detected and a new SPI op code is issued to permit this function to continue to completion.
    739          // 
    740          // 	param 	inc_pointer_first specifies pointer adjust value (0,1 or 2 only) before writing
    741          //      param	irq_mgmt. if zero, the calling routine manages irq enable/disable.
    742          //	                  if non-zero, this function calls __disable_interrupt() and __enable_interrupt() locally.
    743          //
    744          //	The MCU's SPI mode register is written with option WDRBT = 0 so Master
    745          //	can initialize a new transfer whether/not SPI RxData register has unread
    746          //	data. To speed up SPI operations by taking advantnage of the WDRBT
    747          //	option, several statements are commented-out in the function below.
    748          //

   \                                 In section .text, align 2, keep-with-next
    749          unsigned char Write_6131_Buffer(unsigned short write_data[], unsigned char inc_pointer_first, unsigned char irq_mgmt) {
   \                     Write_6131_Buffer:
   \   00000000   F0B4               PUSH     {R4-R7}
   \   00000002   0300               MOVS     R3,R0
    750          
    751              AT91S_SPI *spi = BOARD_6131_SPI_BASE;
   \   00000004   ........           LDR.W    R4,??DataTable12  ;; 0x40008000
    752              unsigned short i, len;
    753              //unsigned short dummy;
    754          
    755              // inc_pointer_first parameter determines SPI op code value, must be 0,1 or 2 only
    756              if(inc_pointer_first > 2) return ('F');
   \   00000008   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0329               CMP      R1,#+3
   \   0000000C   01D3               BCC.N    ??Write_6131_Buffer_0
   \   0000000E   4620               MOVS     R0,#+70
   \   00000010   63E0               B.N      ??Write_6131_Buffer_1
    757              // op code will be 0xE8, 0xF0 or 0xF8
    758              i = 0xE8 + (inc_pointer_first << 3);
   \                     ??Write_6131_Buffer_0:
   \   00000012   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   C800               LSLS     R0,R1,#+3
   \   00000016   E830               ADDS     R0,R0,#+232
   \   00000018   0500               MOVS     R5,R0
    759          
    760              // disable interrupts, if IRQs managed at this level
    761              if(irq_mgmt)  __disable_interrupt();	 
   \   0000001A   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001C   002A               CMP      R2,#+0
   \   0000001E   00D0               BEQ.N    ??Write_6131_Buffer_2
   \   00000020   72B6               CPSID    I
    762              // variable tested by vectored interrupt routine
    763              spi_busy = 1;				         
   \                     ??Write_6131_Buffer_2:
   \   00000022   ........           LDR.W    R0,??DataTable15_1
   \   00000026   0127               MOVS     R7,#+1
   \   00000028   0770               STRB     R7,[R0, #+0]
    764              // Assert SPI chip select
    765              AT91C_BASE_PIOA->PIO_CODR = SPI_nCS; // faster than PIO_Clear(pinNss); 
   \   0000002A   ........           LDR.W    R0,??DataTable12_1  ;; 0x400e0c34
   \   0000002E   5FF48037           MOVS     R7,#+65536
   \   00000032   0760               STR      R7,[R0, #+0]
    766              // Wait for TDR and shifter = empty
    767              while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
   \                     ??Write_6131_Buffer_3:
   \   00000034   2069               LDR      R0,[R4, #+16]
   \   00000036   8005               LSLS     R0,R0,#+22
   \   00000038   FCD5               BPL.N    ??Write_6131_Buffer_3
    768              // Send SPI op code i to write using adjusted pointer value
    769              spi->SPI_TDR = i | SPI_PCS(BOARD_6131_NPCS);
   \   0000003A   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003C   55F46020           ORRS     R0,R5,#0xE0000
   \   00000040   E060               STR      R0,[R4, #+12]
    770              // Wait for TDRE flag (Tx Data Register Empty)
    771              while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Write_6131_Buffer_4:
   \   00000042   2069               LDR      R0,[R4, #+16]
   \   00000044   8007               LSLS     R0,R0,#+30
   \   00000046   FCD5               BPL.N    ??Write_6131_Buffer_4
    772              // Wait for RDRF flag (Rx Data Register Full)
    773              // while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
    774              // Read and discard received data char in Rx buffer
    775              // dummy = spi->SPI_RDR & 0xFFFF;        
    776              len = sizeof(write_data);
   \   00000048   0420               MOVS     R0,#+4
   \   0000004A   0600               MOVS     R6,R0
    777              
    778              for (i = 0; i < len; i++) {
   \   0000004C   0020               MOVS     R0,#+0
   \   0000004E   0500               MOVS     R5,R0
   \                     ??Write_6131_Buffer_5:
   \   00000050   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000052   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000054   B542               CMP      R5,R6
   \   00000056   32D2               BCS.N    ??Write_6131_Buffer_6
    779          
    780          	if(irq_mgmt) __enable_interrupt();
   \   00000058   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000005A   002A               CMP      R2,#+0
   \   0000005C   00D0               BEQ.N    ??Write_6131_Buffer_7
   \   0000005E   62B6               CPSIE    I
    781          	// Before writing the next word, momentarily enable IRQs...
    782          	// A pending IRQ that occurred since last __disable_interrupt() will be 
    783                  // recognized here. Its ISR (int.svc routine) will execute, probably 
    784                  // using SPI, disrupting our multi-word transfer. The ISR sets the 
    785                  // spi_irq flag, then execution resumes at this __disable_interrupt() call...   
    786          	if(irq_mgmt) __disable_interrupt();
   \                     ??Write_6131_Buffer_7:
   \   00000060   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000062   002A               CMP      R2,#+0
   \   00000064   00D0               BEQ.N    ??Write_6131_Buffer_8
   \   00000066   72B6               CPSID    I
    787          
    788          	if(spi_irq) {
   \                     ??Write_6131_Buffer_8:
   \   00000068   ........           LDR.W    R0,??DataTable15_2
   \   0000006C   0078               LDRB     R0,[R0, #+0]
   \   0000006E   0028               CMP      R0,#+0
   \   00000070   0ED0               BEQ.N    ??Write_6131_Buffer_9
    789          		// the multi-word transfer was disturbed, but the interrupt's
    790          		// ISR should have used a different Memory Address Pointer and
    791                          // reenabled the Memory Address Pointer we were using, so our
    792          		// MAP points to the next word to be write. Issue a new SPI 
    793          		// op code to resume a multi-word write process, starting at the 
    794          		// RAM location addressed by the Memory Address Pointer value. 
    795          		// Assert SPI chip select
    796          		AT91C_BASE_PIOA->PIO_CODR = SPI_nCS; // faster than PIO_Clear(pinNss); 
   \   00000072   ........           LDR.W    R0,??DataTable12_1  ;; 0x400e0c34
   \   00000076   5FF48037           MOVS     R7,#+65536
   \   0000007A   0760               STR      R7,[R0, #+0]
    797          		// Wait for TDR and shifter = empty
    798          		// while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
    799          		// Send SPI op code to resume writing using existing pointer value
    800          		spi->SPI_TDR = 0xC0 | SPI_PCS(BOARD_6131_NPCS);
   \   0000007C   ........           LDR.W    R0,??DataTable13_1  ;; 0xe00c0
   \   00000080   E060               STR      R0,[R4, #+12]
    801          		// Wait for TDRE flag (Tx Data Register Empty)
    802          		while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Write_6131_Buffer_10:
   \   00000082   2069               LDR      R0,[R4, #+16]
   \   00000084   8007               LSLS     R0,R0,#+30
   \   00000086   FCD5               BPL.N    ??Write_6131_Buffer_10
    803          		// Wait for RDRF flag (Rx Data Register Full)
    804          		// while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
    805          		// Read and discard received data char in Rx buffer
    806          		// dummy = spi->SPI_RDR & 0xFFFF;
    807          		spi_irq = 0;
   \   00000088   ........           LDR.W    R0,??DataTable15_2
   \   0000008C   0027               MOVS     R7,#+0
   \   0000008E   0770               STRB     R7,[R0, #+0]
    808          	}
    809                  // transmit next data word a byte at a time
    810                          
    811                  // Wait for TDR and shifter = empty
    812                  // while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
    813                  // transmit upper byte
    814                  spi->SPI_TDR = ((char)(write_data[i] >> 8)) | SPI_PCS(BOARD_6131_NPCS);
   \                     ??Write_6131_Buffer_9:
   \   00000090   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000092   33F81500           LDRH     R0,[R3, R5, LSL #+1]
   \   00000096   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000098   000A               LSRS     R0,R0,#+8
   \   0000009A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009C   50F46020           ORRS     R0,R0,#0xE0000
   \   000000A0   E060               STR      R0,[R4, #+12]
    815                  // Wait for TDRE flag (Tx Data Register Empty)
    816                  while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Write_6131_Buffer_11:
   \   000000A2   2069               LDR      R0,[R4, #+16]
   \   000000A4   8007               LSLS     R0,R0,#+30
   \   000000A6   FCD5               BPL.N    ??Write_6131_Buffer_11
    817                  // Wait for RDRF flag (Rx Data Register Full)
    818                  // while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
    819                  // Read and discard received data char in Rx buffer
    820                  // dummy = spi->SPI_RDR & 0xFFFF;
    821              
    822                  // Wait for TDR and shifter = empty
    823                  // while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
    824                  // transmit lower byte
    825                  spi->SPI_TDR = ((char)(write_data[i])) | SPI_PCS(BOARD_6131_NPCS);
   \   000000A8   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000AA   13F81500           LDRB     R0,[R3, R5, LSL #+1]
   \   000000AE   50F46020           ORRS     R0,R0,#0xE0000
   \   000000B2   E060               STR      R0,[R4, #+12]
    826                  // Wait for TDRE flag (Tx Data Register Empty)
    827                  while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Write_6131_Buffer_12:
   \   000000B4   2069               LDR      R0,[R4, #+16]
   \   000000B6   8007               LSLS     R0,R0,#+30
   \   000000B8   FCD5               BPL.N    ??Write_6131_Buffer_12
    828                  // Wait for RDRF flag (Rx Data Register Full)
    829                  // while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
    830                  // Read and discard received data char in Rx buffer
    831                  // dummy = spi->SPI_RDR & 0xFFFF;                            
    832              }
   \   000000BA   6D1C               ADDS     R5,R5,#+1
   \   000000BC   C8E7               B.N      ??Write_6131_Buffer_5
    833              // prevent warning: variable dummy was set but never used
    834              // dummy = dummy;
    835              spi_busy = 0;
   \                     ??Write_6131_Buffer_6:
   \   000000BE   ........           LDR.W    R0,??DataTable15_1
   \   000000C2   0027               MOVS     R7,#+0
   \   000000C4   0770               STRB     R7,[R0, #+0]
    836              // negate slave chip select
    837              AT91C_BASE_PIOA->PIO_SODR = SPI_nCS; // faster than PIO_Set(pinNss);
   \   000000C6   ........           LDR.W    R0,??DataTable15  ;; 0x400e0c30
   \   000000CA   5FF48037           MOVS     R7,#+65536
   \   000000CE   0760               STR      R7,[R0, #+0]
    838              // re-enable interrupts, if IRQs managed at this level 
    839              if(irq_mgmt)  __enable_interrupt();	
   \   000000D0   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000D2   002A               CMP      R2,#+0
   \   000000D4   00D0               BEQ.N    ??Write_6131_Buffer_13
   \   000000D6   62B6               CPSIE    I
    840              return ('P');
   \                     ??Write_6131_Buffer_13:
   \   000000D8   5020               MOVS     R0,#+80
   \                     ??Write_6131_Buffer_1:
   \   000000DA   F0BC               POP      {R4-R7}
   \   000000DC   7047               BX       LR               ;; return
    841          }
    842          
    843          
    844          
    845          // 	After changing the Memory Address Pointer register in the HI-6131, this function reads one 
    846          //	or more 16-bit words from sequential RAM. Before reading data, the pre-existing pointer value 
    847          //	can be first increased by 0, 1 or 2, based on a passed parameter. Once adjusted, the value
    848          //	in the newly addressed RAM location (assumed to be a data buffer address) is itself copied 
    849          //	to the Memory Address Pointer. Then a multi-word read sequence begins and continues until the 
    850          //	specified number of words is received.
    851          //
    852          //	Design Intent: This function is used imediately after reading a Descriptor Table Control Word. 
    853          //	Because of auto-increment, the Memory Address Pointer points to the word following the Control 
    854          //	Word. Based on Control Word value tests performed before this function call, the program needs 
    855          //	to read data from one of the receive data buffers addressed by the three locations following the 
    856          //	Control Word. The choice of parameter "inc_pointer_first" selects 1 of 3 pointers to be copied
    857          //	to the Memory Address Pointer (reg 15) then "N" data words are read from the selected buffer:
    858          //
    859          //
    860          //                      Descriptor Block     value of parameter   copied to Memory Address
    861          //                      (4 words)            inc_pointer_first    Pointer before reading begins
    862          //                      ==================   =================    =============================
    863          //	THIS WORD READ -->  Control Word                    
    864          //	JUST BEFORE         Data Pointer A              0              Data Buffer A addr
    865          //      FUNCTION CALL       Data Pointer B              1              Data Buffer B addr
    866          //                          Broadcast Data Ptr          2              Broadcast Data Buffer addr
    867          //
    868          //
    869          //
    870          //	Note: Because this function may perform long N-word transfers, it is typically 
    871          //	used with parameter irq_mgmt = 1. In this mode, IRQs are disabled during spi intervals,
    872          //	but IRQs are periodically enabled between whole word transfers. The function will 
    873          //	recover from vectored spi-using interrupts (recognized only between read data words) 
    874          //	when these IRQs use the demonstrated "spi_busy spi_irq" handshake. Such IRQs are 
    875          //	detected and a new SPI op code is issued to permit this function to continue to completion.
    876          // 
    877          // 	param 	number_of_words is the array size 
    878          // 	param 	inc_pointer_first specifies pointer adjust value (0,1 or 2 only) before reading
    879          //      param	irq_mgmt. if zero, the calling routine manages irq enable/disable.
    880          //	                  if non-zero, this function calls __disable_interrupt() and __enable_interrupt() locally.
    881          //
    882          //	The MCU's SPI mode register is written with option WDRBT = 0 so Master
    883          //	can initialize a new transfer whether/not SPI RxData register has unread
    884          //	data. To speed up SPI operations by taking advantnage of the WDRBT
    885          //	option, several statements are commented-out in the function below.
    886          //

   \                                 In section .text, align 2, keep-with-next
    887          unsigned char Read_6131_Buffer(unsigned short number_of_words, unsigned char inc_pointer_first, unsigned char irq_mgmt) {
   \                     Read_6131_Buffer:
   \   00000000   F8B4               PUSH     {R3-R7}
   \   00000002   0300               MOVS     R3,R0
    888          
    889              AT91S_SPI *spi = BOARD_6131_SPI_BASE;
   \   00000004   ........           LDR.W    R4,??DataTable12  ;; 0x40008000
    890              volatile unsigned char bufferRX[2];
    891              unsigned short i, j;
    892              unsigned short dummy;
    893          
    894              // inc_pointer_first parameter determines SPI op code value, must be 0,1 or 2 only
    895              if(inc_pointer_first > 2) return ('F');
   \   00000008   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0329               CMP      R1,#+3
   \   0000000C   01D3               BCC.N    ??Read_6131_Buffer_0
   \   0000000E   4620               MOVS     R0,#+70
   \   00000010   96E0               B.N      ??Read_6131_Buffer_1
    896              // op code will be 0x68, 0x70 or 0x78
    897              i = 0x68 + (inc_pointer_first << 3);
   \                     ??Read_6131_Buffer_0:
   \   00000012   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   C800               LSLS     R0,R1,#+3
   \   00000016   6830               ADDS     R0,R0,#+104
   \   00000018   0500               MOVS     R5,R0
    898          
    899              // disable interrupts, if IRQs managed at this level
    900              if(irq_mgmt)  __disable_interrupt();	 
   \   0000001A   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001C   002A               CMP      R2,#+0
   \   0000001E   00D0               BEQ.N    ??Read_6131_Buffer_2
   \   00000020   72B6               CPSID    I
    901              // variable tested by vectored interrupt routine
    902              spi_busy = 1;				         
   \                     ??Read_6131_Buffer_2:
   \   00000022   ........           LDR.W    R0,??DataTable15_1
   \   00000026   5FF0010C           MOVS     R12,#+1
   \   0000002A   80F800C0           STRB     R12,[R0, #+0]
    903              // Assert SPI chip select
    904              AT91C_BASE_PIOA->PIO_CODR = SPI_nCS; // faster than PIO_Clear(pinNss); 
   \   0000002E   ........           LDR.W    R0,??DataTable12_1  ;; 0x400e0c34
   \   00000032   5FF4803C           MOVS     R12,#+65536
   \   00000036   C0F800C0           STR      R12,[R0, #+0]
    905              // Wait for TDR and shifter = empty
    906              while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
   \                     ??Read_6131_Buffer_3:
   \   0000003A   2069               LDR      R0,[R4, #+16]
   \   0000003C   8005               LSLS     R0,R0,#+22
   \   0000003E   FCD5               BPL.N    ??Read_6131_Buffer_3
    907              // Send SPI op code i to read using adjusted pointer value
    908              spi->SPI_TDR = i | SPI_PCS(BOARD_6131_NPCS);
   \   00000040   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000042   55F46020           ORRS     R0,R5,#0xE0000
   \   00000046   E060               STR      R0,[R4, #+12]
    909              // Wait for TDRE flag (Tx Data Register Empty)
    910              while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Read_6131_Buffer_4:
   \   00000048   2069               LDR      R0,[R4, #+16]
   \   0000004A   8007               LSLS     R0,R0,#+30
   \   0000004C   FCD5               BPL.N    ??Read_6131_Buffer_4
    911              // Wait for RDRF flag (Rx Data Register Full)
    912              while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
   \                     ??Read_6131_Buffer_5:
   \   0000004E   2069               LDR      R0,[R4, #+16]
   \   00000050   C007               LSLS     R0,R0,#+31
   \   00000052   FCD5               BPL.N    ??Read_6131_Buffer_5
    913              // Read and discard received data char in Rx buffer
    914              dummy = spi->SPI_RDR & 0xFFFF;        
   \   00000054   A068               LDR      R0,[R4, #+8]
   \   00000056   0700               MOVS     R7,R0
    915          
    916              for ( i = 0; i < number_of_words; i++ )	{
   \   00000058   0020               MOVS     R0,#+0
   \   0000005A   0500               MOVS     R5,R0
   \                     ??Read_6131_Buffer_6:
   \   0000005C   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000005E   9BB2               UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000060   9D42               CMP      R5,R3
   \   00000062   5CD2               BCS.N    ??Read_6131_Buffer_7
    917          	__enable_interrupt();
   \   00000064   62B6               CPSIE    I
    918          	// Before writing the next word, momentarily enable IRQs...
    919          	// A pending IRQ that occurred since last __disable_interrupt() will be 
    920                  // recognized here. Its ISR (int.svc routine) will execute, probably 
    921                  // using SPI, disrupting our multi-word transfer. The ISR sets the 
    922                  // spi_irq flag, then execution resumes at this __disable_interrupt() call...   
    923          	if(irq_mgmt) __disable_interrupt();
   \   00000066   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000068   002A               CMP      R2,#+0
   \   0000006A   00D0               BEQ.N    ??Read_6131_Buffer_8
   \   0000006C   72B6               CPSID    I
    924          
    925          	if(spi_irq) {
   \                     ??Read_6131_Buffer_8:
   \   0000006E   ........           LDR.W    R0,??DataTable15_2
   \   00000072   0078               LDRB     R0,[R0, #+0]
   \   00000074   0028               CMP      R0,#+0
   \   00000076   19D0               BEQ.N    ??Read_6131_Buffer_9
    926          		// the multi-word transfer was disturbed, but the interrupt's
    927          		// ISR should have used a different Memory Address Pointer and
    928                          // reenabled the Memory Address Pointer we were using, so our
    929          		// MAP points to the next word to be write. Issue a new SPI 
    930          		// op code to resume a multi-word write process, starting at the 
    931          		// RAM location addressed by the Memory Address Pointer value. 
    932          		// Assert SPI chip select
    933          		AT91C_BASE_PIOA->PIO_CODR = SPI_nCS; // faster than PIO_Clear(pinNss); 
   \   00000078   ........           LDR.W    R0,??DataTable12_1  ;; 0x400e0c34
   \   0000007C   5FF4803C           MOVS     R12,#+65536
   \   00000080   C0F800C0           STR      R12,[R0, #+0]
    934          		// Wait for TDR and shifter = empty
    935          		while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
   \                     ??Read_6131_Buffer_10:
   \   00000084   2069               LDR      R0,[R4, #+16]
   \   00000086   8005               LSLS     R0,R0,#+22
   \   00000088   FCD5               BPL.N    ??Read_6131_Buffer_10
    936          		// Send SPI op code 0x40 to resume reading using existing pointer value
    937          		spi->SPI_TDR = 0x40 | SPI_PCS(BOARD_6131_NPCS);
   \   0000008A   ........           LDR.W    R0,??DataTable13_2  ;; 0xe0040
   \   0000008E   E060               STR      R0,[R4, #+12]
    938          		// Wait for TDRE flag (Tx Data Register Empty)
    939          		while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Read_6131_Buffer_11:
   \   00000090   2069               LDR      R0,[R4, #+16]
   \   00000092   8007               LSLS     R0,R0,#+30
   \   00000094   FCD5               BPL.N    ??Read_6131_Buffer_11
    940          		// Wait for RDRF flag (Rx Data Register Full)
    941          		while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
   \                     ??Read_6131_Buffer_12:
   \   00000096   2069               LDR      R0,[R4, #+16]
   \   00000098   C007               LSLS     R0,R0,#+31
   \   0000009A   FCD5               BPL.N    ??Read_6131_Buffer_12
    942          		// Read and discard received data char in Rx buffer
    943          		dummy = spi->SPI_RDR & 0xFFFF;
   \   0000009C   A068               LDR      R0,[R4, #+8]
   \   0000009E   0700               MOVS     R7,R0
    944          		spi_irq = 0;
   \   000000A0   ........           LDR.W    R0,??DataTable15_2
   \   000000A4   5FF0000C           MOVS     R12,#+0
   \   000000A8   80F800C0           STRB     R12,[R0, #+0]
    945                  }
    946          	// Read the next word 
    947                  // receive 2 bytes RAM data, transmit 2 dummy data bytes
    948                  for (j = 0; j < 2; i++) {
   \                     ??Read_6131_Buffer_9:
   \   000000AC   0020               MOVS     R0,#+0
   \   000000AE   0600               MOVS     R6,R0
   \                     ??Read_6131_Buffer_13:
   \   000000B0   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000B2   022E               CMP      R6,#+2
   \   000000B4   1AD2               BCS.N    ??Read_6131_Buffer_14
    949                        // Wait for TDR and shifter = empty
    950                        while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
   \                     ??Read_6131_Buffer_15:
   \   000000B6   2069               LDR      R0,[R4, #+16]
   \   000000B8   8005               LSLS     R0,R0,#+22
   \   000000BA   FCD5               BPL.N    ??Read_6131_Buffer_15
    951                        // transmit dummy data byte 0x00 to start receive
    952                        spi->SPI_TDR = 0x00 | SPI_PCS(BOARD_6131_NPCS);
   \   000000BC   5FF46020           MOVS     R0,#+917504
   \   000000C0   E060               STR      R0,[R4, #+12]
    953                        // Wait for TDRE flag (Tx Data Register Empty)
    954                        while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Read_6131_Buffer_16:
   \   000000C2   2069               LDR      R0,[R4, #+16]
   \   000000C4   8007               LSLS     R0,R0,#+30
   \   000000C6   FCD5               BPL.N    ??Read_6131_Buffer_16
    955                        // Wait for RDRF flag (Rx Data Register Full)
    956                        while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
   \                     ??Read_6131_Buffer_17:
   \   000000C8   2069               LDR      R0,[R4, #+16]
   \   000000CA   C007               LSLS     R0,R0,#+31
   \   000000CC   FCD5               BPL.N    ??Read_6131_Buffer_17
    957                        // without this next delay, the ARM SPI reads wrong value in RDR!
    958                        // I see good data shifting out from HI-6131 but RxData register value is wrong
    959                        for (dummy=0; dummy<2; dummy++);
   \   000000CE   0020               MOVS     R0,#+0
   \   000000D0   0700               MOVS     R7,R0
   \                     ??Read_6131_Buffer_18:
   \   000000D2   BFB2               UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000D4   022F               CMP      R7,#+2
   \   000000D6   01D2               BCS.N    ??Read_6131_Buffer_19
   \   000000D8   7F1C               ADDS     R7,R7,#+1
   \   000000DA   FAE7               B.N      ??Read_6131_Buffer_18
    960                        // Read received data char in Rx buffer
    961                        bufferRX[j] = spi->SPI_RDR & 0xFFFF;
   \                     ??Read_6131_Buffer_19:
   \   000000DC   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000DE   00A8               ADD      R0,SP,#+0
   \   000000E0   D4F808C0           LDR      R12,[R4, #+8]
   \   000000E4   06F800C0           STRB     R12,[R6, R0]
    962                  }
   \   000000E8   6D1C               ADDS     R5,R5,#+1
   \   000000EA   E1E7               B.N      ??Read_6131_Buffer_13
    963                  // merge 2 data bytes into 16-bit value and store
    964                  read_data[i] =  (unsigned int)bufferRX[0] << 8;
   \                     ??Read_6131_Buffer_14:
   \   000000EC   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000EE   ........           LDR.W    R0,??DataTable15_4
   \   000000F2   9DF800C0           LDRB     R12,[SP, #+0]
   \   000000F6   5FEA0C2C           LSLS     R12,R12,#+8
   \   000000FA   20F815C0           STRH     R12,[R0, R5, LSL #+1]
    965                  read_data[i] |= (unsigned int)bufferRX[1];
   \   000000FE   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000100   ........           LDR.W    R0,??DataTable15_4
   \   00000104   30F81500           LDRH     R0,[R0, R5, LSL #+1]
   \   00000108   9DF801C0           LDRB     R12,[SP, #+1]
   \   0000010C   5CEA0000           ORRS     R0,R12,R0
   \   00000110   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000112   ........           LDR.W    R12,??DataTable15_4
   \   00000116   2CF81500           STRH     R0,[R12, R5, LSL #+1]
    966              }
   \   0000011A   6D1C               ADDS     R5,R5,#+1
   \   0000011C   9EE7               B.N      ??Read_6131_Buffer_6
    967              // prevent warning: variable dummy was set but never used
    968              dummy = dummy;
    969              // negate slave chip select
    970              AT91C_BASE_PIOA->PIO_SODR = SPI_nCS; // faster than PIO_Set(pinNss);
   \                     ??Read_6131_Buffer_7:
   \   0000011E   ........           LDR.W    R0,??DataTable13  ;; 0x400e0c30
   \   00000122   5FF4803C           MOVS     R12,#+65536
   \   00000126   C0F800C0           STR      R12,[R0, #+0]
    971              spi_busy = 0;
   \   0000012A   ........           LDR.W    R0,??DataTable15_1
   \   0000012E   5FF0000C           MOVS     R12,#+0
   \   00000132   80F800C0           STRB     R12,[R0, #+0]
    972              // re-enable interrupts, if IRQs managed at this level 
    973              if(irq_mgmt)  __enable_interrupt();	
   \   00000136   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000138   002A               CMP      R2,#+0
   \   0000013A   00D0               BEQ.N    ??Read_6131_Buffer_20
   \   0000013C   62B6               CPSIE    I
    974          
    975              return ('P');
   \                     ??Read_6131_Buffer_20:
   \   0000013E   5020               MOVS     R0,#+80
   \                     ??Read_6131_Buffer_1:
   \   00000140   F2BC               POP      {R1,R4-R7}
   \   00000142   7047               BX       LR               ;; return
    976          }
    977          
    978          
    979          //  This function reads a single 16-bit value from the RAM location pointed to by the 
    980          //  specified RT1 or RT2 Current Control Word Address register. The function transmits 
    981          //  an 8-bit op code, then receives the data word as two bytes. The data is returned as 
    982          //  a word. The function copies the specified RT1 or RT2 Current Control Word Address 
    983          //  register to the enabled Memory Address Pointer register before reading the word.
    984          //	The data character received during op code transmission is discarded.
    985          //
    986          //  If parameter irq_mgmt is zero, this function disables interrupts while SPI 
    987          //  transfers are underway. The two vectored interrupts from the HI-6131 (hardware and 
    988          //  message IRQs) use SPI and would cause disruption. Since this is a 3-byte SPI sequence,
    989          //  IRQ recognition is just delayed briefly. If irq_mgmt is non-zero, the calling
    990          //  function should disable IRQs before calling this function...
    991          //
    992          //    param     rt_num.   '1' specifies RT1 or '2' (any value except '1') specifies RT2
    993          //    param	irq_mgmt. if zero, the calling routine manages irq enable/disable.
    994          //			  if non-zero, this function calls __disable_interrupt() and __enable_interrupt() locally.
    995          //
    996          //	The MCU's SPI mode register is written with option WDRBT = 0 so Master
    997          //	can initialize a new transfer whether/not SPI RxData register has unread
    998          //	data. To speed up SPI operations by taking advantnage of the WDRBT
    999          //	option, several statements are commented-out in the function below.
   1000          //

   \                                 In section .text, align 2, keep-with-next
   1001          unsigned short Read_Current_Control_Word(unsigned char rt_num, unsigned char irq_mgmt) {
   \                     Read_Current_Control_Word:
   \   00000000   F8B4               PUSH     {R3-R7}
   \   00000002   0200               MOVS     R2,R0
   1002          
   1003              AT91S_SPI *spi = BOARD_6131_SPI_BASE;
   \   00000004   ........           LDR.W    R3,??DataTable12  ;; 0x40008000
   1004              unsigned short dummy;
   1005              unsigned char opcode;
   1006              unsigned short data, i;
   1007              volatile unsigned char bufferRX[2];
   1008          
   1009              // disable interrupts, if IRQs managed at this level
   1010              if(irq_mgmt)  __disable_interrupt();	 
   \   00000008   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0029               CMP      R1,#+0
   \   0000000C   00D0               BEQ.N    ??Read_Current_Control_Word_0
   \   0000000E   72B6               CPSID    I
   1011                  
   1012              if(rt_num == 2) opcode = 0x50;
   \                     ??Read_Current_Control_Word_0:
   \   00000010   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000012   022A               CMP      R2,#+2
   \   00000014   02D1               BNE.N    ??Read_Current_Control_Word_1
   \   00000016   5027               MOVS     R7,#+80
   \   00000018   3D00               MOVS     R5,R7
   \   0000001A   01E0               B.N      ??Read_Current_Control_Word_2
   1013              else opcode = 0x48;
   \                     ??Read_Current_Control_Word_1:
   \   0000001C   4827               MOVS     R7,#+72
   \   0000001E   3D00               MOVS     R5,R7
   1014                       
   1015              if(irq_mgmt)  __disable_interrupt();
   \                     ??Read_Current_Control_Word_2:
   \   00000020   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000022   0029               CMP      R1,#+0
   \   00000024   00D0               BEQ.N    ??Read_Current_Control_Word_3
   \   00000026   72B6               CPSID    I
   1016              // variable tested by vectored interrupt routine 
   1017              spi_busy = 1;				
   \                     ??Read_Current_Control_Word_3:
   \   00000028   ........           LDR.W    R7,??DataTable15_1
   \   0000002C   5FF0010C           MOVS     R12,#+1
   \   00000030   87F800C0           STRB     R12,[R7, #+0]
   1018              // Assert SPI chip select
   1019              AT91C_BASE_PIOA->PIO_CODR = SPI_nCS; // faster than PIO_Clear(pinNss); 
   \   00000034   ........           LDR.W    R7,??DataTable12_1  ;; 0x400e0c34
   \   00000038   5FF4803C           MOVS     R12,#+65536
   \   0000003C   C7F800C0           STR      R12,[R7, #+0]
   1020              // Wait for TDR and shifter = empty
   1021              while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
   \                     ??Read_Current_Control_Word_4:
   \   00000040   1F69               LDR      R7,[R3, #+16]
   \   00000042   BF05               LSLS     R7,R7,#+22
   \   00000044   FCD5               BPL.N    ??Read_Current_Control_Word_4
   1022              // Send SPI op code 
   1023              spi->SPI_TDR = opcode | SPI_PCS(BOARD_6131_NPCS);
   \   00000046   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000048   55F46027           ORRS     R7,R5,#0xE0000
   \   0000004C   DF60               STR      R7,[R3, #+12]
   1024              // Wait for TDRE flag (Tx Data Register Empty)
   1025              while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Read_Current_Control_Word_5:
   \   0000004E   1F69               LDR      R7,[R3, #+16]
   \   00000050   BF07               LSLS     R7,R7,#+30
   \   00000052   FCD5               BPL.N    ??Read_Current_Control_Word_5
   1026              // Wait for RDRF flag (Rx Data Register Full)
   1027              while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
   \                     ??Read_Current_Control_Word_6:
   \   00000054   1F69               LDR      R7,[R3, #+16]
   \   00000056   FF07               LSLS     R7,R7,#+31
   \   00000058   FCD5               BPL.N    ??Read_Current_Control_Word_6
   1028              // Read and discard received data char in Rx buffer
   1029              dummy = spi->SPI_RDR & 0xFFFF;
   \   0000005A   9F68               LDR      R7,[R3, #+8]
   \   0000005C   3C00               MOVS     R4,R7
   1030                                                               
   1031              // receive 2 bytes register data, transmit 2 dummy data bytes
   1032              for (i = 0; i < 2; i++) {
   \   0000005E   0027               MOVS     R7,#+0
   \   00000060   3E00               MOVS     R6,R7
   \                     ??Read_Current_Control_Word_7:
   \   00000062   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000064   022E               CMP      R6,#+2
   \   00000066   1AD2               BCS.N    ??Read_Current_Control_Word_8
   1033                  // Wait for TDR and shifter = empty
   1034                  while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
   \                     ??Read_Current_Control_Word_9:
   \   00000068   1F69               LDR      R7,[R3, #+16]
   \   0000006A   BF05               LSLS     R7,R7,#+22
   \   0000006C   FCD5               BPL.N    ??Read_Current_Control_Word_9
   1035                  // transmit dummy data byte 0x00 to start receive
   1036                  spi->SPI_TDR = 0x00 | SPI_PCS(BOARD_6131_NPCS);
   \   0000006E   5FF46027           MOVS     R7,#+917504
   \   00000072   DF60               STR      R7,[R3, #+12]
   1037                  // Wait for TDRE flag (Tx Data Register Empty)
   1038                  while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Read_Current_Control_Word_10:
   \   00000074   1F69               LDR      R7,[R3, #+16]
   \   00000076   BF07               LSLS     R7,R7,#+30
   \   00000078   FCD5               BPL.N    ??Read_Current_Control_Word_10
   1039                  // Wait for RDRF flag (Rx Data Register Full)
   1040                  while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
   \                     ??Read_Current_Control_Word_11:
   \   0000007A   1F69               LDR      R7,[R3, #+16]
   \   0000007C   FF07               LSLS     R7,R7,#+31
   \   0000007E   FCD5               BPL.N    ??Read_Current_Control_Word_11
   1041                  // without this next delay, the ARM SPI reads wrong value in RDR!
   1042                  // I see good data shifting out from HI-6131 but RxData register value is wrong
   1043                  for (dummy=0; dummy<2; dummy++);
   \   00000080   0027               MOVS     R7,#+0
   \   00000082   3C00               MOVS     R4,R7
   \                     ??Read_Current_Control_Word_12:
   \   00000084   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000086   022C               CMP      R4,#+2
   \   00000088   01D2               BCS.N    ??Read_Current_Control_Word_13
   \   0000008A   641C               ADDS     R4,R4,#+1
   \   0000008C   FAE7               B.N      ??Read_Current_Control_Word_12
   1044                  // Read received data char in Rx buffer
   1045                  bufferRX[i] = spi->SPI_RDR & 0xFFFF;
   \                     ??Read_Current_Control_Word_13:
   \   0000008E   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000090   00AF               ADD      R7,SP,#+0
   \   00000092   D3F808C0           LDR      R12,[R3, #+8]
   \   00000096   06F807C0           STRB     R12,[R6, R7]
   1046              }    
   \   0000009A   761C               ADDS     R6,R6,#+1
   \   0000009C   E1E7               B.N      ??Read_Current_Control_Word_7
   1047              // negate slave chip select
   1048              AT91C_BASE_PIOA->PIO_SODR = SPI_nCS; // faster than PIO_Set(pinNss);
   \                     ??Read_Current_Control_Word_8:
   \   0000009E   ........           LDR.W    R7,??DataTable15  ;; 0x400e0c30
   \   000000A2   5FF4803C           MOVS     R12,#+65536
   \   000000A6   C7F800C0           STR      R12,[R7, #+0]
   1049              // re-enable interrupts, if IRQs managed at this level 
   1050              if(irq_mgmt)  __enable_interrupt();	
   \   000000AA   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000AC   0029               CMP      R1,#+0
   \   000000AE   00D0               BEQ.N    ??Read_Current_Control_Word_14
   \   000000B0   62B6               CPSIE    I
   1051              // concantenate (merge) 2 data bytes into 16-bit value
   1052              data =  (unsigned int)bufferRX[0] << 8;
   \                     ??Read_Current_Control_Word_14:
   \   000000B2   9DF80070           LDRB     R7,[SP, #+0]
   \   000000B6   3F02               LSLS     R7,R7,#+8
   \   000000B8   3800               MOVS     R0,R7
   1053              data |= (unsigned int)bufferRX[1];
   \   000000BA   9DF80170           LDRB     R7,[SP, #+1]
   \   000000BE   3843               ORRS     R0,R7,R0
   1054                  
   1055              return data;
   \   000000C0   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000C2   F2BC               POP      {R1,R4-R7}
   \   000000C4   7047               BX       LR               ;; return
   1056          }
   1057          
   1058          
   1059          
   1060          
   1061          // 	These functions return a single 16-bit Control Word from the RT1 or RT2 Descriptor Table, 
   1062          //	specified by the passed parameters. Separate functions for RT1 and RT2.  Example usage:
   1063          //			
   1064          //	Read_RT1_Control_Word('R','S',21,0) returns Control Word for receive subaddress 21.
   1065          //	Read_RT2_Control_Word('T','M',18,0) returns Control Word for transmit mode command 18.
   1066          //
   1067          //	The function determines the address offset from the provided paramters, then adds
   1068          //	the offset to the Descriptor Table base address in register 5. The resultant address
   1069          //	is written to the Memory Address Pointer (reg 15) and the addressed RAM location
   1070          //	is read and the value is returned.
   1071          //
   1072          //	A returned value of 0xFFFF (not a valid Control Word value) signifies an error 
   1073          //	condition, such as undefined parameter, out-of-range subaddress or mode code value,etc.
   1074          //
   1075          //	If parameter irq_mgmt is zero, this function disables interrupts while SPI 
   1076          //	transfers are underway. The two vectored interrupts from the HI-6131 (hardware and 
   1077          //	message IRQs) use SPI and would cause disruption. If irq_mgmt is non-zero, the calling
   1078          //	function should disable IRQs before calling this function...
   1079          //
   1080          //      param	txrx specifies transmit or receive, valid characters are 'T','t','R'or'r'
   1081          //      param	samc specifies subaddress or mode command, valid characters are 'S','s','M'or'm'
   1082          //      param	number is subaddress or mode code number. (1-30 for subaddress, or 0-31 for mode cmds)
   1083          //      param	irq_mgmt. if zero, the calling routine manages irq enable/disable.
   1084          //	                  if non-zero, this function calls __disable_interrupt() and __enable_interrupt() locally.
   1085          //
   1086          //		The MCU's SPI mode register is written with option WDRBT = 0 so Master
   1087          //		can initialize a new transfer whether/not SPI RxData register has unread
   1088          //		data. To speed up SPI operations by taking advantnage of the WDRBT
   1089          //		option, several statements are commented-out in the function below.
   1090          //

   \                                 In section .text, align 2, keep-with-next
   1091          unsigned short Read_RT1_Control_Word(unsigned char txrx, unsigned char samc, unsigned char number, unsigned char irq_mgmt) {
   \                     Read_RT1_Control_Word:
   \   00000000   2DE9F843           PUSH     {R3-R9,LR}
   \   00000004   8146               MOV      R9,R0
   \   00000006   0C00               MOVS     R4,R1
   \   00000008   1500               MOVS     R5,R2
   \   0000000A   1E00               MOVS     R6,R3
   1092          
   1093          	unsigned short address = 0, data;
   \   0000000C   5FF00008           MOVS     R8,#+0
   1094          
   1095          	if((samc == 's') || (samc == 'S')) {
   \   00000010   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   732C               CMP      R4,#+115
   \   00000014   02D0               BEQ.N    ??Read_RT1_Control_Word_0
   \   00000016   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   532C               CMP      R4,#+83
   \   0000001A   0CD1               BNE.N    ??Read_RT1_Control_Word_1
   1096          		if ((number > 0) && (number < 31)) {
   \                     ??Read_RT1_Control_Word_0:
   \   0000001C   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   012D               CMP      R5,#+1
   \   00000020   06D3               BCC.N    ??Read_RT1_Control_Word_2
   \   00000022   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   1F2D               CMP      R5,#+31
   \   00000026   03D2               BCS.N    ??Read_RT1_Control_Word_2
   1097          			address = number << 2;
   \   00000028   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   A800               LSLS     R0,R5,#+2
   \   0000002C   8046               MOV      R8,R0
   \   0000002E   17E0               B.N      ??Read_RT1_Control_Word_3
   1098          		}
   1099          		else return (0xFFFF);	// error - subaddress must be in range 1-30 inclusive 
   \                     ??Read_RT1_Control_Word_2:
   \   00000030   4FF6FF70           MOVW     R0,#+65535
   \   00000034   4EE0               B.N      ??Read_RT1_Control_Word_4
   1100          	}
   1101          
   1102          	else if ((samc == 'm') || (samc == 'M')) {
   \                     ??Read_RT1_Control_Word_1:
   \   00000036   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000038   6D2C               CMP      R4,#+109
   \   0000003A   02D0               BEQ.N    ??Read_RT1_Control_Word_5
   \   0000003C   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003E   4D2C               CMP      R4,#+77
   \   00000040   0BD1               BNE.N    ??Read_RT1_Control_Word_6
   1103          
   1104          		if (number < 32) {
   \                     ??Read_RT1_Control_Word_5:
   \   00000042   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   202D               CMP      R5,#+32
   \   00000046   05D2               BCS.N    ??Read_RT1_Control_Word_7
   1105          			address = number << 2;
   \   00000048   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   A800               LSLS     R0,R5,#+2
   \   0000004C   8046               MOV      R8,R0
   1106          			address += 0x100;
   \   0000004E   08F20018           ADDW     R8,R8,#+256
   \   00000052   05E0               B.N      ??Read_RT1_Control_Word_3
   1107          		}
   1108          		else return (0xFFFF);	// error - mode command with invalid mode number 
   \                     ??Read_RT1_Control_Word_7:
   \   00000054   4FF6FF70           MOVW     R0,#+65535
   \   00000058   3CE0               B.N      ??Read_RT1_Control_Word_4
   1109          	}
   1110          
   1111          	else  return  (0xFFFF);		// error - not coded s,S,m or M for subaddress or mode cmd 
   \                     ??Read_RT1_Control_Word_6:
   \   0000005A   4FF6FF70           MOVW     R0,#+65535
   \   0000005E   39E0               B.N      ??Read_RT1_Control_Word_4
   1112          
   1113          	if((txrx == 't') || (txrx == 'T'))
   \                     ??Read_RT1_Control_Word_3:
   \   00000060   5FFA89F9           UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000064   B9F1740F           CMP      R9,#+116
   \   00000068   04D0               BEQ.N    ??Read_RT1_Control_Word_8
   \   0000006A   5FFA89F9           UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000006E   B9F1540F           CMP      R9,#+84
   \   00000072   02D1               BNE.N    ??Read_RT1_Control_Word_9
   1114          
   1115          		address += 0x080;
   \                     ??Read_RT1_Control_Word_8:
   \   00000074   18F18008           ADDS     R8,R8,#+128
   \   00000078   0EE0               B.N      ??Read_RT1_Control_Word_10
   1116          
   1117          	else if ((txrx |= 'r') && (txrx |= 'R'))
   \                     ??Read_RT1_Control_Word_9:
   \   0000007A   59F07209           ORRS     R9,R9,#0x72
   \   0000007E   4846               MOV      R0,R9
   \   00000080   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000082   0028               CMP      R0,#+0
   \   00000084   08D0               BEQ.N    ??Read_RT1_Control_Word_10
   \   00000086   59F05209           ORRS     R9,R9,#0x52
   \   0000008A   4846               MOV      R0,R9
   \   0000008C   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008E   0028               CMP      R0,#+0
   \   00000090   02D0               BEQ.N    ??Read_RT1_Control_Word_10
   1118          
   1119          		return (0xFFFF);	// error - not coded t,T,r or R for transmit or receive 
   \   00000092   4FF6FF70           MOVW     R0,#+65535
   \   00000096   1DE0               B.N      ??Read_RT1_Control_Word_4
   1120          
   1121          	if(irq_mgmt) __disable_interrupt();		// disable interrupts, if IRQs managed at this level 
   \                     ??Read_RT1_Control_Word_10:
   \   00000098   F6B2               UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000009A   002E               CMP      R6,#+0
   \   0000009C   00D0               BEQ.N    ??Read_RT1_Control_Word_11
   \   0000009E   72B6               CPSID    I
   1122          
   1123          	data = Read_6131LowReg(RT1_DESC_TBL_BASE_ADDR_REG,0);
   \                     ??Read_RT1_Control_Word_11:
   \   000000A0   0021               MOVS     R1,#+0
   \   000000A2   1920               MOVS     R0,#+25
   \   000000A4   ........           BL       Read_6131LowReg
   \   000000A8   0700               MOVS     R7,R0
   1124          
   1125          	address += data;		// add table base addr to offset, then load mem addr ptr 
   \   000000AA   17EB0808           ADDS     R8,R7,R8
   1126          
   1127          	enaMAP(1);
   \   000000AE   0120               MOVS     R0,#+1
   \   000000B0   ........           BL       enaMAP
   1128          	
   1129          	Write_6131LowReg(MAP_1,address,0);	
   \   000000B4   0022               MOVS     R2,#+0
   \   000000B6   4146               MOV      R1,R8
   \   000000B8   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000BA   0B20               MOVS     R0,#+11
   \   000000BC   ........           BL       Write_6131LowReg
   1130          
   1131          	data = Read_6131_1word(0);    // read desired Control Word from the Descriptor Table 
   \   000000C0   0020               MOVS     R0,#+0
   \   000000C2   ........           BL       Read_6131_1word
   \   000000C6   0700               MOVS     R7,R0
   1132          
   1133          	if(irq_mgmt) __enable_interrupt();		// re-enable interrupts, if IRQs managed at this level 
   \   000000C8   F6B2               UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000CA   002E               CMP      R6,#+0
   \   000000CC   00D0               BEQ.N    ??Read_RT1_Control_Word_12
   \   000000CE   62B6               CPSIE    I
   1134          
   1135          	return data;
   \                     ??Read_RT1_Control_Word_12:
   \   000000D0   3800               MOVS     R0,R7
   \   000000D2   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??Read_RT1_Control_Word_4:
   \   000000D4   BDE8F283           POP      {R1,R4-R9,PC}    ;; return
   1136          }
   1137          
   1138          
   1139          
   1140          
   1141          // the RT2 version

   \                                 In section .text, align 2, keep-with-next
   1142          unsigned short Read_RT2_Control_Word(unsigned char txrx, unsigned char samc, unsigned char number, unsigned char irq_mgmt) {
   \                     Read_RT2_Control_Word:
   \   00000000   2DE9F843           PUSH     {R3-R9,LR}
   \   00000004   8146               MOV      R9,R0
   \   00000006   0C00               MOVS     R4,R1
   \   00000008   1500               MOVS     R5,R2
   \   0000000A   1E00               MOVS     R6,R3
   1143          
   1144          	unsigned short address = 0, data;
   \   0000000C   5FF00008           MOVS     R8,#+0
   1145          
   1146          	if((samc == 's') || (samc == 'S')) {
   \   00000010   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   732C               CMP      R4,#+115
   \   00000014   02D0               BEQ.N    ??Read_RT2_Control_Word_0
   \   00000016   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   532C               CMP      R4,#+83
   \   0000001A   0CD1               BNE.N    ??Read_RT2_Control_Word_1
   1147          		if ((number > 0) && (number < 31)) {
   \                     ??Read_RT2_Control_Word_0:
   \   0000001C   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   012D               CMP      R5,#+1
   \   00000020   06D3               BCC.N    ??Read_RT2_Control_Word_2
   \   00000022   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   1F2D               CMP      R5,#+31
   \   00000026   03D2               BCS.N    ??Read_RT2_Control_Word_2
   1148          			address = number << 2;
   \   00000028   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   A800               LSLS     R0,R5,#+2
   \   0000002C   8046               MOV      R8,R0
   \   0000002E   17E0               B.N      ??Read_RT2_Control_Word_3
   1149          		}
   1150          		else return (0xFFFF);	// error - subaddress must be in range 1-30 inclusive 
   \                     ??Read_RT2_Control_Word_2:
   \   00000030   4FF6FF70           MOVW     R0,#+65535
   \   00000034   4EE0               B.N      ??Read_RT2_Control_Word_4
   1151          	}
   1152          
   1153          	else if ((samc == 'm') || (samc == 'M')) {
   \                     ??Read_RT2_Control_Word_1:
   \   00000036   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000038   6D2C               CMP      R4,#+109
   \   0000003A   02D0               BEQ.N    ??Read_RT2_Control_Word_5
   \   0000003C   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003E   4D2C               CMP      R4,#+77
   \   00000040   0BD1               BNE.N    ??Read_RT2_Control_Word_6
   1154          
   1155          		if (number < 32) {
   \                     ??Read_RT2_Control_Word_5:
   \   00000042   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   202D               CMP      R5,#+32
   \   00000046   05D2               BCS.N    ??Read_RT2_Control_Word_7
   1156          			address = number << 2;
   \   00000048   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   A800               LSLS     R0,R5,#+2
   \   0000004C   8046               MOV      R8,R0
   1157          			address += 0x100;
   \   0000004E   08F20018           ADDW     R8,R8,#+256
   \   00000052   05E0               B.N      ??Read_RT2_Control_Word_3
   1158          		}
   1159          		else return (0xFFFF);	// error - mode command with invalid mode number 
   \                     ??Read_RT2_Control_Word_7:
   \   00000054   4FF6FF70           MOVW     R0,#+65535
   \   00000058   3CE0               B.N      ??Read_RT2_Control_Word_4
   1160          	}
   1161          
   1162          	else  return  (0xFFFF);		// error - not coded s,S,m or M for subaddress or mode cmd 
   \                     ??Read_RT2_Control_Word_6:
   \   0000005A   4FF6FF70           MOVW     R0,#+65535
   \   0000005E   39E0               B.N      ??Read_RT2_Control_Word_4
   1163          
   1164          	if((txrx == 't') || (txrx == 'T'))
   \                     ??Read_RT2_Control_Word_3:
   \   00000060   5FFA89F9           UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000064   B9F1740F           CMP      R9,#+116
   \   00000068   04D0               BEQ.N    ??Read_RT2_Control_Word_8
   \   0000006A   5FFA89F9           UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000006E   B9F1540F           CMP      R9,#+84
   \   00000072   02D1               BNE.N    ??Read_RT2_Control_Word_9
   1165          
   1166          		address += 0x080;
   \                     ??Read_RT2_Control_Word_8:
   \   00000074   18F18008           ADDS     R8,R8,#+128
   \   00000078   0EE0               B.N      ??Read_RT2_Control_Word_10
   1167          
   1168          	else if ((txrx |= 'r') && (txrx |= 'R'))
   \                     ??Read_RT2_Control_Word_9:
   \   0000007A   59F07209           ORRS     R9,R9,#0x72
   \   0000007E   4846               MOV      R0,R9
   \   00000080   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000082   0028               CMP      R0,#+0
   \   00000084   08D0               BEQ.N    ??Read_RT2_Control_Word_10
   \   00000086   59F05209           ORRS     R9,R9,#0x52
   \   0000008A   4846               MOV      R0,R9
   \   0000008C   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008E   0028               CMP      R0,#+0
   \   00000090   02D0               BEQ.N    ??Read_RT2_Control_Word_10
   1169          
   1170          		return (0xFFFF);	// error - not coded t,T,r or R for transmit or receive 
   \   00000092   4FF6FF70           MOVW     R0,#+65535
   \   00000096   1DE0               B.N      ??Read_RT2_Control_Word_4
   1171          
   1172          	if(irq_mgmt) __disable_interrupt();		// disable interrupts, if IRQs managed at this level 
   \                     ??Read_RT2_Control_Word_10:
   \   00000098   F6B2               UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000009A   002E               CMP      R6,#+0
   \   0000009C   00D0               BEQ.N    ??Read_RT2_Control_Word_11
   \   0000009E   72B6               CPSID    I
   1173          
   1174          	data = Read_6131LowReg(RT2_DESC_TBL_BASE_ADDR_REG,0);
   \                     ??Read_RT2_Control_Word_11:
   \   000000A0   0021               MOVS     R1,#+0
   \   000000A2   2220               MOVS     R0,#+34
   \   000000A4   ........           BL       Read_6131LowReg
   \   000000A8   0700               MOVS     R7,R0
   1175          
   1176          	address += data;		// add table base addr to offset, then load mem addr ptr 
   \   000000AA   17EB0808           ADDS     R8,R7,R8
   1177          
   1178          	enaMAP(1);
   \   000000AE   0120               MOVS     R0,#+1
   \   000000B0   ........           BL       enaMAP
   1179          	
   1180          	Write_6131LowReg(MAP_1,address,0);	
   \   000000B4   0022               MOVS     R2,#+0
   \   000000B6   4146               MOV      R1,R8
   \   000000B8   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000BA   0B20               MOVS     R0,#+11
   \   000000BC   ........           BL       Write_6131LowReg
   1181          
   1182          	data = Read_6131_1word(0);    // read desired Control Word from the Descriptor Table 
   \   000000C0   0020               MOVS     R0,#+0
   \   000000C2   ........           BL       Read_6131_1word
   \   000000C6   0700               MOVS     R7,R0
   1183          
   1184          	if(irq_mgmt) __enable_interrupt();		// re-enable interrupts, if IRQs managed at this level 
   \   000000C8   F6B2               UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000CA   002E               CMP      R6,#+0
   \   000000CC   00D0               BEQ.N    ??Read_RT2_Control_Word_12
   \   000000CE   62B6               CPSIE    I
   1185          
   1186          	return data;
   \                     ??Read_RT2_Control_Word_12:
   \   000000D0   3800               MOVS     R0,R7
   \   000000D2   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??Read_RT2_Control_Word_4:
   \   000000D4   BDE8F283           POP      {R1,R4-R9,PC}    ;; return
   1187          }
   1188          
   1189          
   1190          
   1191          //  This function reads a single 16-bit value from the RAM location pointed	to by
   1192          //  the enabled Memory Address Pointer, then advances that Memory Address Pointer
   1193          //  value by 4 RAM addresses. The function transmits an 8-bit op code, then 
   1194          //  receives the addressed data word as two bytes. The data is returned as a word.
   1195          //  The data character received during op code transmission is discarded.
   1196          //
   1197          //  Design Intent: The host can easily read successive descriptor table Control
   1198          //  Words, spaced at 4-word intervals. Example use: message activity can be detected 
   1199          //  for subaddresses not programmed to generate interrupts. Host can poll the DBAC 
   1200          //  (Data Block Accessed) bit in each Control Word, which is set when a message 
   1201          //  is completed. The DBAC bit automatically resets when the Control Word is read.
   1202          //
   1203          //  If parameter irq_mgmt is zero, this function disables interrupts while SPI 
   1204          //  transfers are underway. The two vectored interrupts from the HI-6131 (hardware and 
   1205          //  message IRQs) use SPI and would cause disruption. Since this is a 3-byte SPI sequence,
   1206          //  IRQ recognition is just delayed briefly. If irq_mgmt is non-zero, the calling
   1207          //  function should disable IRQs before calling this function...
   1208          //
   1209          //  param	irq_mgmt. if zero, the calling routine manages irq enable/disable.
   1210          //	                  if non-zero, this function calls __disable_interrupt() and __enable_interrupt() locally.
   1211          //
   1212          //  The MCU's SPI mode register is written with option WDRBT = 0 so Master
   1213          //  can initialize a new transfer whether/not SPI RxData register has unread
   1214          //  data. To speed up SPI operations by taking advantnage of the WDRBT
   1215          //  option, several statements are commented-out in the function below.
   1216          //

   \                                 In section .text, align 2, keep-with-next
   1217          unsigned short ReadWord_Adv4(unsigned char irq_mgmt) {
   \                     ReadWord_Adv4:
   \   00000000   38B4               PUSH     {R3-R5}
   \   00000002   0100               MOVS     R1,R0
   1218          
   1219              AT91S_SPI *spi = BOARD_6131_SPI_BASE;
   \   00000004   ....               LDR.N    R2,??DataTable12  ;; 0x40008000
   1220              unsigned short data, i;
   1221              volatile unsigned char bufferRX[2];
   1222                  
   1223              // disable interrupts, if IRQs managed at this level
   1224              if(irq_mgmt)  __disable_interrupt();	 
   \   00000006   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0029               CMP      R1,#+0
   \   0000000A   00D0               BEQ.N    ??ReadWord_Adv4_0
   \   0000000C   72B6               CPSID    I
   1225              // Assert SPI chip select
   1226              AT91C_BASE_PIOA->PIO_CODR = SPI_nCS; // faster than PIO_Clear(pinNss); 
   \                     ??ReadWord_Adv4_0:
   \   0000000E   ....               LDR.N    R4,??DataTable12_1  ;; 0x400e0c34
   \   00000010   5FF48035           MOVS     R5,#+65536
   \   00000014   2560               STR      R5,[R4, #+0]
   1227              // Wait for TDR and shifter = empty
   1228              while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
   \                     ??ReadWord_Adv4_1:
   \   00000016   1469               LDR      R4,[R2, #+16]
   \   00000018   A405               LSLS     R4,R4,#+22
   \   0000001A   FCD5               BPL.N    ??ReadWord_Adv4_1
   1229              // Send 8-bit SPI op code 0x60
   1230              spi->SPI_TDR = 0x60 | SPI_PCS(BOARD_6131_NPCS);
   \   0000001C   ........           LDR.W    R4,??DataTable15_5  ;; 0xe0060
   \   00000020   D460               STR      R4,[R2, #+12]
   1231              // Wait for TDRE flag (Tx Data Register Empty)
   1232              while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??ReadWord_Adv4_2:
   \   00000022   1469               LDR      R4,[R2, #+16]
   \   00000024   A407               LSLS     R4,R4,#+30
   \   00000026   FCD5               BPL.N    ??ReadWord_Adv4_2
   1233              // Wait for RDRF flag (Rx Data Register Full)
   1234              while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
   \                     ??ReadWord_Adv4_3:
   \   00000028   1469               LDR      R4,[R2, #+16]
   \   0000002A   E407               LSLS     R4,R4,#+31
   \   0000002C   FCD5               BPL.N    ??ReadWord_Adv4_3
   1235              // Read received data char in Rx buffer, discard/overwrite below
   1236              bufferRX[0] = spi->SPI_RDR & 0xFFFF;
   \   0000002E   9468               LDR      R4,[R2, #+8]
   \   00000030   8DF80040           STRB     R4,[SP, #+0]
   1237          
   1238              // receive 2 bytes register data, transmit 2 dummy data bytes
   1239              for (i = 0; i < 2; i++) {
   \   00000034   0024               MOVS     R4,#+0
   \   00000036   2300               MOVS     R3,R4
   \                     ??ReadWord_Adv4_4:
   \   00000038   9BB2               UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000003A   022B               CMP      R3,#+2
   \   0000003C   18D2               BCS.N    ??ReadWord_Adv4_5
   1240                  // Wait for TDR and shifter = empty
   1241                  while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
   \                     ??ReadWord_Adv4_6:
   \   0000003E   1469               LDR      R4,[R2, #+16]
   \   00000040   A405               LSLS     R4,R4,#+22
   \   00000042   FCD5               BPL.N    ??ReadWord_Adv4_6
   1242                  // transmit dummy data to receive next byte
   1243                  spi->SPI_TDR = 0x0 | SPI_PCS(BOARD_6131_NPCS);
   \   00000044   5FF46024           MOVS     R4,#+917504
   \   00000048   D460               STR      R4,[R2, #+12]
   1244                  // Wait for TDRE flag (Tx Data Register Empty)
   1245                  while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??ReadWord_Adv4_7:
   \   0000004A   1469               LDR      R4,[R2, #+16]
   \   0000004C   A407               LSLS     R4,R4,#+30
   \   0000004E   FCD5               BPL.N    ??ReadWord_Adv4_7
   1246                  // Wait for RDRF flag (Rx Data Register Full)
   1247                  while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
   \                     ??ReadWord_Adv4_8:
   \   00000050   1469               LDR      R4,[R2, #+16]
   \   00000052   E407               LSLS     R4,R4,#+31
   \   00000054   FCD5               BPL.N    ??ReadWord_Adv4_8
   1248                  // without this next delay, the ARM SPI reads wrong value in RDR!
   1249                  // I see good data shifting out from HI-6131 but RxData register value is wrong
   1250                  for (data=0; data<2; data++);
   \   00000056   0024               MOVS     R4,#+0
   \   00000058   2000               MOVS     R0,R4
   \                     ??ReadWord_Adv4_9:
   \   0000005A   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000005C   0228               CMP      R0,#+2
   \   0000005E   01D2               BCS.N    ??ReadWord_Adv4_10
   \   00000060   401C               ADDS     R0,R0,#+1
   \   00000062   FAE7               B.N      ??ReadWord_Adv4_9
   1251                  // Read received data char in Rx buffer
   1252                  bufferRX[i] = spi->SPI_RDR & 0xFFFF;
   \                     ??ReadWord_Adv4_10:
   \   00000064   9BB2               UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000066   00AC               ADD      R4,SP,#+0
   \   00000068   9568               LDR      R5,[R2, #+8]
   \   0000006A   1D55               STRB     R5,[R3, R4]
   1253              }    
   \   0000006C   5B1C               ADDS     R3,R3,#+1
   \   0000006E   E3E7               B.N      ??ReadWord_Adv4_4
   1254              // negate slave chip select
   1255              AT91C_BASE_PIOA->PIO_SODR = SPI_nCS; // faster than PIO_Set(pinNss);
   \                     ??ReadWord_Adv4_5:
   \   00000070   ........           LDR.W    R4,??DataTable15  ;; 0x400e0c30
   \   00000074   5FF48035           MOVS     R5,#+65536
   \   00000078   2560               STR      R5,[R4, #+0]
   1256              // re-enable interrupts, if IRQs managed at this level 
   1257              if(irq_mgmt)  __enable_interrupt();	
   \   0000007A   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000007C   0029               CMP      R1,#+0
   \   0000007E   00D0               BEQ.N    ??ReadWord_Adv4_11
   \   00000080   62B6               CPSIE    I
   1258              // merge 2 data bytes into 16-bit value
   1259              data =  (unsigned int)bufferRX[0] << 8;
   \                     ??ReadWord_Adv4_11:
   \   00000082   9DF80040           LDRB     R4,[SP, #+0]
   \   00000086   2402               LSLS     R4,R4,#+8
   \   00000088   2000               MOVS     R0,R4
   1260              data |= (unsigned int)bufferRX[1];
   \   0000008A   9DF80140           LDRB     R4,[SP, #+1]
   \   0000008E   2043               ORRS     R0,R4,R0
   1261                  
   1262              return data;
   \   00000090   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000092   32BC               POP      {R1,R4,R5}
   \   00000094   7047               BX       LR               ;; return
   1263          }
   1264            
   1265          // This function performs the following steps: (1) write enabled memory address pointer
   1266          // with the current bit 8:0 value in Interrupt Log Address register, minus 1. Upper bits
   1267          // 15:9 (indicating number of interrupts since Log Address register was read) are not 
   1268          // used. Since the Interrupt Log Address register points to the storage address for the
   1269          // next-occurring interrupt, the decremented MAP value points to the second word stored 
   1270          // for the last interrupt, the IIW Interrupt Address Word. If the Log Address register 
   1271          // points to the first log buffer address 0x0180, then the last buffer address 0x01BF is 
   1272          // written to the enabled memory pointer register because buffer wrap-around occurred. 
   1273          // (2) The last-written Interrupt Address Word indicated by the enabled memory address
   1274          // pointer is read. (3) The memory address pointer DECREMENTS, addressing the corresponding
   1275          // Interrupt Information Word. The function returns the last IAW but not the IIW. (4) Upon
   1276          // return, the calling routine can read the corresponding IIW now addressed by the enabled
   1277          // memory address pointer. 
   1278          //
   1279          // The 0x58 op code can be used to read a single IAW location, or a revision to this function
   1280          // can start a multi-word read sequence in which the memory address pointer automatically 
   1281          // DECREMENTS after each word read, as long as SPI clock continues in 16-pulse multiples. 
   1282          // This is the only SPI op code that decrements the memory pointer for multi-word operations. 
   1283          // Repeated memory pointer decrements would wrap around the 0x0180 to 0x01BF log buffer boundary,
   1284          // returning IAW then IIW word pairs, in reverse order of interrupt occurence (last in, first out).
   1285          //
   1286          // This function reads the last Interrupt Address Word (IAW) written to the HI-6131 Interrupt 
   1287          // Log buffer. The function transmits the 8-bit 0x58 op code, then receives the IAW word as two 
   1288          // bytes, returned as a word. Upon return, the memory address pointer points to the IIW Interrupt
   1289          // Information Word corresponding to the returned IAW. The data character received during op code 
   1290          // transmission is discarded.
   1291          //
   1292          // If parameter irq_mgmt is zero, this function disables interrupts while SPI transfers are 
   1293          // underway. If irq_mgmt is non-zero, the calling function should disable IRQs before calling this function...
   1294          //
   1295          //      param	irq_mgmt. if zero, the calling routine manages irq enable/disable.
   1296          //	                  if non-zero, this function calls __disable_interrupt() and __enable_interrupt() locally.
   1297          //
   1298          //		The MCU's SPI mode register is written with option WDRBT = 0 so Master
   1299          //		can initialize a new transfer whether/not SPI RxData register has unread
   1300          //		data. To speed up SPI operations by taking advantnage of the WDRBT
   1301          //		option, several statements are commented-out in the function below.
   1302          //

   \                                 In section .text, align 2, keep-with-next
   1303          unsigned short Read_Last_Interrupt(unsigned char irq_mgmt) {
   \                     Read_Last_Interrupt:
   \   00000000   38B4               PUSH     {R3-R5}
   \   00000002   0100               MOVS     R1,R0
   1304          
   1305              AT91S_SPI *spi = BOARD_6131_SPI_BASE;
   \   00000004   ....               LDR.N    R2,??DataTable12  ;; 0x40008000
   1306              unsigned short data, i;
   1307              volatile unsigned char bufferRX[2];
   1308                  
   1309              // disable interrupts, if IRQs managed at this level
   1310              if(irq_mgmt)  __disable_interrupt();	 
   \   00000006   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0029               CMP      R1,#+0
   \   0000000A   00D0               BEQ.N    ??Read_Last_Interrupt_0
   \   0000000C   72B6               CPSID    I
   1311              // Assert SPI chip select
   1312              AT91C_BASE_PIOA->PIO_CODR = SPI_nCS; // faster than PIO_Clear(pinNss); 
   \                     ??Read_Last_Interrupt_0:
   \   0000000E   ....               LDR.N    R4,??DataTable12_1  ;; 0x400e0c34
   \   00000010   5FF48035           MOVS     R5,#+65536
   \   00000014   2560               STR      R5,[R4, #+0]
   1313              // Wait for TDR and shifter = empty
   1314              while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
   \                     ??Read_Last_Interrupt_1:
   \   00000016   1469               LDR      R4,[R2, #+16]
   \   00000018   A405               LSLS     R4,R4,#+22
   \   0000001A   FCD5               BPL.N    ??Read_Last_Interrupt_1
   1315              // Send 8-bit SPI op code 
   1316              spi->SPI_TDR = 0x58 | SPI_PCS(BOARD_6131_NPCS);
   \   0000001C   ........           LDR.W    R4,??DataTable15_6  ;; 0xe0058
   \   00000020   D460               STR      R4,[R2, #+12]
   1317              // Wait for TDRE flag (Tx Data Register Empty)
   1318              while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Read_Last_Interrupt_2:
   \   00000022   1469               LDR      R4,[R2, #+16]
   \   00000024   A407               LSLS     R4,R4,#+30
   \   00000026   FCD5               BPL.N    ??Read_Last_Interrupt_2
   1319              // Wait for RDRF flag (Rx Data Register Full)
   1320              while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
   \                     ??Read_Last_Interrupt_3:
   \   00000028   1469               LDR      R4,[R2, #+16]
   \   0000002A   E407               LSLS     R4,R4,#+31
   \   0000002C   FCD5               BPL.N    ??Read_Last_Interrupt_3
   1321              // Read received data char in Rx buffer, discard/overwrite below
   1322              bufferRX[0] = spi->SPI_RDR & 0xFFFF;
   \   0000002E   9468               LDR      R4,[R2, #+8]
   \   00000030   8DF80040           STRB     R4,[SP, #+0]
   1323          
   1324              // receive 2 bytes register data, transmit 2 dummy data bytes
   1325              for (i = 0; i < 2; i++) {
   \   00000034   0024               MOVS     R4,#+0
   \   00000036   2300               MOVS     R3,R4
   \                     ??Read_Last_Interrupt_4:
   \   00000038   9BB2               UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000003A   022B               CMP      R3,#+2
   \   0000003C   18D2               BCS.N    ??Read_Last_Interrupt_5
   1326                  // Wait for TDR and shifter = empty
   1327                  while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
   \                     ??Read_Last_Interrupt_6:
   \   0000003E   1469               LDR      R4,[R2, #+16]
   \   00000040   A405               LSLS     R4,R4,#+22
   \   00000042   FCD5               BPL.N    ??Read_Last_Interrupt_6
   1328                  // transmit dummy data to receive next byte
   1329                  spi->SPI_TDR = 0x0 | SPI_PCS(BOARD_6131_NPCS);
   \   00000044   5FF46024           MOVS     R4,#+917504
   \   00000048   D460               STR      R4,[R2, #+12]
   1330                  // Wait for TDRE flag (Tx Data Register Empty)
   1331                  while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Read_Last_Interrupt_7:
   \   0000004A   1469               LDR      R4,[R2, #+16]
   \   0000004C   A407               LSLS     R4,R4,#+30
   \   0000004E   FCD5               BPL.N    ??Read_Last_Interrupt_7
   1332                  // Wait for RDRF flag (Rx Data Register Full)
   1333                  while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
   \                     ??Read_Last_Interrupt_8:
   \   00000050   1469               LDR      R4,[R2, #+16]
   \   00000052   E407               LSLS     R4,R4,#+31
   \   00000054   FCD5               BPL.N    ??Read_Last_Interrupt_8
   1334                  // without this next delay, the ARM SPI reads wrong value in RDR!
   1335                  // I see good data shifting out from HI-6131 but RxData register value is wrong
   1336                  for (data=0; data<2; data++);
   \   00000056   0024               MOVS     R4,#+0
   \   00000058   2000               MOVS     R0,R4
   \                     ??Read_Last_Interrupt_9:
   \   0000005A   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000005C   0228               CMP      R0,#+2
   \   0000005E   01D2               BCS.N    ??Read_Last_Interrupt_10
   \   00000060   401C               ADDS     R0,R0,#+1
   \   00000062   FAE7               B.N      ??Read_Last_Interrupt_9
   1337                  // Read received data char in Rx buffer
   1338                  bufferRX[i] = spi->SPI_RDR & 0xFFFF;
   \                     ??Read_Last_Interrupt_10:
   \   00000064   9BB2               UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000066   00AC               ADD      R4,SP,#+0
   \   00000068   9568               LDR      R5,[R2, #+8]
   \   0000006A   1D55               STRB     R5,[R3, R4]
   1339              }    
   \   0000006C   5B1C               ADDS     R3,R3,#+1
   \   0000006E   E3E7               B.N      ??Read_Last_Interrupt_4
   1340              // negate slave chip select
   1341              AT91C_BASE_PIOA->PIO_SODR = SPI_nCS; // faster than PIO_Set(pinNss);
   \                     ??Read_Last_Interrupt_5:
   \   00000070   ........           LDR.W    R4,??DataTable15  ;; 0x400e0c30
   \   00000074   5FF48035           MOVS     R5,#+65536
   \   00000078   2560               STR      R5,[R4, #+0]
   1342          		
   1343              // re-enable interrupts, if IRQs managed at this level 
   1344              if(irq_mgmt)  __enable_interrupt();	
   \   0000007A   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000007C   0029               CMP      R1,#+0
   \   0000007E   00D0               BEQ.N    ??Read_Last_Interrupt_11
   \   00000080   62B6               CPSIE    I
   1345              // merge 2 data bytes into 16-bit value
   1346              data =  (unsigned int)bufferRX[0] << 8;
   \                     ??Read_Last_Interrupt_11:
   \   00000082   9DF80040           LDRB     R4,[SP, #+0]
   \   00000086   2402               LSLS     R4,R4,#+8
   \   00000088   2000               MOVS     R0,R4
   1347              data |= (unsigned int)bufferRX[1];
   \   0000008A   9DF80140           LDRB     R4,[SP, #+1]
   \   0000008E   2043               ORRS     R0,R4,R0
   1348              // return last interrupt's IAW, the MAP points to matching IIW    
   1349              return data;
   \   00000090   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000092   32BC               POP      {R1,R4,R5}
   \   00000094   7047               BX       LR               ;; return
   1350          }
   1351            
   1352          
   1353          	
   1354          // 
   1355          //  This function fills the entire HI-6131 RAM space 0x0040-0x7FFF. Each RAM
   1356          //  location is written with its memory address. Example: RAM addresses 
   1357          //  0x01BA and 0x07EF are written with values 0x01BA and 0x07EF respectively.
   1358          //
   1359          //  If exercised before RAM initialization, this RAM fill can verify locations
   1360          //  of reserved data buffers for valid transmit subaddress commands because the
   1361          //  transmitted data values indicate where the transmitted data was stored.
   1362          //
   1363          //  This function should not be used while terminal execution is enabled. 
   1364          //  Interrupts are disabled while SPI is in use. 
   1365          //
   1366          //	NOTE: Upper byte of RT Descriptor Table Control Words will not be overwritten
   1367          //      param	irq_mgmt. if zero, the calling routine manages irq enable/disable.
   1368          //	                  if non-zero, this function calls __disable_interrupt() and __enable_interrupt() locally.
   1369          //

   \                                 In section .text, align 2, keep-with-next
   1370          void Fill_6131RAM_Offset(void) {
   \                     Fill_6131RAM_Offset:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   82B0               SUB      SP,SP,#+8
   1371          
   1372              AT91S_SPI *spi = BOARD_6131_SPI_BASE;
   \   00000004   ....               LDR.N    R4,??DataTable12  ;; 0x40008000
   1373              unsigned short i;
   1374              unsigned short dummy;
   1375              volatile unsigned char bufferTX[2];
   1376                  	
   1377              __disable_interrupt();
   \   00000006   72B6               CPSID    I
   1378              enaMAP(1);
   \   00000008   0120               MOVS     R0,#+1
   \   0000000A   ........           BL       enaMAP
   1379              // read-modify-write Test Control reg 0x004D to set FRAMA
   1380              // bit allowing RT descriptor tables to write normally
   1381              Write_6131LowReg(MAP_1,0x004D,0);	
   \   0000000E   0022               MOVS     R2,#+0
   \   00000010   4D21               MOVS     R1,#+77
   \   00000012   0B20               MOVS     R0,#+11
   \   00000014   ........           BL       Write_6131LowReg
   1382              i = Read_6131_1word(0);	 
   \   00000018   0020               MOVS     R0,#+0
   \   0000001A   ........           BL       Read_6131_1word
   \   0000001E   0500               MOVS     R5,R0
   1383              Write_6131LowReg(MAP_1,0x004D,0); 
   \   00000020   0022               MOVS     R2,#+0
   \   00000022   4D21               MOVS     R1,#+77
   \   00000024   0B20               MOVS     R0,#+11
   \   00000026   ........           BL       Write_6131LowReg
   1384              Write_6131_1word(i|0x1000,0);
   \   0000002A   0021               MOVS     R1,#+0
   \   0000002C   55F48050           ORRS     R0,R5,#0x1000
   \   00000030   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000032   ........           BL       Write_6131_1word
   1385          
   1386              // Assert SPI chip select since there was an interrupt
   1387              AT91C_BASE_PIOA->PIO_CODR = SPI_nCS; // faster than PIO_Clear(pinNss); 
   \   00000036   ....               LDR.N    R0,??DataTable12_1  ;; 0x400e0c34
   \   00000038   5FF48031           MOVS     R1,#+65536
   \   0000003C   0160               STR      R1,[R0, #+0]
   1388              // Wait for TDR and shifter = empty
   1389              while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
   \                     ??Fill_6131RAM_Offset_0:
   \   0000003E   2069               LDR      R0,[R4, #+16]
   \   00000040   8005               LSLS     R0,R0,#+22
   \   00000042   FCD5               BPL.N    ??Fill_6131RAM_Offset_0
   1390              // Issue SPI op code 0xC0: write using existing MAP pointer value.
   1391              spi->SPI_TDR = 0xC0 | SPI_PCS(BOARD_6131_NPCS);
   \   00000044   ....               LDR.N    R0,??DataTable13_1  ;; 0xe00c0
   \   00000046   E060               STR      R0,[R4, #+12]
   1392              // Wait for TDRE flag (Tx Data Register Empty)
   1393              while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Fill_6131RAM_Offset_1:
   \   00000048   2069               LDR      R0,[R4, #+16]
   \   0000004A   8007               LSLS     R0,R0,#+30
   \   0000004C   FCD5               BPL.N    ??Fill_6131RAM_Offset_1
   1394              // Wait for RDRF flag (Rx Data Register Full)
   1395              while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
   \                     ??Fill_6131RAM_Offset_2:
   \   0000004E   2069               LDR      R0,[R4, #+16]
   \   00000050   C007               LSLS     R0,R0,#+31
   \   00000052   FCD5               BPL.N    ??Fill_6131RAM_Offset_2
   1396              // Read and discard received data char in Rx buffer
   1397              dummy = spi->SPI_RDR & 0xFFFF;
   \   00000054   A068               LDR      R0,[R4, #+8]
   \   00000056   0600               MOVS     R6,R0
   1398          
   1399              // write mem addr pointer with first RAM address
   1400              Write_6131LowReg(MAP_1,0x0050,0); 
   \   00000058   0022               MOVS     R2,#+0
   \   0000005A   5021               MOVS     R1,#+80
   \   0000005C   0B20               MOVS     R0,#+11
   \   0000005E   ........           BL       Write_6131LowReg
   1401              // 32K minus 80 words
   1402              for (i = 0x0050; i < 0x8000; i++) {	 
   \   00000062   5020               MOVS     R0,#+80
   \   00000064   0500               MOVS     R5,R0
   \                     ??Fill_6131RAM_Offset_3:
   \   00000066   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000068   B5F5004F           CMP      R5,#+32768
   \   0000006C   25D2               BCS.N    ??Fill_6131RAM_Offset_4
   1403          	// upper data byte
   1404          	bufferTX[0] = (char)(i >> 8);          
   \   0000006E   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000070   280A               LSRS     R0,R5,#+8
   \   00000072   8DF80000           STRB     R0,[SP, #+0]
   1405          	// lower data byte
   1406          	bufferTX[1] = (char)i; 
   \   00000076   2800               MOVS     R0,R5
   \   00000078   8DF80100           STRB     R0,[SP, #+1]
   1407          	// -------------------------------------------		
   1408                  // Wait for TDR and shifter = empty
   1409                  // while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
   1410                  // transmit next byte
   1411                  spi->SPI_TDR = bufferTX[0] | SPI_PCS(BOARD_6131_NPCS);
   \   0000007C   9DF80000           LDRB     R0,[SP, #+0]
   \   00000080   50F46020           ORRS     R0,R0,#0xE0000
   \   00000084   E060               STR      R0,[R4, #+12]
   1412                  // Wait for TDRE flag (Tx Data Register Empty)
   1413          	while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Fill_6131RAM_Offset_5:
   \   00000086   2069               LDR      R0,[R4, #+16]
   \   00000088   8007               LSLS     R0,R0,#+30
   \   0000008A   FCD5               BPL.N    ??Fill_6131RAM_Offset_5
   1414                  // Wait for RDRF flag (Rx Data Register Full)
   1415                  while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
   \                     ??Fill_6131RAM_Offset_6:
   \   0000008C   2069               LDR      R0,[R4, #+16]
   \   0000008E   C007               LSLS     R0,R0,#+31
   \   00000090   FCD5               BPL.N    ??Fill_6131RAM_Offset_6
   1416                  // Read and discard received data char in Rx buffer
   1417                   dummy = spi->SPI_RDR & 0xFFFF;
   \   00000092   A068               LDR      R0,[R4, #+8]
   \   00000094   0600               MOVS     R6,R0
   1418          	// -------------------------------------------
   1419                  // Wait for TDR and shifter = empty
   1420                  while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
   \                     ??Fill_6131RAM_Offset_7:
   \   00000096   2069               LDR      R0,[R4, #+16]
   \   00000098   8005               LSLS     R0,R0,#+22
   \   0000009A   FCD5               BPL.N    ??Fill_6131RAM_Offset_7
   1421                  // transmit next byte
   1422                  spi->SPI_TDR = bufferTX[1] | SPI_PCS(BOARD_6131_NPCS);
   \   0000009C   9DF80100           LDRB     R0,[SP, #+1]
   \   000000A0   50F46020           ORRS     R0,R0,#0xE0000
   \   000000A4   E060               STR      R0,[R4, #+12]
   1423                  // Wait for TDRE flag (Tx Data Register Empty)
   1424          	while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Fill_6131RAM_Offset_8:
   \   000000A6   2069               LDR      R0,[R4, #+16]
   \   000000A8   8007               LSLS     R0,R0,#+30
   \   000000AA   FCD5               BPL.N    ??Fill_6131RAM_Offset_8
   1425                  // Wait for RDRF flag (Rx Data Register Full)
   1426                  while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
   \                     ??Fill_6131RAM_Offset_9:
   \   000000AC   2069               LDR      R0,[R4, #+16]
   \   000000AE   C007               LSLS     R0,R0,#+31
   \   000000B0   FCD5               BPL.N    ??Fill_6131RAM_Offset_9
   1427                  // Read and discard received data char in Rx buffer
   1428                  dummy = spi->SPI_RDR & 0xFFFF;
   \   000000B2   A068               LDR      R0,[R4, #+8]
   \   000000B4   0600               MOVS     R6,R0
   1429              }
   \   000000B6   6D1C               ADDS     R5,R5,#+1
   \   000000B8   D5E7               B.N      ??Fill_6131RAM_Offset_3
   1430              // negate slave chip select
   1431              AT91C_BASE_PIOA->PIO_SODR = SPI_nCS; // faster than PIO_Set(pinNss);
   \                     ??Fill_6131RAM_Offset_4:
   \   000000BA   ........           LDR.W    R0,??DataTable15  ;; 0x400e0c30
   \   000000BE   5FF48031           MOVS     R1,#+65536
   \   000000C2   0160               STR      R1,[R0, #+0]
   1432          	
   1433              // read-modify-write Test Control reg 0x004D to reset FRAMA
   1434              Write_6131LowReg(MAP_1,0x004D,0);	
   \   000000C4   0022               MOVS     R2,#+0
   \   000000C6   4D21               MOVS     R1,#+77
   \   000000C8   0B20               MOVS     R0,#+11
   \   000000CA   ........           BL       Write_6131LowReg
   1435              i = Read_6131_1word(0);	 
   \   000000CE   0020               MOVS     R0,#+0
   \   000000D0   ........           BL       Read_6131_1word
   \   000000D4   0500               MOVS     R5,R0
   1436              Write_6131LowReg(MAP_1,0x004D,0); 
   \   000000D6   0022               MOVS     R2,#+0
   \   000000D8   4D21               MOVS     R1,#+77
   \   000000DA   0B20               MOVS     R0,#+11
   \   000000DC   ........           BL       Write_6131LowReg
   1437              Write_6131_1word((i & 0x7FFF),0);
   \   000000E0   0021               MOVS     R1,#+0
   \   000000E2   6804               LSLS     R0,R5,#+17       ;; ZeroExtS R0,R5,#+17,#+17
   \   000000E4   400C               LSRS     R0,R0,#+17
   \   000000E6   ........           BL       Write_6131_1word
   1438          
   1439              __enable_interrupt(); 
   \   000000EA   62B6               CPSIE    I
   1440              // prevent warning: variable dummy was set but never used
   1441              dummy = dummy;
   1442          }
   \   000000EC   73BD               POP      {R0,R1,R4-R6,PC}  ;; return
   1443          
   1444          
   1445          // 
   1446          // This function fills a range in HI-6131 RAM space 0x0040-0x7FFF with a specified value.
   1447          // This may be used to clear a range of RAM memory addresses
   1448          //
   1449          // This function should not be used while terminal execution is enabled, 
   1450          // Interrupts are disabled while SPI is in use. 
   1451          //
   1452          //  param 	addr is first storage address. VALUE MUST EXCEED 0x1F to avoid register space
   1453          //  param 	num_words is the number of 16-bit words to be written, MAXIMUM (0x8000-0x50) = 32688 decimal 
   1454          //  param 	fill_value, 16 bits. 0x0000 clears RAM 
   1455          ///

   \                                 In section .text, align 2, keep-with-next
   1456          void Fill_6131RAM(unsigned short addr, unsigned short num_words, unsigned short fill_value) {
   \                     Fill_6131RAM:
   \   00000000   2DE9F843           PUSH     {R3-R9,LR}
   \   00000004   0400               MOVS     R4,R0
   \   00000006   0D00               MOVS     R5,R1
   \   00000008   1600               MOVS     R6,R2
   1457          
   1458              AT91S_SPI *spi = BOARD_6131_SPI_BASE;
   \   0000000A   ....               LDR.N    R7,??DataTable15_7  ;; 0x40008000
   1459              unsigned short i;
   1460              unsigned short dummy;
   1461              volatile unsigned char bufferTX[2];
   1462                  	
   1463              __disable_interrupt();
   \   0000000C   72B6               CPSID    I
   1464              enaMAP(1);
   \   0000000E   0120               MOVS     R0,#+1
   \   00000010   ........           BL       enaMAP
   1465              // write mem addr pointer with first RAM address
   1466              Write_6131LowReg(MAP_1,addr,0); 
   \   00000014   0022               MOVS     R2,#+0
   \   00000016   2100               MOVS     R1,R4
   \   00000018   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000001A   0B20               MOVS     R0,#+11
   \   0000001C   ........           BL       Write_6131LowReg
   1467          	
   1468              // upper data byte
   1469              bufferTX[0] = (char)(fill_value >> 8);          
   \   00000020   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000022   300A               LSRS     R0,R6,#+8
   \   00000024   8DF80000           STRB     R0,[SP, #+0]
   1470              // lower data byte
   1471              bufferTX[1] = (char)fill_value; 
   \   00000028   3000               MOVS     R0,R6
   \   0000002A   8DF80100           STRB     R0,[SP, #+1]
   1472          
   1473              // Assert SPI chip select since there was an interrupt
   1474              AT91C_BASE_PIOA->PIO_CODR = SPI_nCS; // faster than PIO_Clear(pinNss); 
   \   0000002E   ....               LDR.N    R0,??DataTable15_8  ;; 0x400e0c34
   \   00000030   5FF48031           MOVS     R1,#+65536
   \   00000034   0160               STR      R1,[R0, #+0]
   1475              // Wait for TDR and shifter = empty
   1476              while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
   \                     ??Fill_6131RAM_0:
   \   00000036   3869               LDR      R0,[R7, #+16]
   \   00000038   8005               LSLS     R0,R0,#+22
   \   0000003A   FCD5               BPL.N    ??Fill_6131RAM_0
   1477              // Issue SPI op code 0xC0: write using existing MAP pointer value.
   1478              spi->SPI_TDR = 0xC0 | SPI_PCS(BOARD_6131_NPCS);
   \   0000003C   ....               LDR.N    R0,??DataTable13_1  ;; 0xe00c0
   \   0000003E   F860               STR      R0,[R7, #+12]
   1479              // Wait for TDRE flag (Tx Data Register Empty)
   1480              while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Fill_6131RAM_1:
   \   00000040   3869               LDR      R0,[R7, #+16]
   \   00000042   8007               LSLS     R0,R0,#+30
   \   00000044   FCD5               BPL.N    ??Fill_6131RAM_1
   1481              // Wait for RDRF flag (Rx Data Register Full)
   1482              while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
   \                     ??Fill_6131RAM_2:
   \   00000046   3869               LDR      R0,[R7, #+16]
   \   00000048   C007               LSLS     R0,R0,#+31
   \   0000004A   FCD5               BPL.N    ??Fill_6131RAM_2
   1483              // Read and discard received data char in Rx buffer
   1484              dummy = spi->SPI_RDR & 0xFFFF;
   \   0000004C   B868               LDR      R0,[R7, #+8]
   \   0000004E   8146               MOV      R9,R0
   1485          
   1486              for (i = num_words; i > 0; i--)	{
   \   00000050   A846               MOV      R8,R5
   \                     ??Fill_6131RAM_3:
   \   00000052   1FFA88F8           UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000056   B8F1010F           CMP      R8,#+1
   \   0000005A   22D3               BCC.N    ??Fill_6131RAM_4
   1487          
   1488          	// -------------------------------------------		
   1489                  // Wait for TDR and shifter = empty
   1490                  while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
   \                     ??Fill_6131RAM_5:
   \   0000005C   3869               LDR      R0,[R7, #+16]
   \   0000005E   8005               LSLS     R0,R0,#+22
   \   00000060   FCD5               BPL.N    ??Fill_6131RAM_5
   1491                  // transmit next byte
   1492                  spi->SPI_TDR = bufferTX[0] | SPI_PCS(BOARD_6131_NPCS);
   \   00000062   9DF80000           LDRB     R0,[SP, #+0]
   \   00000066   50F46020           ORRS     R0,R0,#0xE0000
   \   0000006A   F860               STR      R0,[R7, #+12]
   1493                  // Wait for TDRE flag (Tx Data Register Empty)
   1494          	while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Fill_6131RAM_6:
   \   0000006C   3869               LDR      R0,[R7, #+16]
   \   0000006E   8007               LSLS     R0,R0,#+30
   \   00000070   FCD5               BPL.N    ??Fill_6131RAM_6
   1495                  // Wait for RDRF flag (Rx Data Register Full)
   1496                  while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
   \                     ??Fill_6131RAM_7:
   \   00000072   3869               LDR      R0,[R7, #+16]
   \   00000074   C007               LSLS     R0,R0,#+31
   \   00000076   FCD5               BPL.N    ??Fill_6131RAM_7
   1497                  // Read and discard received data char in Rx buffer
   1498                  dummy = spi->SPI_RDR & 0xFFFF;
   \   00000078   B868               LDR      R0,[R7, #+8]
   \   0000007A   8146               MOV      R9,R0
   1499          	// -------------------------------------------
   1500                  // Wait for TDR and shifter = empty
   1501                  while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
   \                     ??Fill_6131RAM_8:
   \   0000007C   3869               LDR      R0,[R7, #+16]
   \   0000007E   8005               LSLS     R0,R0,#+22
   \   00000080   FCD5               BPL.N    ??Fill_6131RAM_8
   1502                  // transmit next byte
   1503                  spi->SPI_TDR = bufferTX[1] | SPI_PCS(BOARD_6131_NPCS);
   \   00000082   9DF80100           LDRB     R0,[SP, #+1]
   \   00000086   50F46020           ORRS     R0,R0,#0xE0000
   \   0000008A   F860               STR      R0,[R7, #+12]
   1504                  // Wait for TDRE flag (Tx Data Register Empty)
   1505          	while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Fill_6131RAM_9:
   \   0000008C   3869               LDR      R0,[R7, #+16]
   \   0000008E   8007               LSLS     R0,R0,#+30
   \   00000090   FCD5               BPL.N    ??Fill_6131RAM_9
   1506                  // Wait for RDRF flag (Rx Data Register Full)
   1507                  while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
   \                     ??Fill_6131RAM_10:
   \   00000092   3869               LDR      R0,[R7, #+16]
   \   00000094   C007               LSLS     R0,R0,#+31
   \   00000096   FCD5               BPL.N    ??Fill_6131RAM_10
   1508                  // Read and discard received data char in Rx buffer
   1509                  dummy = spi->SPI_RDR & 0xFFFF;
   \   00000098   B868               LDR      R0,[R7, #+8]
   \   0000009A   8146               MOV      R9,R0
   1510              }
   \   0000009C   B8F10108           SUBS     R8,R8,#+1
   \   000000A0   D7E7               B.N      ??Fill_6131RAM_3
   1511              // negate slave chip select
   1512              AT91C_BASE_PIOA->PIO_SODR = SPI_nCS; // faster than PIO_Set(pinNss);
   \                     ??Fill_6131RAM_4:
   \   000000A2   ....               LDR.N    R0,??DataTable15  ;; 0x400e0c30
   \   000000A4   5FF48031           MOVS     R1,#+65536
   \   000000A8   0160               STR      R1,[R0, #+0]
   1513          
   1514              __enable_interrupt(); 
   \   000000AA   62B6               CPSIE    I
   1515              // prevent warning: variable dummy was set but never used
   1516              dummy = dummy;
   1517          }
   \   000000AC   BDE8F183           POP      {R0,R4-R9,PC}    ;; return
   1518          
   1519          
   1520          // 
   1521          // This function copies 1024 words from HI-6131 register/RAM address space 
   1522          // for console screen display. This only applies for HI-6131 since HI-6130
   1523          // can use Embedded Workbench "Memory Watch Window" for the same purpose. 
   1524          //
   1525          // Press button SW2 to prompt screen refresh, This interrupts C program 
   1526          // execution and uses memory address pointer MAP4. Interrupts will temporarily
   1527          // be disabled during each SPI word transfer. After completion, the incoming 
   1528          // memory address pointer will be re-enabled. If spi_busy = 1 (indicating a 
   1529          // multi-word SPI process was interrupted) flag spi_irq will be set so the
   1530          // interrupted process can resume, assuming interrupted process uses the same
   1531          // interrupt management as this function.
   1532          

   \                                 In section .text, align 2, keep-with-next
   1533          void Memory_watch(unsigned short address) {
   \                     Memory_watch:
   \   00000000   2DE9F14F           PUSH     {R0,R4-R11,LR}
   \   00000004   82B0               SUB      SP,SP,#+8
   1534          
   1535              AT91S_SPI *spi = BOARD_6131_SPI_BASE;
   \   00000006   ....               LDR.N    R4,??DataTable15_7  ;; 0x40008000
   1536              unsigned short i,j,k,addr;
   1537              unsigned char savemap, data, mod4=0;
   \   00000008   5FF0000A           MOVS     R10,#+0
   1538              unsigned short dummy;
   1539          	
   1540               __disable_interrupt();
   \   0000000C   72B6               CPSID    I
   1541              // we will restore the active MAP when finished
   1542              savemap = (char)(getMAPaddr() - 0x000A);
   \   0000000E   ........           BL       getMAPaddr
   \   00000012   0A38               SUBS     R0,R0,#+10
   \   00000014   8DF80400           STRB     R0,[SP, #+4]
   1543              // use MAP3 
   1544              enaMAP(3);
   \   00000018   0320               MOVS     R0,#+3
   \   0000001A   ........           BL       enaMAP
   1545              addr = address & 0xFFF0;
   \   0000001E   BDF80800           LDRH     R0,[SP, #+8]
   \   00000022   4FF6F071           MOVW     R1,#+65520
   \   00000026   0840               ANDS     R0,R1,R0
   \   00000028   8046               MOV      R8,R0
   1546              Write_6131LowReg(MAP_3,addr,0); 
   \   0000002A   0022               MOVS     R2,#+0
   \   0000002C   4146               MOV      R1,R8
   \   0000002E   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000030   0D20               MOVS     R0,#+13
   \   00000032   ........           BL       Write_6131LowReg
   1547              
   1548              // variable tested by vectored interrupt routine 
   1549              spi_busy = 1;				
   \   00000036   ....               LDR.N    R0,??DataTable15_1
   \   00000038   0121               MOVS     R1,#+1
   \   0000003A   0170               STRB     R1,[R0, #+0]
   1550              // Assert SPI chip select
   1551              AT91C_BASE_PIOA->PIO_CODR = SPI_nCS; // faster than PIO_Clear(pinNss); 
   \   0000003C   ....               LDR.N    R0,??DataTable15_8  ;; 0x400e0c34
   \   0000003E   5FF48031           MOVS     R1,#+65536
   \   00000042   0160               STR      R1,[R0, #+0]
   1552              // Wait for TDR and shifter = empty
   1553              while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
   \                     ??Memory_watch_0:
   \   00000044   2069               LDR      R0,[R4, #+16]
   \   00000046   8005               LSLS     R0,R0,#+22
   \   00000048   FCD5               BPL.N    ??Memory_watch_0
   1554              // Send SPI op code 
   1555              spi->SPI_TDR = 0x40 | SPI_PCS(BOARD_6131_NPCS);
   \   0000004A   ....               LDR.N    R0,??DataTable15_9  ;; 0xe0040
   \   0000004C   E060               STR      R0,[R4, #+12]
   1556              // Wait for TDRE flag (Tx Data Register Empty)
   1557              while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Memory_watch_1:
   \   0000004E   2069               LDR      R0,[R4, #+16]
   \   00000050   8007               LSLS     R0,R0,#+30
   \   00000052   FCD5               BPL.N    ??Memory_watch_1
   1558              // Wait for RDRF flag (Rx Data Register Full)
   1559              while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
   \                     ??Memory_watch_2:
   \   00000054   2069               LDR      R0,[R4, #+16]
   \   00000056   C007               LSLS     R0,R0,#+31
   \   00000058   FCD5               BPL.N    ??Memory_watch_2
   1560              // Read and discard received data char in Rx buffer
   1561              dummy = spi->SPI_RDR;// & 0xFFFF;
   \   0000005A   A068               LDR      R0,[R4, #+8]
   \   0000005C   8346               MOV      R11,R0
   1562                                      
   1563              // 4 groups of 4 lines each
   1564              for (i = 0; i < 4; i++) { 
   \   0000005E   0020               MOVS     R0,#+0
   \   00000060   0500               MOVS     R5,R0
   \                     ??Memory_watch_3:
   \   00000062   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000064   042D               CMP      R5,#+4
   \   00000066   80F09980           BCS.W    ??Memory_watch_4
   1565          	  // 4 lines preceded by header
   1566          	  printf("\n\rx%.2X%.2X    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F", (char)(addr>>8), (char)addr);
   \   0000006A   4246               MOV      R2,R8
   \   0000006C   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000006E   1FFA88F8           UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000072   5FEA1821           LSRS     R1,R8,#+8
   \   00000076   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000078   ....               LDR.N    R0,??DataTable15_10
   \   0000007A   ........           BL       printf
   1567          	  for (j = 0; j < 4; j++) {
   \   0000007E   0020               MOVS     R0,#+0
   \   00000080   0600               MOVS     R6,R0
   \                     ??Memory_watch_5:
   \   00000082   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000084   042E               CMP      R6,#+4
   \   00000086   80F08780           BCS.W    ??Memory_watch_6
   1568          		printf("\n\r");
   \   0000008A   ....               ADR.N    R0,??DataTable15_3  ;; 0x0A, 0x0D, 0x00, 0x00
   \   0000008C   ........           BL       printf
   1569          		// 16 words / line 
   1570          		for (k = 0; k < 16; k++) {
   \   00000090   0020               MOVS     R0,#+0
   \   00000092   0700               MOVS     R7,R0
   \                     ??Memory_watch_7:
   \   00000094   BFB2               UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000096   102F               CMP      R7,#+16
   \   00000098   7CD2               BCS.N    ??Memory_watch_8
   1571                            
   1572                                  // Wait for TDR and shifter = empty
   1573          			while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
   \                     ??Memory_watch_9:
   \   0000009A   2069               LDR      R0,[R4, #+16]
   \   0000009C   8005               LSLS     R0,R0,#+22
   \   0000009E   FCD5               BPL.N    ??Memory_watch_9
   1574          			// transmit dummy data to receive upper byte
   1575          			spi->SPI_TDR = (0x00 | SPI_PCS(BOARD_6131_NPCS));
   \   000000A0   5FF46020           MOVS     R0,#+917504
   \   000000A4   E060               STR      R0,[R4, #+12]
   1576          			// Wait for TDRE flag (Tx Data Register Empty)
   1577          			while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Memory_watch_10:
   \   000000A6   2069               LDR      R0,[R4, #+16]
   \   000000A8   8007               LSLS     R0,R0,#+30
   \   000000AA   FCD5               BPL.N    ??Memory_watch_10
   1578          			// Wait for RDRF flag (Rx Data Register Full)
   1579          			while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
   \                     ??Memory_watch_11:
   \   000000AC   2069               LDR      R0,[R4, #+16]
   \   000000AE   C007               LSLS     R0,R0,#+31
   \   000000B0   FCD5               BPL.N    ??Memory_watch_11
   1580                                  // without this next delay, the ARM SPI reads wrong value in RDR!
   1581                                  // I see good data shifting out from HI-6131 but RxData register value is wrong
   1582                                  for (dummy=0; dummy<5; dummy++);
   \   000000B2   0020               MOVS     R0,#+0
   \   000000B4   8346               MOV      R11,R0
   \                     ??Memory_watch_12:
   \   000000B6   1FFA8BFB           UXTH     R11,R11          ;; ZeroExt  R11,R11,#+16,#+16
   \   000000BA   BBF1050F           CMP      R11,#+5
   \   000000BE   02D2               BCS.N    ??Memory_watch_13
   \   000000C0   1BF1010B           ADDS     R11,R11,#+1
   \   000000C4   F7E7               B.N      ??Memory_watch_12
   1583          			// Read upper byte
   1584          			data = spi->SPI_RDR;// & 0xFF;
   \                     ??Memory_watch_13:
   \   000000C6   A068               LDR      R0,[R4, #+8]
   \   000000C8   8146               MOV      R9,R0
   1585          			printf("%.2X", (char)data);
   \   000000CA   5FFA89F9           UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000CE   4946               MOV      R1,R9
   \   000000D0   ....               LDR.N    R0,??DataTable15_11
   \   000000D2   ........           BL       printf
   1586          
   1587                                  // Wait for TDR and shifter = empty
   1588                                  while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
   \                     ??Memory_watch_14:
   \   000000D6   2069               LDR      R0,[R4, #+16]
   \   000000D8   8005               LSLS     R0,R0,#+22
   \   000000DA   FCD5               BPL.N    ??Memory_watch_14
   1589          			// transmit dummy data to receive lower byte
   1590          			spi->SPI_TDR = (0x00 | SPI_PCS(BOARD_6131_NPCS));
   \   000000DC   5FF46020           MOVS     R0,#+917504
   \   000000E0   E060               STR      R0,[R4, #+12]
   1591          			// Wait for TDRE flag (Tx Data Register Empty)
   1592          			while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Memory_watch_15:
   \   000000E2   2069               LDR      R0,[R4, #+16]
   \   000000E4   8007               LSLS     R0,R0,#+30
   \   000000E6   FCD5               BPL.N    ??Memory_watch_15
   1593          			// Wait for RDRF flag (Rx Data Register Full)
   1594          			while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
   \                     ??Memory_watch_16:
   \   000000E8   2069               LDR      R0,[R4, #+16]
   \   000000EA   C007               LSLS     R0,R0,#+31
   \   000000EC   FCD5               BPL.N    ??Memory_watch_16
   1595                                  // without this next delay, the ARM SPI reads wrong value in RDR!
   1596                                  // I see good data shifting out from HI-6131 but RxData register value is wrong
   1597                                  for (dummy=0; dummy<5; dummy++);
   \   000000EE   0020               MOVS     R0,#+0
   \   000000F0   8346               MOV      R11,R0
   \                     ??Memory_watch_17:
   \   000000F2   1FFA8BFB           UXTH     R11,R11          ;; ZeroExt  R11,R11,#+16,#+16
   \   000000F6   BBF1050F           CMP      R11,#+5
   \   000000FA   02D2               BCS.N    ??Memory_watch_18
   \   000000FC   1BF1010B           ADDS     R11,R11,#+1
   \   00000100   F7E7               B.N      ??Memory_watch_17
   1598          			// Read lower byte
   1599          			data = spi->SPI_RDR;// & 0xFF;
   \                     ??Memory_watch_18:
   \   00000102   A068               LDR      R0,[R4, #+8]
   \   00000104   8146               MOV      R9,R0
   1600          			printf("%.2X ", (char)data);
   \   00000106   5FFA89F9           UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000010A   4946               MOV      R1,R9
   \   0000010C   ....               LDR.N    R0,??DataTable15_12
   \   0000010E   ........           BL       printf
   1601                                          
   1602                                  // this next part provides normal operation when reading RT Descriptor tables.
   1603                                  // MAP does not auto-increment when the next word is a descriptor Control Word.
   1604                                  // every 4th word we reload MAP to force increment, d-table words 4,8,12, etc.
   1605                                  // Behavior applies even when not accessing d-tables, AND ASSUMES RT DESCRIPTOR
   1606                                  // TABLE(S) START AT BASE ADDRESS WITH 4-LSB'S = 0, any 0xNNN0: 0x0400, 0x04F0.
   1607                                  // DESCRIPTOR TABLE START ADDRESS CANNOT EXCEED 0x7E00...
   1608          			addr++;
   \   00000112   18F10108           ADDS     R8,R8,#+1
   1609                                  mod4++;
   \   00000116   1AF1010A           ADDS     R10,R10,#+1
   1610                                  if (mod4 == 4) {
   \   0000011A   5FFA8AFA           UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000011E   BAF1040F           CMP      R10,#+4
   \   00000122   05D1               BNE.N    ??Memory_watch_19
   1611                                      mod4 = 0;
   \   00000124   0020               MOVS     R0,#+0
   \   00000126   8246               MOV      R10,R0
   1612                                      // negate slave chip select. Below we reload MAP to force increment, 
   1613                                      // then issue a new read op code 0x40 to resume read at next address
   1614                                      AT91C_BASE_PIOA->PIO_SODR = SPI_nCS; // faster than PIO_Set(pinNss);
   \   00000128   ....               LDR.N    R0,??DataTable15  ;; 0x400e0c30
   \   0000012A   5FF48031           MOVS     R1,#+65536
   \   0000012E   0160               STR      R1,[R0, #+0]
   1615                                  }
   1616          			// Before reading the next word, momentarily enable IRQs...
   1617          			__enable_interrupt();
   \                     ??Memory_watch_19:
   \   00000130   62B6               CPSIE    I
   1618          			// A pending IRQ that occurred since last disable_interrupt() will be recognized here.
   1619          			// Its int.service routine probably used SPI, disrupting our multi-word transfer. As long
   1620          			// as the interrupt routine sets the spi_irq flag, we can recover. When the interrupt is
   1621                                  // finished, execution resumes at this next disable_interrupt() call, ...
   1622          				
   1623          			__disable_interrupt();
   \   00000132   72B6               CPSID    I
   1624                                  
   1625                                  if(spi_irq) enaMAP(4);
   \   00000134   ....               LDR.N    R0,??DataTable15_2
   \   00000136   0078               LDRB     R0,[R0, #+0]
   \   00000138   0028               CMP      R0,#+0
   \   0000013A   02D0               BEQ.N    ??Memory_watch_20
   \   0000013C   0420               MOVS     R0,#+4
   \   0000013E   ........           BL       enaMAP
   1626                                    
   1627          			if(spi_irq || (mod4==0)) {
   \                     ??Memory_watch_20:
   \   00000142   ....               LDR.N    R0,??DataTable15_2
   \   00000144   0078               LDRB     R0,[R0, #+0]
   \   00000146   0028               CMP      R0,#+0
   \   00000148   04D1               BNE.N    ??Memory_watch_21
   \   0000014A   5FFA8AFA           UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000014E   BAF1000F           CMP      R10,#+0
   \   00000152   1DD1               BNE.N    ??Memory_watch_22
   1628          				spi_irq = 0;
   \                     ??Memory_watch_21:
   \   00000154   ....               LDR.N    R0,??DataTable15_2
   \   00000156   0021               MOVS     R1,#+0
   \   00000158   0170               STRB     R1,[R0, #+0]
   1629          				// Reload MAP4 with the next read address, then issue a new SPI op code 0x40
   1630                                          // to resume our multi-word read process where it left off. This occurs after
   1631                                          // interrupt, or when new mod4 = 0, i.e., addr = 0xXXX0, 0xXXX4,0xXXX8 or 0xXXXC.
   1632                                          Write_6131LowReg(MAP_3,addr,0); 
   \   0000015A   0022               MOVS     R2,#+0
   \   0000015C   4146               MOV      R1,R8
   \   0000015E   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000160   0D20               MOVS     R0,#+13
   \   00000162   ........           BL       Write_6131LowReg
   1633          				
   1634          				// Wait for TDR and shifter = empty in case spi not idle
   1635          				while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
   \                     ??Memory_watch_23:
   \   00000166   2069               LDR      R0,[R4, #+16]
   \   00000168   8005               LSLS     R0,R0,#+22
   \   0000016A   FCD5               BPL.N    ??Memory_watch_23
   1636          				// Negate then assert SPI chip select since there was an interrupt
   1637          				AT91C_BASE_PIOA->PIO_SODR = SPI_nCS; // faster than PIO_Set(pinNss);
   \   0000016C   ....               LDR.N    R0,??DataTable15  ;; 0x400e0c30
   \   0000016E   5FF48031           MOVS     R1,#+65536
   \   00000172   0160               STR      R1,[R0, #+0]
   1638          				AT91C_BASE_PIOA->PIO_CODR = SPI_nCS; // faster than PIO_Clear(pinNss); 
   \   00000174   ....               LDR.N    R0,??DataTable15_8  ;; 0x400e0c34
   \   00000176   5FF48031           MOVS     R1,#+65536
   \   0000017A   0160               STR      R1,[R0, #+0]
   1639          				// Issue SPI op code 0x40: write using existing MAP pointer value.
   1640          				spi->SPI_TDR = 0x40 | SPI_PCS(BOARD_6131_NPCS);
   \   0000017C   ....               LDR.N    R0,??DataTable15_9  ;; 0xe0040
   \   0000017E   E060               STR      R0,[R4, #+12]
   1641          				// Wait for TDRE flag (Tx Data Register Empty)
   1642          				while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??Memory_watch_24:
   \   00000180   2069               LDR      R0,[R4, #+16]
   \   00000182   8007               LSLS     R0,R0,#+30
   \   00000184   FCD5               BPL.N    ??Memory_watch_24
   1643          				// Wait for RDRF flag (Rx Data Register Full)
   1644          				while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
   \                     ??Memory_watch_25:
   \   00000186   2069               LDR      R0,[R4, #+16]
   \   00000188   C007               LSLS     R0,R0,#+31
   \   0000018A   FCD5               BPL.N    ??Memory_watch_25
   1645          				// Read and discard received data char in Rx buffer
   1646          				dummy = spi->SPI_RDR & 0xFFFF;
   \   0000018C   A068               LDR      R0,[R4, #+8]
   \   0000018E   8346               MOV      R11,R0
   1647                                  } 
   1648                                  
   1649                          }   // end for(k = 0; k < 16; k++)
   \                     ??Memory_watch_22:
   \   00000190   7F1C               ADDS     R7,R7,#+1
   \   00000192   7FE7               B.N      ??Memory_watch_7
   1650          	  }         // end for(j = 0; j < 4; j++)
   \                     ??Memory_watch_8:
   \   00000194   761C               ADDS     R6,R6,#+1
   \   00000196   74E7               B.N      ??Memory_watch_5
   1651              }               // end for (i = 0; i < 4; i++)
   \                     ??Memory_watch_6:
   \   00000198   6D1C               ADDS     R5,R5,#+1
   \   0000019A   62E7               B.N      ??Memory_watch_3
   1652              
   1653          	// negate slave chip select
   1654                  AT91C_BASE_PIOA->PIO_SODR = SPI_nCS; 
   \                     ??Memory_watch_4:
   \   0000019C   ....               LDR.N    R0,??DataTable15  ;; 0x400e0c30
   \   0000019E   5FF48031           MOVS     R1,#+65536
   \   000001A2   0160               STR      R1,[R0, #+0]
   1655          
   1656          	printf("\n\r===============================================================================");
   \   000001A4   ....               LDR.N    R0,??DataTable15_13
   \   000001A6   ........           BL       printf
   1657          	printf("\n\rKeys: (W)atch On/Off  (D)own  (U)p  (R)efresh  (A)ddress  (M)enu  ");
   \   000001AA   ....               LDR.N    R0,??DataTable15_14
   \   000001AC   ........           BL       printf
   1658                  printf("0x%.2X%.2X-0x%.2X%.2X", (char)((addr-256)>>8),(char)(addr-256),(char)((addr-1)>>8),(char)(addr-1));
   \   000001B0   4046               MOV      R0,R8
   \   000001B2   401E               SUBS     R0,R0,#+1
   \   000001B4   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001B6   0090               STR      R0,[SP, #+0]
   \   000001B8   1FFA88F8           UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000001BC   B8F10100           SUBS     R0,R8,#+1
   \   000001C0   0312               ASRS     R3,R0,#+8
   \   000001C2   DBB2               UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000001C4   4246               MOV      R2,R8
   \   000001C6   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000001C8   1FFA88F8           UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000001CC   B8F58070           SUBS     R0,R8,#+256
   \   000001D0   0112               ASRS     R1,R0,#+8
   \   000001D2   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001D4   ....               LDR.N    R0,??DataTable15_15
   \   000001D6   ........           BL       printf
   1659          	printf("\n\r===============================================================================\n\r");
   \   000001DA   ....               LDR.N    R0,??DataTable15_16
   \   000001DC   ........           BL       printf
   1660          	//          
   1661          	spi_busy = 0;
   \   000001E0   ....               LDR.N    R0,??DataTable15_1
   \   000001E2   0021               MOVS     R1,#+0
   \   000001E4   0170               STRB     R1,[R0, #+0]
   1662                  // prevent warning
   1663                  dummy = dummy;
   1664                  
   1665          	// restore original MAP
   1666          	enaMAP(savemap);
   \   000001E6   9DF80400           LDRB     R0,[SP, #+4]
   \   000001EA   ........           BL       enaMAP
   1667                  
   1668          	__enable_interrupt();
   \   000001EE   62B6               CPSIE    I
   1669                  
   1670          }    // end 
   \   000001F0   BDE8F78F           POP      {R0-R2,R4-R11,PC}  ;; return
   1671          
   1672          /*	                 80 x 24 fomatting for above fctn
   1673                   1         2         3         4         5         6         7         8
   1674          12345678901234567890123456789012345678901234567890123456789012345678901234567890
   1675          
   1676          6000    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
   1677          0000 1111 2222 3333 4444 5555 6666 7777 8888 9999 AAAA BBBB CCCC DDDD EEEE FFFF
   1678          0000 1111 2222 3333 4444 5555 6666 7777 8888 9999 AAAA BBBB CCCC DDDD EEEE FFFF
   1679          0000 1111 2222 3333 4444 5555 6666 7777 8888 9999 AAAA BBBB CCCC DDDD EEEE FFFF
   1680          0000 1111 2222 3333 4444 5555 6666 7777 8888 9999 AAAA BBBB CCCC DDDD EEEE FFFF
   1681          6040    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
   1682          0000 1111 2222 3333 4444 5555 6666 7777 8888 9999 AAAA BBBB CCCC DDDD EEEE FFFF
   1683          0000 1111 2222 3333 4444 5555 6666 7777 8888 9999 AAAA BBBB CCCC DDDD EEEE FFFF
   1684          0000 1111 2222 3333 4444 5555 6666 7777 8888 9999 AAAA BBBB CCCC DDDD EEEE FFFF
   1685          0000 1111 2222 3333 4444 5555 6666 7777 8888 9999 AAAA BBBB CCCC DDDD EEEE FFFF
   1686          6080    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
   1687          0000 1111 2222 3333 4444 5555 6666 7777 8888 9999 AAAA BBBB CCCC DDDD EEEE FFFF
   1688          0000 1111 2222 3333 4444 5555 6666 7777 8888 9999 AAAA BBBB CCCC DDDD EEEE FFFF
   1689          0000 1111 2222 3333 4444 5555 6666 7777 8888 9999 AAAA BBBB CCCC DDDD EEEE FFFF
   1690          0000 1111 2222 3333 4444 5555 6666 7777 8888 9999 AAAA BBBB CCCC DDDD EEEE FFFF
   1691          60C0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
   1692          0000 1111 2222 3333 4444 5555 6666 7777 8888 9999 AAAA BBBB CCCC DDDD EEEE FFFF
   1693          0000 1111 2222 3333 4444 5555 6666 7777 8888 9999 AAAA BBBB CCCC DDDD EEEE FFFF
   1694          0000 1111 2222 3333 4444 5555 6666 7777 8888 9999 AAAA BBBB CCCC DDDD EEEE FFFF
   1695          0000 1111 2222 3333 4444 5555 6666 7777 8888 9999 AAAA BBBB CCCC DDDD EEEE FFFF
   1696          ===============================================================================
   1697          'M' toggles HI-6131 memory watch on/off.  'U' or 'D' scrolls addr range up/down
   1698          'A' for new start address entry.      '0' (zero) displays the main console menu
   1699          ================    PRESS BOARD BUTTON SW1 TO REFRESH SCREEN   ================
   1700          */
   1701          
   1702          
   1703          
   1704          //      This function returns the address of the currently enabled Memory Address Pointer
   1705          //      register, either 0x000B, 0x000C, 0x000D or 0x000E
   1706          //

   \                                 In section .text, align 2, keep-with-next
   1707          unsigned short getMAPaddr(void) {
   \                     getMAPaddr:
   \   00000000   10B5               PUSH     {R4,LR}
   1708                // bits 11-10 of Master Configuration reg
   1709                unsigned short i;
   1710                i = Read_6131LowReg(MASTER_CONFIG_REG, 1) >> 10;
   \   00000002   0121               MOVS     R1,#+1
   \   00000004   0020               MOVS     R0,#+0
   \   00000006   ........           BL       Read_6131LowReg
   \   0000000A   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000C   800A               LSRS     R0,R0,#+10
   \   0000000E   0400               MOVS     R4,R0
   1711                i = 0x000B + (i & 0x0003);
   \   00000010   14F00300           ANDS     R0,R4,#0x3
   \   00000014   10F10B04           ADDS     R4,R0,#+11
   1712                return i;
   \   00000018   2000               MOVS     R0,R4
   \   0000001A   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001C   10BD               POP      {R4,PC}          ;; return
   1713          }
   1714          
   1715          
   1716          
   1717          //      This function enables the Memory Address Pointer specified by the map_num parameter.
   1718          //      param   map_num must be: 1 enables MAP1 at register address 0x000B, 
   1719          //                               2 enables MAP2 at register address 0x000C, 
   1720          //                               3 enables MAP3 at register address 0x000D 
   1721          //                            or 4 enables MAP4 at register address 0x000E
   1722          //

   \                                 In section .text, align 2, keep-with-next
   1723          void enaMAP(unsigned char map_num) {
   \                     enaMAP:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0400               MOVS     R4,R0
   1724                // read-modify-write Master Configuration reg, updating bits 11-10
   1725                unsigned short i;
   1726                unsigned short j = (map_num-1) << 10;
   \   00000004   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   601E               SUBS     R0,R4,#+1
   \   00000008   8602               LSLS     R6,R0,#+10
   1727                // j = 0 for MAP1, 0x0400 for MAP2, 0x0800 for MAP3, 0x0C00 for MAP4
   1728                i = Read_6131LowReg(MASTER_CONFIG_REG, 1) & ~0x0C00;
   \   0000000A   0121               MOVS     R1,#+1
   \   0000000C   0020               MOVS     R0,#+0
   \   0000000E   ........           BL       Read_6131LowReg
   \   00000012   4FF2FF31           MOVW     R1,#+62463
   \   00000016   0840               ANDS     R0,R1,R0
   \   00000018   0500               MOVS     R5,R0
   1729                j |= i;
   \   0000001A   2E43               ORRS     R6,R5,R6
   1730                Write_6131LowReg(MASTER_CONFIG_REG, j, 1);
   \   0000001C   0122               MOVS     R2,#+1
   \   0000001E   3100               MOVS     R1,R6
   \   00000020   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000022   0020               MOVS     R0,#+0
   \   00000024   ........           BL       Write_6131LowReg
   1731          }
   \   00000028   70BD               POP      {R4-R6,PC}       ;; return
   1732                
   1733          
   1734          
   1735          //-----------------------------------------------------------------------------
   1736          /// Initialization of the ARM Cortex M3 SPI for communication with the HI-6131
   1737          //-----------------------------------------------------------------------------
   1738          

   \                                 In section .text, align 2, keep-with-next
   1739          void Configure_ARM_MCU_SPI(void) {
   \                     Configure_ARM_MCU_SPI:
   \   00000000   80B5               PUSH     {R7,LR}
   1740            
   1741              volatile unsigned int uDummy;
   1742                
   1743              // Configure pins
   1744              PIO_Configure(pinsSPI, PIO_LISTSIZE(pinsSPI));
   \   00000002   0421               MOVS     R1,#+4
   \   00000004   ....               LDR.N    R0,??DataTable15_17
   \   00000006   ........           BL       PIO_Configure
   1745                                
   1746              // write SPI Mode register
   1747              SPI_Configure(AT91C_BASE_SPI0,
   1748                            AT91C_ID_SPI0,
   1749                            ((1 << 0) |   // SPI Master
   1750                             (0 << 1) |   // PS = fixed peripheral select
   1751                             (0 << 2) |   // PSDEC = chip selects directly connect to peripheral devices
   1752                             (1 << 4) |   // mode fault detect disabled
   1753                             (0 << 5) |   // WDRBT = 0 Master can init new transfer whether/not RxD reg has unread data
   1754                             (0 << 7) |   // LLB = 0 Local loopback path disabled
   1755                             (0xE << 16)| // PCS for chip select 0.
   1756                             (0x00 << 24))// DLYBCS delay from NPCS inactive to the activation of another NPCS
   1757              );                          // If DLYBCS < or = 6 then 6 MCK periods are inserted by default.                     
   \   0000000A   ....               LDR.N    R2,??DataTable15_18  ;; 0xe0011
   \   0000000C   1421               MOVS     R1,#+20
   \   0000000E   ....               LDR.N    R0,??DataTable15_7  ;; 0x40008000
   \   00000010   ........           BL       SPI_Configure
   1758          
   1759          
   1760              // write SPI chip select reg for NPCS0
   1761              SPI_ConfigureNPCS(AT91C_BASE_SPI0, 
   1762                                BOARD_6131_NPCS,
   1763                                ((0 << 0)  | // CPOL = SCK inactive state = 0
   1764                                 (1 << 1)  | // NCPHA read data SCK leading edge, chg data trailing edge
   1765                                 (0 << 2)  | // CSNAAT = 0
   1766                                 (0 << 3)  | // CSAAT = 0
   1767                                 (0 << 4)  | // BITS = 8 bit transfers
   1768                                 (3 << 8)  | // SCBR gives SCK = MCLK/N = 48MHz/3 = 16MHz 
   1769                                 (12 << 16)| // DLYBS dly between nCS-SCK = N/MCLK = 12/48 = .25uS
   1770                                 (1 << 24) ) // DLYBCT dly between transfers N x 32/MCLK = 32/48 = .67uS
   1771              );
   \   00000014   ....               LDR.N    R2,??DataTable15_19  ;; 0x10c0302
   \   00000016   0021               MOVS     R1,#+0
   \   00000018   ....               LDR.N    R0,??DataTable15_7  ;; 0x40008000
   \   0000001A   ........           BL       SPI_ConfigureNPCS
   1772              
   1773              
   1774              SPI_Enable(AT91C_BASE_SPI0);
   \   0000001E   ....               LDR.N    R0,??DataTable15_7  ;; 0x40008000
   \   00000020   ........           BL       SPI_Enable
   1775          
   1776              for (uDummy=0; uDummy<100000; uDummy++);
   \   00000024   0020               MOVS     R0,#+0
   \   00000026   0090               STR      R0,[SP, #+0]
   \                     ??Configure_ARM_MCU_SPI_0:
   \   00000028   0098               LDR      R0,[SP, #+0]
   \   0000002A   ....               LDR.N    R1,??DataTable15_20  ;; 0x186a0
   \   0000002C   8842               CMP      R0,R1
   \   0000002E   03D2               BCS.N    ??Configure_ARM_MCU_SPI_1
   \   00000030   0098               LDR      R0,[SP, #+0]
   \   00000032   401C               ADDS     R0,R0,#+1
   \   00000034   0090               STR      R0,[SP, #+0]
   \   00000036   F7E7               B.N      ??Configure_ARM_MCU_SPI_0
   1777          
   1778              uDummy = AT91C_BASE_SPI0->SPI_SR;
   \                     ??Configure_ARM_MCU_SPI_1:
   \   00000038   ....               LDR.N    R0,??DataTable15_21  ;; 0x40008010
   \   0000003A   0068               LDR      R0,[R0, #+0]
   \   0000003C   0090               STR      R0,[SP, #+0]
   1779              uDummy = AT91C_BASE_SPI0->SPI_RDR;
   \   0000003E   ....               LDR.N    R0,??DataTable15_22  ;; 0x40008008
   \   00000040   0068               LDR      R0,[R0, #+0]
   \   00000042   0090               STR      R0,[SP, #+0]
   1780          
   1781          }   // end Configure_ARM_MCU_SPI()
   \   00000044   01BD               POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   00800040           DC32     0x40008000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   340C0E40           DC32     0x400e0c34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   300C0E40           DC32     0x400e0c30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   C0000E00           DC32     0xe00c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   40000E00           DC32     0xe0040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   300C0E40           DC32     0x400e0c30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   ........           DC32     spi_busy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   ........           DC32     spi_irq

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0A0D0000           DC8      0x0A, 0x0D, 0x00, 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   ........           DC32     read_data

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \   00000000   60000E00           DC32     0xe0060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \   00000000   58000E00           DC32     0xe0058

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_7:
   \   00000000   00800040           DC32     0x40008000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_8:
   \   00000000   340C0E40           DC32     0x400e0c34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_9:
   \   00000000   40000E00           DC32     0xe0040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_10:
   \   00000000   ........           DC32     `?<Constant "\\n\\rx%.2X%.2X    1    2...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_11:
   \   00000000   ........           DC32     `?<Constant "%.2X">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_12:
   \   00000000   ........           DC32     `?<Constant "%.2X ">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_13:
   \   00000000   ........           DC32     `?<Constant "\\n\\r===================...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_14:
   \   00000000   ........           DC32     `?<Constant "\\n\\rKeys: (W)atch On/Of...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_15:
   \   00000000   ........           DC32     `?<Constant "0x%.2X%.2X-0x%.2X%.2X">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_16:
   \   00000000   ........           DC32     `?<Constant "\\n\\r===================...">_1`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_17:
   \   00000000   ........           DC32     pinsSPI

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_18:
   \   00000000   11000E00           DC32     0xe0011

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_19:
   \   00000000   02030C01           DC32     0x10c0302

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_20:
   \   00000000   A0860100           DC32     0x186a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_21:
   \   00000000   10800040           DC32     0x40008010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_22:
   \   00000000   08800040           DC32     0x40008008

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\rx%.2X%.2X    1    2...">`:
   \   00000000   0A0D78252E32       DC8 0AH, 0DH, 78H, 25H, 2EH, 32H, 58H, 25H
   \              5825        
   \   00000008   2E3258202020       DC8 2EH, 32H, 58H, 20H, 20H, 20H, 20H, 31H
   \              2031        
   \   00000010   202020203220       DC8 20H, 20H, 20H, 20H, 32H, 20H, 20H, 20H
   \              2020        
   \   00000018   203320202020       DC8 20H, 33H, 20H, 20H, 20H, 20H, 34H, 20H
   \              3420        
   \   00000020   202020352020       DC8 20H, 20H, 20H, 35H, 20H, 20H, 20H, 20H
   \              2020        
   \   00000028   362020202037       DC8 36H, 20H, 20H, 20H, 20H, 37H, 20H, 20H
   \              2020        
   \   00000030   202038202020       DC8 20H, 20H, 38H, 20H, 20H, 20H, 20H, 39H
   \              2039        
   \   00000038   202020204120       DC8 20H, 20H, 20H, 20H, 41H, 20H, 20H, 20H
   \              2020        
   \   00000040   204220202020       DC8 20H, 42H, 20H, 20H, 20H, 20H, 43H, 20H
   \              4320        
   \   00000048   202020442020       DC8 20H, 20H, 20H, 44H, 20H, 20H, 20H, 20H
   \              2020        
   \   00000050   452020202046       DC8 45H, 20H, 20H, 20H, 20H, 46H, 0
   \              00          
   \   00000057   00                 DC8 0

   \                                 In section .rodata, align 4
   \   00000000   0A0D00             DC8 "\012\015"
   \   00000003   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "%.2X">`:
   \   00000000   252E325800         DC8 "%.2X"
   \   00000005   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "%.2X ">`:
   \   00000000   252E32582000       DC8 "%.2X "
   \   00000006   0000               DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\r===================...">`:
   \   00000000   0A0D3D3D3D3D       DC8 0AH, 0DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              3D3D        
   \   00000008   3D3D3D3D3D3D       DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              3D3D        
   \   00000010   3D3D3D3D3D3D       DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              3D3D        
   \   00000018   3D3D3D3D3D3D       DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              3D3D        
   \   00000020   3D3D3D3D3D3D       DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              3D3D        
   \   00000028   3D3D3D3D3D3D       DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              3D3D        
   \   00000030   3D3D3D3D3D3D       DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              3D3D        
   \   00000038   3D3D3D3D3D3D       DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              3D3D        
   \   00000040   3D3D3D3D3D3D       DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              3D3D        
   \   00000048   3D3D3D3D3D3D       DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              3D3D        
   \   00000050   3D00               DC8 3DH, 0
   \   00000052   0000               DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\rKeys: (W)atch On/Of...">`:
   \   00000000   0A0D4B657973       DC8 0AH, 0DH, 4BH, 65H, 79H, 73H, 3AH, 20H
   \              3A20        
   \   00000008   285729617463       DC8 28H, 57H, 29H, 61H, 74H, 63H, 68H, 20H
   \              6820        
   \   00000010   4F6E2F4F6666       DC8 4FH, 6EH, 2FH, 4FH, 66H, 66H, 20H, 20H
   \              2020        
   \   00000018   2844296F776E       DC8 28H, 44H, 29H, 6FH, 77H, 6EH, 20H, 20H
   \              2020        
   \   00000020   285529702020       DC8 28H, 55H, 29H, 70H, 20H, 20H, 28H, 52H
   \              2852        
   \   00000028   296566726573       DC8 29H, 65H, 66H, 72H, 65H, 73H, 68H, 20H
   \              6820        
   \   00000030   202841296464       DC8 20H, 28H, 41H, 29H, 64H, 64H, 72H, 65H
   \              7265        
   \   00000038   73732020284D       DC8 73H, 73H, 20H, 20H, 28H, 4DH, 29H, 65H
   \              2965        
   \   00000040   6E75202000         DC8 6EH, 75H, 20H, 20H, 0
   \   00000045   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "0x%.2X%.2X-0x%.2X%.2X">`:
   \   00000000   3078252E3258       DC8 "0x%.2X%.2X-0x%.2X%.2X"
   \              252E32582D30
   \              78252E325825
   \              2E325800    
   \   00000016   0000               DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\r===================...">_1`:
   \   00000000   0A0D3D3D3D3D       DC8 0AH, 0DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              3D3D        
   \   00000008   3D3D3D3D3D3D       DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              3D3D        
   \   00000010   3D3D3D3D3D3D       DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              3D3D        
   \   00000018   3D3D3D3D3D3D       DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              3D3D        
   \   00000020   3D3D3D3D3D3D       DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              3D3D        
   \   00000028   3D3D3D3D3D3D       DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              3D3D        
   \   00000030   3D3D3D3D3D3D       DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              3D3D        
   \   00000038   3D3D3D3D3D3D       DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              3D3D        
   \   00000040   3D3D3D3D3D3D       DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              3D3D        
   \   00000048   3D3D3D3D3D3D       DC8 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH, 3DH
   \              3D3D        
   \   00000050   3D0A0D00           DC8 3DH, 0AH, 0DH, 0
   1782          
   1783          
   1784          
   1785          /*
   1786          //	next function was created specifically to demonstrate a method for
   1787          //	SPI interrupt management. The function performs a 32-word sequential
   1788          //	read from the top 32 words in HI-6131 RAM (0x7FE0-0x7FFF). The status
   1789          //	flags spi_busy and spi_int support controlled recognition of vectored 
   1790          //	message interrupts that can break into this foreground sequential access.
   1791          //	The memory data pointer is restored and a new op code is issued to
   1792          //	allow the foreground 32-word fetch to reach completion. To support
   1793          //	debug, the function ends by copying the 32 words read from HI-6131 RAM
   1794          //	into ZNEO processor RAM, where the Memory Watch debug window can confirm
   1795          //	proper data was read, 0x0101, 0x0202 ... 0x2121 to 0x3232. (set Memory
   1796          //	Watch window to start address M#00FFB00 and 4 bytes/row.
   1797          //	Data is displayed only when program execution is stopped.
   1798          //
   1799          //	Function spiTest_setup() should run once, before calling this test...
   1800          //	For convenience in testing, any receive command for subaddress 30 will
   1801          //	generate an IWA (interrupt when accessed) message interrupt that can
   1802          //	break into this process
   1803          //
   1804          //	IF USING VECTORED INTERRRUPTS WITH HI-6131, ALL N-WORD SEQUENTIAL 
   1805          //	READ/WRITE PROCESSES SHOULD USE AN IRQ MANAGEMENT SCHEME LIKE THIS
   1806          //
   1807          //  param	irq_mgmt. if zero, the calling routine manages irq enable/disable.
   1808          //	                  if non-zero, this function calls __disable_interrupt() and __enable_interrupt() locally.
   1809          ///
   1810          void spiIRQtest(void) {
   1811          
   1812          	unsigned short i, data, ram_array[32];
   1813          	unsigned char number_of_words = 32;
   1814          
   1815          	__disable_interrupt();					// disable interrupts for about 11us, until
   1816          						// top of word counting "for loop" below 
   1817          
   1818          	spi_busy = 1;				// global variable tested by vectored IRQ routine 
   1819          
   1820          	// write memory address pointer, point to data in HI-6131 RAM
   1821          	// that was written earlier by function spiTest_setup() called in main()  
   1822          	Write_6131LowReg(MEM_ADDR_PTR,0x7FE0,0);
   1823          
   1824          	ESPITDCR = 0x01;		// Assert SPI chip select but leave TEOF bit low 
   1825          	ESPIDATA = 0x40;		// Send SPI op code to read, w/o mem pointer pre-increment 
   1826          	while (!(ESPISTAT & RDRF));	// Wait for RDRF flag (Rx Data Register Full) 
   1827          	data = ESPIDATA;		// Read and discard received data char in Rx buffer 
   1828          
   1829          
   1830          	for (i = 0; i < number_of_words; i++) {
   1831          
   1832          		__enable_interrupt();
   1833          		// Before reading the next word, momentarily enable IRQs...
   1834          		// A pending IRQ that occurred since last __disable_interrupt() will be recognized here.
   1835          		// Its ISR (int.svc routine) will execute, probably using SPI, disrupting 
   1836          		// our multi-word transfer. This example program briefly allows interrupts 
   1837          		// once every 4us or so while in this "for loop". The interrupt ISR sets 
   1838          		// the spi_irq flag, then execution resumes at this next __disable_interrupt() call...   
   1839          		__disable_interrupt();
   1840          
   1841          		if(spi_irq) {	// detect IRQ that used SPI
   1842          
   1843          			// the multi-word transfer was disturbed, but the interrupt's
   1844          			// ISR should have restored reg 15, the Memory Address Pointer,
   1845          			// so it points to the next word to be read. Issue a new SPI op
   1846          			// code to resume a multi-word read process, starting at the 
   1847          			// RAM location addressed by the restored Mem Address Pointer value. 
   1848          
   1849          			ESPITDCR = 0x01;		// Assert SPI chip select but leave TEOF bit low 
   1850          			ESPIDATA = 0x40;		// Send SPI op code: READ = 0x40, WRITE = 0xC0 
   1851          			while (!(ESPISTAT & RDRF));	// Wait for RDRF flag (Rx Data Register Full) 
   1852          			data = ESPIDATA;		// Read and discard received data char in Rx buffer 
   1853          			spi_irq = 0;			// reset global variable set by IRQ 
   1854          		}
   1855          							// Read the next word 
   1856          		ESPIDATA = 0;				// Dummy data for transmit buffer 
   1857          		while (!(ESPISTAT & RDRF));		// Wait for RDRF flag (Rx Data Register Full) 	
   1858          		ESPIDATA = 0;				// Dummy data for transmit buffer 
   1859          		data = ESPIDATA << 8;			// Read upper byte from Rx buffer and left-shift 
   1860          		while (!(ESPISTAT & RDRF));		// Wait for RDRF flag (Rx Data Register Full) 
   1861          		data += ESPIDATA;			// Read lower byte from Rx buffer, append it to data word 
   1862          		ram_array[i] = data;
   1863          	}
   1864          
   1865          	ESPITDCR = 0x00;				// Negate SPI chip select 
   1866          	spi_busy = 0;					// reset global variable 
   1867          
   1868          
   1869          	// FOR DEBUG VERIFICATION ONLY, copy the read data array to 
   1870          	// internal processor RAM so it can be	viewed in Memory Watch window.
   1871          	// Set breakpoint at __enable_interrupt() below, and set watch window start address to 
   1872          	// M#00FFB060 to confirm 32-word read data values 0x0101 - 0x3232 
   1873          	for (i = 0; i < number_of_words; i++) {
   1874          		// first overwrite RAM with 0xFFFF so old data 
   1875          		// doesn't mask a read failure in this cycle 
   1876          		*(far unsigned short *)(0xFFB060 + (i<<1)) = 0xFFFF;
   1877          		// copy read data 
   1878          		*(far unsigned short *)(0xFFB060 + (i<<1)) = ram_array[i];
   1879          	}
   1880          
   1881          
   1882          	__enable_interrupt();						// enable interrupts 
   1883          }
   1884          
   1885          
   1886          
   1887          //
   1888          //	special test function loads data to top 32 words in HI-6131 RAM
   1889          //
   1890          //	here are the top 32 words in the RAM after running function below:
   1891          //		==========================================================
   1892          //		ADDR	0x7FE0,0x7FE1,0x7FE2,0x7FE3,0x7FE4,0x7FE5,0x7FE6,0x7FE7,
   1893          //		DATA 	0x0101,0x0202,0x0303,0x0404,0x0505,0x0606,0x0707,0x0808,
   1894          //		==========================================================
   1895          //		ADDR	0x7FE8,0x7FE9,0x7FEA,0x7FEB,0x7FEC,0x7FED,0x7FEE,0x7FEF
   1896          //		DATA	0x0909,0x1010,0x1111,0x1212,0x1313,0x1414,0x1515,0x1616
   1897          //		==========================================================		
   1898          // 		ADDR	0x7FF0,0x7FF1,0x7FF2,0x7FF3,0x7FF4,0x7FF5,0x7FF6,0x7FF7,
   1899          //		DATA 	0x1717,0x1818,0x1919,0x2020,0x2121,0x2222,0x2323,0x2424,
   1900          // 		==========================================================
   1901          //		ADDR	0x7FF8,0x7FF9,0x7FFA,0x7FFB,0x7FFC,0x7FFD,0x7FFE,0x7FFF
   1902          //		DATA	0x2525,0x2626,0x2727,0x2828,0x2929,0x3030,0x3131,0x3232
   1903          //		==========================================================
   1904          //  param	irq_mgmt. if zero, the calling routine manages irq enable/disable.
   1905          //                        if non-zero, this function calls __disable_interrupt() and __enable_interrupt() locally.
   1906          ///
   1907          void spiTest_setup(void) {
   1908          
   1909          	unsigned short num_words=32;
   1910          
   1911          	unsigned short spi_write_data[32] = {0x0101,0x0202,0x0303,0x0404,
   1912          					0x0505,0x0606,0x0707,0x0808,
   1913          					0x0909,0x1010,0x1111,0x1212,
   1914          					0x1313,0x1414,0x1515,0x1616,
   1915          					0x1717,0x1818,0x1919,0x2020,
   1916          					0x2121,0x2222,0x2323,0x2424,
   1917          					0x2525,0x2626,0x2727,0x2828,
   1918          					0x2929,0x3030,0x3131,0x3232};
   1919          
   1920          	// disable interrupts, manage IRQs at this level, 
   1921          	// no  EI/DI switching by the called SPI functions 
   1922          	__disable_interrupt();
   1923          
   1924          	// write addr 0x7FE0 to mem addr pointer 
   1925          	Write_6131LowReg(MEM_ADDR_PTR,0x7FE0,0); 	
   1926          	
   1927          	// next write N consec words from spi_write_data[] array 
   1928          	Write_6131(spi_write_data,num_words,0,0);
   1929          
   1930          	// enable interrupts 
   1931          	__enable_interrupt();
   1932          }
   1933          
   1934          */
   1935          
   1936          
   1937          // End of file 

   Maximum stack usage in bytes:

     Function                  .cstack
     --------                  -------
     Configure_ARM_MCU_SPI          8
     Fill_6131RAM                  32
     Fill_6131RAM_Offset           24
     Memory_watch                  48
     ReadWord_Adv4                 12
     Read_6131                     20
     Read_6131LowReg               16
     Read_6131_1word               12
     Read_6131_Buffer              20
     Read_Current_Control_Word     20
     Read_Last_Interrupt           12
     Read_RT1_Control_Word         32
     Read_RT2_Control_Word         32
     SPIopcode                      4
     Write_6131                    16
     Write_6131LowReg              16
     Write_6131_1word              16
     Write_6131_Buffer             16
     enaMAP                        16
     getMAPaddr                     8


   Section sizes:

     Function/Label                             Bytes
     --------------                             -----
     pinsSPI                                     128
     spi_busy                                      1
     spi_irq                                       1
     read_data                                   512
     SPIopcode                                    78
     Write_6131LowReg                            130
     Read_6131LowReg                             170
     Write_6131_1word                            130
     Read_6131_1word                             154
     Write_6131                                  248
     Read_6131                                   268
     Write_6131_Buffer                           222
     Read_6131_Buffer                            324
     Read_Current_Control_Word                   198
     Read_RT1_Control_Word                       216
     Read_RT2_Control_Word                       216
     ReadWord_Adv4                               150
     Read_Last_Interrupt                         150
     Fill_6131RAM_Offset                         238
     Fill_6131RAM                                176
     Memory_watch                                500
     getMAPaddr                                   30
     enaMAP                                       42
     Configure_ARM_MCU_SPI                        70
     ??DataTable12                                 4
     ??DataTable12_1                               4
     ??DataTable13                                 4
     ??DataTable13_1                               4
     ??DataTable13_2                               4
     ??DataTable15                                 4
     ??DataTable15_1                               4
     ??DataTable15_2                               4
     ??DataTable15_3                               4
     ??DataTable15_4                               4
     ??DataTable15_5                               4
     ??DataTable15_6                               4
     ??DataTable15_7                               4
     ??DataTable15_8                               4
     ??DataTable15_9                               4
     ??DataTable15_10                              4
     ??DataTable15_11                              4
     ??DataTable15_12                              4
     ??DataTable15_13                              4
     ??DataTable15_14                              4
     ??DataTable15_15                              4
     ??DataTable15_16                              4
     ??DataTable15_17                              4
     ??DataTable15_18                              4
     ??DataTable15_19                              4
     ??DataTable15_20                              4
     ??DataTable15_21                              4
     ??DataTable15_22                              4
     ?<Constant "\n\rx%.2X%.2X    1    2...">     88
     ?<Constant "\n\r">                            4
     ?<Constant "%.2X">                            8
     ?<Constant "%.2X ">                           8
     ?<Constant "\n\r===================...">     84
     ?<Constant "\n\rKeys: (W)atch On/Of...">     72
     ?<Constant "0x%.2X%.2X-0x%.2X%.2X">          24
     ?<Constant "\n\r===================...">_1   84

 
   514 bytes in section .bss
   500 bytes in section .rodata
 3 822 bytes in section .text
 
 3 822 bytes of CODE  memory
   500 bytes of CONST memory
   514 bytes of DATA  memory

Errors: none
Warnings: none
