###############################################################################
#                                                                             #
#                                                       18/Jun/2012  10:26:32 #
# IAR ANSI C/C++ Compiler V6.21.1.32794/W32 KICKSTART for ARM                 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Program Files\IAR Systems\Embedded Workbench 6.0      #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\main.c                           #
#    Command line =  "C:\Program Files\IAR Systems\Embedded Workbench 6.0     #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\main.c" -D at91sam3u4 -D flash   #
#                    -D TRACE_LEVEL=4 -D BC_ena=0 -D RT2_ena=1 -D RT1_ena=1   #
#                    -D SMT_ena=0 -D IMT_ena=1 -lC "C:\Program Files\IAR      #
#                    Systems\Embedded Workbench 6.0                           #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\ewp\RT_IMT\List\" --remarks      #
#                    --diag_suppress Pe826,Pe1375,Pe068 -o "C:\Program        #
#                    Files\IAR Systems\Embedded Workbench 6.0                 #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\ewp\RT_IMT\Obj\" --no_cse        #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench 6.0                 #
#                    Kickstart_2\arm\INC\c\DLib_Config_Full.h" -I             #
#                    "C:\Program Files\IAR Systems\Embedded Workbench 6.0     #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\ewp\..\..\..\at91lib/peripherals #
#                    \" -I "C:\Program Files\IAR Systems\Embedded Workbench   #
#                    6.0 Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt    #
#                    HI-6130-40 EBI Demo 2_0\ewp\..\..\..\at91lib/components\ #
#                    " -I "C:\Program Files\IAR Systems\Embedded Workbench    #
#                    6.0 Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt    #
#                    HI-6130-40 EBI Demo 2_0\ewp\..\..\..\at91lib\" -I        #
#                    "C:\Program Files\IAR Systems\Embedded Workbench 6.0     #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\ewp\..\..\..\external_libs\" -I  #
#                    "C:\Program Files\IAR Systems\Embedded Workbench 6.0     #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\ewp\..\..\..\at91lib/boards/at91 #
#                    sam3u-ek\" --cpu_mode thumb -On --use_c++_inline         #
#    List file    =  C:\Program Files\IAR Systems\Embedded Workbench 6.0      #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\ewp\RT_IMT\List\main.lst         #
#    Object file  =  C:\Program Files\IAR Systems\Embedded Workbench 6.0      #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\ewp\RT_IMT\Obj\main.o            #
#                                                                             #
#                                                                             #
###############################################################################

C:\Program Files\IAR Systems\Embedded Workbench 6.0 Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt HI-6130-40 EBI Demo 2_0\main.c
      1          /* ----------------------------------------------------------------------------
      2           *            HOLT INTEGRATED CIRCUITS Applications Engineering
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2011, Holt Integrated Circuits
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Holt's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16          
     17           * ==============================================================================
     18           * Version 2.0
     19           * This version support the HI-6130 and HI-6140.
     20           * Seven Configurations are provided to build customized versions of this project.
     21           * These defines were previously included in the 613x_initialization.h header file to allow
     22           * customized builds. These are not in the preprocessor so they can be set by the IAR tool depending
     23           * on the 
     24          
     25          //#define  BC_ena	1 // Bus Controller
     26          //#define RT1_ena	1 // Remote Terminal 1
     27          //#define RT2_ena	1 // Remote Terminal 2         *--------------------------------------*
     28          //#define SMT_ena	1 // Simple Monitor Terminal   *   DO NOT set SMT_ena = IMT_ena = 1.  *
     29          //#define IMT_ena	0 // IRIG-106 Monitor Terminal *   One or both of these 2 must be 0.  *
     30                                                                 *--------------------------------------*
     31           *
     32           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY HOLT "AS IS" AND ANY EXPRESSED OR
     33           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     34           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     35           * DISCLAIMED. IN NO EVENT SHALL HOLT BE LIABLE FOR ANY DIRECT, INDIRECT,
     36           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     37           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     38           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     39           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     40           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     41           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     42           * ----------------------------------------------------------------------------
     43           */
     44          
     45          
     46          //------------------------------------------------------------------------------
     47          //         Headers
     48          //------------------------------------------------------------------------------
     49          // standard Atmel/IAR headers
     50          #include <board.h>
     51          #include <pio/pio.h>
     52          #include <tc/tc.h>
     53          #include <irq/irq.h>
     54          #include <utility/trace.h>
     55          #include <intrinsics.h>
     56          
     57          // Holt project headers
     58          #include "board_613x.h"
     59          #include "613x_bc.h"
     60          #include "613x_mt.h"
     61          #include "613x_rt.h"
     62          #include "613x_regs.h"
     63          #include "613x_initialization.h"
     64                         
     65          #include "board_6130.h"
     66          #include "device_6130.h"
     67          
     68          #if(CONSOLE_IO)
     69          #include "console.h"
     70          #endif
     71          
     72          
     73          //------------------------------------------------------------------------------
     74          //         Global variables
     75          //------------------------------------------------------------------------------
     76          // HI-6130 register structure base address
     77          // you can highlight pH6130 below and drag it into a 
     78          // Watch Window in IAR Embedded Workbench for ARM:

   \                                 In section .rodata, align 4
     79          const H6130 pH6130 = HI6130_BASE;
   \                     pH6130:
   \   00000000   00000060           DC32 60000000H
     80          
     81          #if(RT1_ena)
     82          // you can highlight pRT1d or pRT1i below and drag into a 
     83          // Watch Window in IAR Embedded Workbench for ARM:

   \                                 In section .rodata, align 4
     84          const RT1d pRT1d = RT1_DTABLE_BASE;
   \                     pRT1d:
   \   00000000   00080060           DC32 60000800H

   \                                 In section .rodata, align 4
     85          const RT1i pRT1i = RT1_ITABLE_BASE;
   \                     pRT1i:
   \   00000000   00040060           DC32 60000400H
     86          #endif // (RT1_ena)
     87          
     88          #if(RT2_ena)
     89          // you can highlight pRT2d or pRT2i below and drag into a 
     90          // Watch Window in IAR Embedded Workbench for ARM:

   \                                 In section .rodata, align 4
     91          const RT2d pRT2d = RT2_DTABLE_BASE;
   \                     pRT2d:
   \   00000000   000C0060           DC32 60000C00H

   \                                 In section .rodata, align 4
     92          const RT2i pRT2i = RT2_ITABLE_BASE;
   \                     pRT2i:
   \   00000000   00060060           DC32 60000600H
     93          #endif // (RT2_ena)
     94          
     95          #if(BC_ena)
     96          // you can highlight pGPQ or pBCil below and drag into a 
     97          // Watch Window in IAR Embedded Workbench for ARM:
     98          GPQ pGPQ = (GPQ) GPQ_BASE_BUS_ADDR;
     99          const BCil pBCil = BC_ILIST_BASE;
    100          const BCstack pBCstack = BC_STACK_BASE; 
    101          const BCstack2RT pBCstack2RT = BC_2RTSTACK_BASE; 
    102          #endif // (BC_ena)
    103          
    104          #if(SMT_ena)
    105          DSTK pDSTK = (DSTK) DSTACK_BASE_BUS_ADDR;
    106          const ScSTK pScSTK = SMT_CMDSTACK_BASE;
    107          const MTF pMTF = MT_FTABLE_BASE;
    108          const AddrList pAddrList = MT_ALIST_BASE;
    109          #endif // (SMT_ena)
    110          
    111          #if(IMT_ena)

   \                                 In section .rodata, align 4
    112          const MTF pMTF = MT_FTABLE_BASE;
   \                     pMTF:
   \   00000000   00020060           DC32 60000200H

   \                                 In section .rodata, align 4
    113          const AddrList pAddrList = MT_ALIST_BASE;
   \                     pAddrList:
   \   00000000   60010060           DC32 60000160H

   \                                 In section .bss, align 4
    114          PktHdr pPktHdr;
   \                     pPktHdr:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    115          IPMB pIPMB;
   \                     pIPMB:
   \   00000000                      DS8 4
    116          #endif // (IMT_ena)
    117          
    118          
    119          //------------------------------------------------------------------------------
    120          //         Functions
    121          //------------------------------------------------------------------------------
    122          
    123          
    124          //------------------------------------------------------------------------------
    125          /// Application entry point. ARM I/O and the Holt HI-613x device are configured,
    126          /// then execution waits in an endless loop.
    127          
    128          /// IAR intrinsic functions used in this program:
    129          ///         __disable_irq();
    130          ///         __enable_irq();
    131          /// These require intrinsics.h header file
    132          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    133          void main(void) {
   \                     main:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   A0B0               SUB      SP,SP,#+128
    134            
    135              unsigned short j, ttconfig = 0, runbits = 0;
   \   00000004   0025               MOVS     R5,#+0
   \   00000006   0026               MOVS     R6,#+0
    136              const Pin pinAUTOEN =  PIN_AUTOEN;
   \   00000008   18A8               ADD      R0,SP,#+96
   \   0000000A   5149               LDR.N    R1,??main_0
   \   0000000C   2022               MOVS     R2,#+32
   \   0000000E   ........           BL       __aeabi_memcpy4
    137              const Pin pinCOPYREQ = PIN_CPYREQ;
   \   00000012   10A8               ADD      R0,SP,#+64
   \   00000014   4F49               LDR.N    R1,??main_0+0x4
   \   00000016   2022               MOVS     R2,#+32
   \   00000018   ........           BL       __aeabi_memcpy4
    138              const Pin pinNMR = PIN_NMR;
   \   0000001C   08A8               ADD      R0,SP,#+32
   \   0000001E   4E49               LDR.N    R1,??main_0+0x8
   \   00000020   2022               MOVS     R2,#+32
   \   00000022   ........           BL       __aeabi_memcpy4
    139              #if(RT1_ena||RT2_ena)
    140              const Pin pinNSW1 = PIN_NSW1;
   \   00000026   00A8               ADD      R0,SP,#+0
   \   00000028   4C49               LDR.N    R1,??main_0+0xC
   \   0000002A   2022               MOVS     R2,#+32
   \   0000002C   ........           BL       __aeabi_memcpy4
    141              #endif
    142              
    143              __disable_interrupt(); // until initialization is complete
   \   00000030   72B6               CPSID    I
    144          
    145              // first priority: reset pin to 0 for HI-613x nMR, then configure that MCU pin as output
    146              AT91C_BASE_PIOC->PIO_CODR = nMR;  
   \   00000032   4B48               LDR.N    R0,??main_0+0x10  ;; 0x400e1034
   \   00000034   5FF00071           MOVS     R1,#+33554432
   \   00000038   0160               STR      R1,[R0, #+0]
    147              PIO_Configure(&pinNMR,1);
   \   0000003A   0121               MOVS     R1,#+1
   \   0000003C   08A8               ADD      R0,SP,#+32
   \   0000003E   ........           BL       PIO_Configure
    148                    
    149              // Configure ARM's other general purpose I/O pins and timer(s) 
    150              ConfigureGpio();
   \   00000042   ........           BL       ConfigureGpio
    151              init_timer();
   \   00000046   ........           BL       init_timer
    152              // enable the MCU nRST external reset
    153              AT91C_BASE_RSTC->RSTC_RMR= 0xA5000F01; 
   \   0000004A   4648               LDR.N    R0,??main_0+0x14  ;; 0x400e1208
   \   0000004C   4649               LDR.N    R1,??main_0+0x18  ;; 0xa5000f01
   \   0000004E   0160               STR      R1,[R0, #+0]
    154              
    155              // Initialize processor for selected interface to HI-613X device,
    156              Configure_ARM_MCU_ExtBus();
   \   00000050   ........           BL       Configure_ARM_MCU_ExtBus
    157          
    158                  
    159              #if (CONSOLE_IO)
    160                  ConfigureUsart1();
   \   00000054   ........           BL       ConfigureUsart1
    161                  printf("\n\n\n\n\n\n\r Holt Integrated Circuits HI-6130_40 Project \n\r");
   \   00000058   4448               LDR.N    R0,??main_0+0x1C
   \   0000005A   ........           BL       printf
    162                  printf(" Ver: 2.0     Compiled: %s %s    ", __DATE__, __TIME__ );
   \   0000005E   444A               LDR.N    R2,??main_0+0x20
   \   00000060   4449               LDR.N    R1,??main_0+0x24
   \   00000062   4548               LDR.N    R0,??main_0+0x28
   \   00000064   ........           BL       printf
    163              #endif
    164          
    165              // Anywhere from 0 to 4 terminals might be enabled by the 4 DIP switches on
    166              // the evaluation board. Next function call checks states for BC, RT1, RT2,
    167              // and MT DIP switches. For each switch = 1 (terminal enabled) the function
    168              // verifies that the corresponding compiler run-time switch is also ON. For
    169              // example: if BCENA DIP switch = 1 then BC_ENA (in file 613x_initialization.h)
    170              // must be defined ON (non-zero). Error trap occurs (flashing the red LED) if:
    171              //
    172              //  * one or more terminals has switch = 1 but compiler run-time switch defined OFF 
    173              //  * one or more terminals has switch = 0 but compiler run-time switch defined ON
    174              //  * all 4 DIP switches = 0, nothing is enabled
    175              // 
    176              // If error-free, function writes terminal enable bits into the Master Configuration 
    177              // register, then returns a 16-bit word having a run bit set for each enabled
    178              // DIP switch, used later to start terminal operation after initialization.
    179                  
    180              // program writes these bits to the Master Configuration register later...
    181              runbits = enable_check();
   \   00000068   ........           BL       enable_check
   \   0000006C   0600               MOVS     R6,R0
    182                  
    183              // Next function call uses an in-line delay. This affects completion time for hard reset 
    184              // (ARM microprocessor power-up reset (POR), or assertion of the board's RESET button. 
    185              // This delay does not affect time for "HI-613x only" hard reset, or HI-613x soft reset.
    186          
    187              //  flash an LED to indicate how initialization will proceed: 
    188              if(PIO_Get(&pinAUTOEN)){
   \   0000006E   18A8               ADD      R0,SP,#+96
   \   00000070   ........           BL       PIO_Get
   \   00000074   0028               CMP      R0,#+0
   \   00000076   05D0               BEQ.N    ??main_1
    189                 // AUTOEN == 1 (self init from EEPROM)
    190                 #if (CONSOLE_IO)
    191                    printf("\n\n\r       Auto-Initializing from EEPROM  \n\n\r");
   \   00000078   4048               LDR.N    R0,??main_0+0x2C
   \   0000007A   ........           BL       printf
    192                 #endif
    193                 Flash_Red_LED();
   \   0000007E   ........           BL       Flash_Red_LED
   \   00000082   04E0               B.N      ??main_2
    194              }    
    195              else {   
    196                 // AUTOEN == 0 (host initialization)
    197                 #if (CONSOLE_IO)
    198                    printf("\n\n\r       Host is Initializing Regs & RAM \n\n\r");
   \                     ??main_1:
   \   00000084   3E48               LDR.N    R0,??main_0+0x30
   \   00000086   ........           BL       printf
    199                 #endif
    200                 Flash_Green_LED();
   \   0000008A   ........           BL       Flash_Green_LED
    201              }
    202                  
    203              // Next actions are determined by states of the AUTOEN (auto-initialize) 
    204              // DIP switch and EECOPY Request DIP switch (labeled "COPYRQ"). AUTOEN is a 
    205              // HI-613x input, COPYRQ is a microprocessor input. The two switches COPYRQ and 
    206              // AUTOEN should never both be high (There is no point in auto-initializing the
    207              // HI-613x from EEPROM then copying the just-initialized setup to EEPROM again!) 
    208          
    209              //           D I P    S W I T C H    S E T T I N G    T A B L E
    210              //  ------------------------------------------------------------------------		
    211              //            |      AUTOEN = 0         |          AUTOEN = 1
    212              //  ----------|-------------------------|-----------------------------------
    213              //    COPYRQ  | Host initializes 613x   |   EEPROM initializes 613x
    214              //     = 0    | No EEPROM involvement   |   No Host involvement
    215              //            | Normal host initialize  |   Normal auto-initialize sequence
    216              //  ----------|-------------------------|-----------------------------------
    217              //    COPYRQ  | Host initializes 613x   |   EEPROM initializes 613x
    218              //      = 1   | then EECOPY to EEPROM   |   then EECOPY to EEPROM 
    219              //            | (Normal EEPROM copy)    |   (Senseless sequence)
    220              //	------------------------------------------------------------------------
    221          		
    222              // Reset HI-613x. If device AUTOEN pin is high, it will auto-initialize
    223              // the device registers and RAM from serial EEPROM. In this case, execution
    224              // comes back here only after the HI-613x READY output goes high...
    225              reset_613x();
   \                     ??main_2:
   \   0000008E   ........           BL       reset_613x
    226          
    227              // If error-free auto-init occurred after master reset, next function call 
    228              // returns "0". if auto-initialize occurred with errors, the function call 
    229              // does NOT return (local error trap). If auto-initialize was not enabled,
    230              // this program initializes device RAM and registers below.
    231          	
    232              // Although possible to do so, "intialize from EEPROM" process in this program 
    233              // does not automatically start execution for terminal devices. Instead,
    234              // whether auto-init or host init, the program simulaneously starts execution for 
    235              // all enabled devices (BC,MT,RT1,RT2) when "runbits" are written into the Master
    236              // Configuration register below...          
    237                         
    238              if(autoinit_check()) {
   \   00000092   ........           BL       autoinit_check
   \   00000096   0028               CMP      R0,#+0
   \   00000098   3BD0               BEQ.N    ??main_3
    239          
    240                  // if function call above returned with non-zero result, the terminal was 
    241                  // NOT automatically initialized after reset, BUT numerous registers now
    242                  // contain non-zero default values. The host will now initialize...
    243                
    244                  // having met enable_check() requirements above, write the terminal 
    245                  // enable bits for BC or RT(s) into the Master Config register 0. (The
    246                  // MT has only a run bit, not an enable bit.)
    247                  pH6130->MASTER_CONFIG_REG = runbits & (BCENA|RT1ENA|RT2ENA);
   \   0000009A   16F48650           ANDS     R0,R6,#0x10C0
   \   0000009E   3949               LDR.N    R1,??main_0+0x34
   \   000000A0   0968               LDR      R1,[R1, #+0]
   \   000000A2   0880               STRH     R0,[R1, #+0]
    248          
    249                  
    250                  // modify runbits to just contain "start execution" bits, to be written last
    251                  runbits &= ~(BCENA|RT1ENA|RT2ENA);
   \   000000A4   4EF63F70           MOVW     R0,#+61247
   \   000000A8   0640               ANDS     R6,R0,R6
    252                      
    253                  // Select common configuration options that apply to all BC, MT, RT1, RT2. 
    254                  initialize_613x_shared();
   \   000000AA   ........           BL       initialize_613x_shared
    255                  
    256                  // Terminal-specific options are initialized next... 
    257                  // Below, variable "ttconfig" is used for time tag counter configuration. 
    258          	// If enabled, the MT has a dedicated 16-bit or 48-bit time counter.
    259          	// MT time tag resolution is selected by MT Configuration Reg, bit 0. 
    260          	// We select the MT counter clock source below, factored into "ttconfig".
    261          		
    262          	// The BC,RT1 and RT2 have independent time tag counters, but share 
    263          	// a common clock source, selected below, factored into "ttconfig". The RT1 
    264          	// and RT2 time counters are always 16-bit. The BC time counter is
    265          	// either 16- or 32-bit, selected below.        
    266                    
    267                  //------------------------------------------------------------------------
    268                  
    269                  #if(BC_ena)
    270          
    271          	    initialize_613x_BC();
    272                      initialize_bc_msg_blocks();
    273          	    initialize_bc_instruction_list();
    274          
    275                      // select BC time tag resolution, either 16-bit or 32-bit (BTTAG16 or BTTAG32)
    276                      
    277                      #ifdef BC_TTAG_HI_RES
    278                          ttconfig |= BTTAG32;
    279                      #else
    280                          ttconfig |= BTTAG16;
    281                      #endif
    282          
    283                      // Select internally-generated time tag clock used by BC,RT1 and RT2
    284                      // Choices are 2U,4U,8U,16U,32U or 64U (microseconds)
    285                      ttconfig |= TTAG_64U;
    286          
    287                  #endif	// end BC init. 
    288          
    289                  //------------------------------------------------------------------------
    290          
    291                  #if(RT1_ena)
    292          	    // verify RT1 Op Status Reg shows a valid RT address. This function call
    293          	    // does not return if register reflects address parity error or if the
    294          	    // register reads back zero value, an invalid result (local error trap)
    295                      
    296          	    if (RTAddr_okay(1)) {
   \   000000AE   0120               MOVS     R0,#+1
   \   000000B0   ........           BL       RTAddr_okay
   \   000000B4   0028               CMP      R0,#+0
   \   000000B6   08D0               BEQ.N    ??main_4
    297                     
    298                          // host now initializes HI-613x regs, RAM tables, for RT1 
    299                          initialize_613x_RT1();				
   \   000000B8   ........           BL       initialize_613x_RT1
    300                          
    301          	        // write test data to assigned transmit buffers
    302          	        write_dummy_tx_data_RT1();
   \   000000BC   ........           BL       write_dummy_tx_data_RT1
    303                          
    304          	        // RT1 and RT2 always use 16-bit time tag resolution.
    305                          // if not already selected above for BC, (i.e. if BC is not used), 
    306                          // select RT1 and RT2 time tag clock which otherwise is shared with BC.
    307                          // Choices are 2U,4U,8U,16U,32U or 64U (microseconds)
    308          	        if(!ttconfig) ttconfig = TTAG_64U;
   \   000000C0   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000C2   002D               CMP      R5,#+0
   \   000000C4   01D1               BNE.N    ??main_4
   \   000000C6   0720               MOVS     R0,#+7
   \   000000C8   0500               MOVS     R5,R0
    309                      }			
    310                   
    311                  #endif    // end RT1 init. RT1 does not start until the RT1STEX register bit is set
    312          
    313                  //------------------------------------------------------------------------
    314          
    315                  #if(RT2_ena)
    316          
    317          	    // verify RT2 Op Status Reg shows a valid RT address. This function call
    318          	    // does not return if register reflects address parity error or if the
    319          	    // register reads back zero value, an invalid result (local error trap)
    320          	    if (RTAddr_okay(2)) {
   \                     ??main_4:
   \   000000CA   0220               MOVS     R0,#+2
   \   000000CC   ........           BL       RTAddr_okay
   \   000000D0   0028               CMP      R0,#+0
   \   000000D2   08D0               BEQ.N    ??main_5
    321                     
    322                          // host now initializes HI-613x regs, RAM tables, for RT2
    323                          initialize_613x_RT2();				
   \   000000D4   ........           BL       initialize_613x_RT2
    324          
    325          	        // write test data to assigned transmit buffers
    326          	        write_dummy_tx_data_RT2();
   \   000000D8   ........           BL       write_dummy_tx_data_RT2
    327          				
    328          	        // RT1 and RT2 always use 16-bit time tag resolution.
    329          	        // if not already selected above for BC or RT1, (i.e. if BC & RT1 not used), 
    330                          // select RT2 time tag clock which otherwise is shared with BC and RT1.
    331                          // Choices are 2U,4U,8U,16U,32U or 64U (microseconds)
    332          	        if(!ttconfig) ttconfig = TTAG_64U;
   \   000000DC   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000DE   002D               CMP      R5,#+0
   \   000000E0   01D1               BNE.N    ??main_5
   \   000000E2   0720               MOVS     R0,#+7
   \   000000E4   0500               MOVS     R5,R0
    333                     }			
    334                   
    335                  #endif    // end RT2 init. RT2 does not start until the RT2STEX register bit is set
    336          
    337                  //------------------------------------------------------------------------
    338               
    339                  #if(SMT_ena||IMT_ena)
    340          
    341                      // Host now initializes Simple Monitor or IRIG-106 Bus Monitor, as selected in 
    342                      // file 613x_initialization.h. Next call traps error if MTRUN pin disables MT.
    343                      initialize_613x_MT();				
   \                     ??main_5:
   \   000000E6   ........           BL       initialize_613x_MT
    344          
    345                      // dedicated MT time tag clock selection:
    346          
    347                      #if(IMT_ena) 
    348                          // IRIG-106 monitor (IMT) always uses 48-bit time tag resolution.
    349                          // two IRIG-106 monitor time tag clock options: MTTAG_OFF or MTTAG_100N (100ns)
    350                          // "OFF" is helpful in debug, to prevent "maximum packet time" end-of-packet.
    351                          j = MTTAG_OFF; // MTTAG_100N;
   \   000000EA   0020               MOVS     R0,#+0
   \   000000EC   0400               MOVS     R4,R0
    352                          ttconfig |= j;
   \   000000EE   2543               ORRS     R5,R4,R5
    353          
    354                      #else 
    355          	        // SMT simple monitor time tag clock options: MTTAG_OFF, MTTAG_100N (100ns)
    356                          // or MTTAG_2U,4U,8U,16U,32U or 64U (microseconds)
    357                	        ttconfig |= MTTAG_64U;
    358                          
    359                          // SMT can use 16-bit or 48-bit time tag resolution, selected in
    360                          // the MT Configuration register...
    361          
    362                          #ifdef SMT_TTAG_HI_RES
    363                              j = SMT_TTAG48;
    364                          #else
    365                              j= SMT_TTAG16;
    366                          #endif
    367          
    368                          // read-modify-write the MT Configuration Register
    369                          pH6130->MT_CONFIG_REG |= j;              
    370                          
    371                      #endif
    372          						
    373                  #endif	// end MT init. Monitor does not start until MTENA register bit is set below
    374                   
    375                  //------------------------------------------------------------------------
    376                  
    377                  // write the Time Tag Configuration Register
    378                  pH6130->TTAG_CONFIG_REG = ttconfig;              
   \   000000F0   2448               LDR.N    R0,??main_0+0x34
   \   000000F2   0068               LDR      R0,[R0, #+0]
   \   000000F4   A0F87250           STRH     R5,[R0, #+114]
    379            
    380          	if (PIO_Get(&pinCOPYREQ)) {
   \   000000F8   10A8               ADD      R0,SP,#+64
   \   000000FA   ........           BL       PIO_Get
   \   000000FE   0028               CMP      R0,#+0
   \   00000100   07D0               BEQ.N    ??main_3
    381                      // "COPY REQUEST" DIP switch is high. Write serial EEPROM using parameter 0 
    382          	    // so the various start bits in the Master Configuraton Register are 
    383                      // NOT automatically set by subsequent auto-initialization cycles.
    384                     #if (CONSOLE_IO)
    385                          printf("       Copying Registers & RAM to EEPROM  \n\r");                       
   \   00000102   2148               LDR.N    R0,??main_0+0x38
   \   00000104   ........           BL       printf
    386                          printf("    Be sure to turn off COPYREQ DIP switch. \n\n\r");                       
   \   00000108   2048               LDR.N    R0,??main_0+0x3C
   \   0000010A   ........           BL       printf
    387                      #endif
    388          	    write_init_eeprom();
   \   0000010E   ........           BL       write_init_eeprom
    389                  }
    390                    
    391              }   // end:if (autoinit_check())
    392                      
    393              // flash both green bus LEDs to signify initialization complete
    394              AT91C_BASE_PIOC->PIO_CODR = nLEDA|nLEDB;  // LEDs ON
   \                     ??main_3:
   \   00000112   1348               LDR.N    R0,??main_0+0x10  ;; 0x400e1034
   \   00000114   5FF04041           MOVS     R1,#-1073741824
   \   00000118   0160               STR      R1,[R0, #+0]
    395              Delay_x100ms(3);
   \   0000011A   0320               MOVS     R0,#+3
   \   0000011C   ........           BL       Delay_x100ms
    396              AT91C_BASE_PIOC->PIO_SODR = nLEDA|nLEDB;  // LEDs OFF
   \   00000120   1B48               LDR.N    R0,??main_0+0x40  ;; 0x400e1030
   \   00000122   5FF04041           MOVS     R1,#-1073741824
   \   00000126   0160               STR      R1,[R0, #+0]
    397                  
    398              // we disabled interrupts during initialization, 
    399              // now enable them before starting terminal execution
    400              __enable_interrupt();
   \   00000128   62B6               CPSIE    I
    401              
    402              // write the Master Configuraton Register to start the
    403              // terminal(s) initialized above, to begin operation.
    404              // do not overwrite previously initialized common features       
    405          	pH6130->MASTER_CONFIG_REG |= runbits;         
   \   0000012A   1648               LDR.N    R0,??main_0+0x34
   \   0000012C   0068               LDR      R0,[R0, #+0]
   \   0000012E   0088               LDRH     R0,[R0, #+0]
   \   00000130   3043               ORRS     R0,R6,R0
   \   00000132   1449               LDR.N    R1,??main_0+0x34
   \   00000134   0968               LDR      R1,[R1, #+0]
   \   00000136   0880               STRH     R0,[R1, #+0]
    406                
    407                #if (CONSOLE_IO)
    408                    show_menu();
   \   00000138   ........           BL       show_menu
    409                    // Infinite loop
    410                    while (1) {
    411                        // poll USART1 to detect and act on console key input at computer keyboard...
    412                        chk_key_input();
   \                     ??main_6:
   \   0000013C   ........           BL       chk_key_input
    413                        
    414                        #if(RT1_ena||RT2_ena)
    415                            // if MCU board SW1 button is pressed, update RT1 and RT2 status bits
    416                            // based on Terminal Flag and Busy DIP switch settings
    417                            if(!PIO_Get(&pinNSW1)) modify_RT_status_bits();
   \   00000140   00A8               ADD      R0,SP,#+0
   \   00000142   ........           BL       PIO_Get
   \   00000146   0028               CMP      R0,#+0
   \   00000148   F8D1               BNE.N    ??main_6
   \   0000014A   ........           BL       modify_RT_status_bits
   \   0000014E   F5E7               B.N      ??main_6
   \                     ??main_0:
   \   00000150   ........           DC32     `?<Constant {16, (AT91S_PIO *)1074662912, 11, 2`
   \   00000154   ........           DC32     `?<Constant {8, (AT91S_PIO *)1074662912, 11, 2}`
   \   00000158   ........           DC32     `?<Constant {33554432, (AT91S_PIO *)1074663424,`
   \   0000015C   ........           DC32     `?<Constant {131072, (AT91S_PIO *)1074662912, 1`
   \   00000160   34100E40           DC32     0x400e1034
   \   00000164   08120E40           DC32     0x400e1208
   \   00000168   010F00A5           DC32     0xa5000f01
   \   0000016C   ........           DC32     `?<Constant "\\n\\n\\n\\n\\n\\n\\r Holt Integrat...">`
   \   00000170   ........           DC32     `?<Constant "10:26:32">`
   \   00000174   ........           DC32     `?<Constant "Jun 18 2012">`
   \   00000178   ........           DC32     `?<Constant " Ver: 2.0     Compile...">`
   \   0000017C   ........           DC32     `?<Constant "\\n\\n\\r       Auto-Initia...">`
   \   00000180   ........           DC32     `?<Constant "\\n\\n\\r       Host is Ini...">`
   \   00000184   ........           DC32     pH6130
   \   00000188   ........           DC32     `?<Constant "       Copying Regist...">`
   \   0000018C   ........           DC32     `?<Constant "    Be sure to turn o...">`
   \   00000190   30100E40           DC32     0x400e1030
    418                        #endif
    419          
    420                    }   // end while 
    421                    
    422                    
    423                #else // not using console IO...
    424                    // Infinite loop
    425                    while (1) {
    426                        #if(BC_ena)
    427                            bc_switch_tests();
    428                        #endif // BC_ena
    429                            
    430                        #if(RT1_ena||RT2_ena)
    431                            // if MCU board SW1 button is pressed, update RT1 and RT2 status bits
    432                            // based on Terminal Flag and Busy DIP switch settings
    433                            if(!PIO_Get(&pinNSW1)) modify_RT_status_bits();
    434                        #endif
    435                            
    436                    }   // end while
    437          
    438                #endif
    439             
    440          }     // end main()

   \                                 In section .rodata, align 4
   \                     `?<Constant {16, (AT91S_PIO *)1074662912, 11, 2`:
   \   00000000   10000000000E       DC32 16, 400E0E00H
   \              0E40        
   \   00000008   0B0200000000       DC8 11, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \   0000001A   000000000000       DC8 0, 0, 0, 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant {8, (AT91S_PIO *)1074662912, 11, 2}`:
   \   00000000   08000000000E       DC32 8, 400E0E00H
   \              0E40        
   \   00000008   0B0200000000       DC8 11, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \   0000001A   000000000000       DC8 0, 0, 0, 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant {33554432, (AT91S_PIO *)1074663424,`:
   \   00000000   000000020010       DC32 33554432, 400E1000H
   \              0E40        
   \   00000008   0C0300000000       DC8 12, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   0000001B   0000000000         DC8 0, 0, 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant {131072, (AT91S_PIO *)1074662912, 1`:
   \   00000000   00000200000E       DC32 131072, 400E0E00H
   \              0E40        
   \   00000008   0B0202000000       DC8 11, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   0000001B   0000000000         DC8 0, 0, 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\n\\n\\n\\n\\n\\r Holt Integrat...">`:
   \   00000000   0A0A0A0A0A0A       DC8 0AH, 0AH, 0AH, 0AH, 0AH, 0AH, 0DH, 20H
   \              0D20        
   \   00000008   486F6C742049       DC8 48H, 6FH, 6CH, 74H, 20H, 49H, 6EH, 74H
   \              6E74        
   \   00000010   656772617465       DC8 65H, 67H, 72H, 61H, 74H, 65H, 64H, 20H
   \              6420        
   \   00000018   436972637569       DC8 43H, 69H, 72H, 63H, 75H, 69H, 74H, 73H
   \              7473        
   \   00000020   2048492D3631       DC8 20H, 48H, 49H, 2DH, 36H, 31H, 33H, 30H
   \              3330        
   \   00000028   5F3430205072       DC8 5FH, 34H, 30H, 20H, 50H, 72H, 6FH, 6AH
   \              6F6A        
   \   00000030   656374200A0D       DC8 65H, 63H, 74H, 20H, 0AH, 0DH, 0
   \              00          
   \   00000037   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant " Ver: 2.0     Compile...">`:
   \   00000000   205665723A20       DC8 " Ver: 2.0     Compiled: %s %s    "
   \              322E30202020
   \              2020436F6D70
   \              696C65643A20
   \              257320257320
   \              20202000    
   \   00000022   0000               DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Jun 18 2012">`:
   \   00000000   4A756E203138       DC8 "Jun 18 2012"
   \              203230313200

   \                                 In section .rodata, align 4
   \                     `?<Constant "10:26:32">`:
   \   00000000   31303A32363A       DC8 "10:26:32"
   \              333200      
   \   00000009   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\n\\r       Auto-Initia...">`:
   \   00000000   0A0A0D202020       DC8 "\012\012\015       Auto-Initializing from EEPROM  \012\012\015"
   \              202020204175
   \              746F2D496E69
   \              7469616C697A
   \              696E67206672
   \              6F6D20454550
   \              524F4D20200A
   \              0A0D00      
   \   0000002D   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\n\\r       Host is Ini...">`:
   \   00000000   0A0A0D202020       DC8 "\012\012\015       Host is Initializing Regs & RAM \012\012\015"
   \              20202020486F
   \              737420697320
   \              496E69746961
   \              6C697A696E67
   \              205265677320
   \              262052414D20
   \              0A0A0D00    
   \   0000002E   0000               DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "       Copying Regist...">`:
   \   00000000   202020202020       DC8 "       Copying Registers & RAM to EEPROM  \012\015"
   \              20436F707969
   \              6E6720526567
   \              697374657273
   \              20262052414D
   \              20746F204545
   \              50524F4D2020
   \              0A0D00      
   \   0000002D   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "    Be sure to turn o...">`:
   \   00000000   202020204265       DC8 "    Be sure to turn off COPYREQ DIP switch. \012\012\015"
   \              207375726520
   \              746F20747572
   \              6E206F666620
   \              434F50595245
   \              512044495020
   \              737769746368
   \              2E200A0A0D00
    441          
    442          
    443          // end of file
    444          

   Maximum stack usage in bytes:

     Function .cstack
     -------- -------
     main        144


   Section sizes:

     Function/Label                                 Bytes
     --------------                                 -----
     pH6130                                            4
     pRT1d                                             4
     pRT1i                                             4
     pRT2d                                             4
     pRT2i                                             4
     pMTF                                              4
     pAddrList                                         4
     pPktHdr                                           4
     pIPMB                                             4
     main                                            404
     ?<Constant {16, (AT91S_PIO *)1074662912, 11, 2   32
     ?<Constant {8, (AT91S_PIO *)1074662912, 11, 2}   32
     ?<Constant {33554432, (AT91S_PIO *)1074663424,   32
     ?<Constant {131072, (AT91S_PIO *)1074662912, 1   32
     ?<Constant "\n\n\n\n\n\n\r Holt Integrat...">    56
     ?<Constant " Ver: 2.0     Compile...">           36
     ?<Constant "Jun 18 2012">                        12
     ?<Constant "10:26:32">                           12
     ?<Constant "\n\n\r       Auto-Initia...">        48
     ?<Constant "\n\n\r       Host is Ini...">        48
     ?<Constant "       Copying Regist...">           48
     ?<Constant "    Be sure to turn o...">           48

 
   8 bytes in section .bss
 464 bytes in section .rodata
 404 bytes in section .text
 
 404 bytes of CODE  memory
 464 bytes of CONST memory
   8 bytes of DATA  memory

Errors: none
Warnings: none
