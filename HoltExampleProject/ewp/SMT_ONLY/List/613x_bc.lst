###############################################################################
#                                                                             #
#                                                       15/May/2012  13:59:25 #
# IAR ANSI C/C++ Compiler V6.21.1.32794/W32 KICKSTART for ARM                 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Program Files\IAR Systems\Embedded Workbench 6.0      #
#                    Kickstart_2\arm\examples\Atmel\HOLT\_Holt HI-6130-31     #
#                    Demo 1_3\613x_bc.c                                       #
#    Command line =  "C:\Program Files\IAR Systems\Embedded Workbench 6.0     #
#                    Kickstart_2\arm\examples\Atmel\HOLT\_Holt HI-6130-31     #
#                    Demo 1_3\613x_bc.c" -D at91sam3u4 -D flash -D            #
#                    TRACE_LEVEL=4 -D HOST_BUS_INTERFACE=1 -D BC_ena=0 -D     #
#                    RT2_ena=0 -D RT1_ena=0 -D SMT_ena=1 -D IMT_ena=0 -lC     #
#                    "C:\Program Files\IAR Systems\Embedded Workbench 6.0     #
#                    Kickstart_2\arm\examples\Atmel\HOLT\_Holt HI-6130-31     #
#                    Demo 1_3\ewp\SMT_ONLY\List\" --remarks --diag_suppress   #
#                    Pe826,Pe1375,Pe068 -o "C:\Program Files\IAR              #
#                    Systems\Embedded Workbench 6.0                           #
#                    Kickstart_2\arm\examples\Atmel\HOLT\_Holt HI-6130-31     #
#                    Demo 1_3\ewp\SMT_ONLY\Obj\" --no_cse --no_unroll         #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0                           #
#                    Kickstart_2\arm\INC\c\DLib_Config_Full.h" -I             #
#                    "C:\Program Files\IAR Systems\Embedded Workbench 6.0     #
#                    Kickstart_2\arm\examples\Atmel\HOLT\_Holt HI-6130-31     #
#                    Demo 1_3\ewp\..\..\..\at91lib/peripherals\" -I           #
#                    "C:\Program Files\IAR Systems\Embedded Workbench 6.0     #
#                    Kickstart_2\arm\examples\Atmel\HOLT\_Holt HI-6130-31     #
#                    Demo 1_3\ewp\..\..\..\at91lib/components\" -I            #
#                    "C:\Program Files\IAR Systems\Embedded Workbench 6.0     #
#                    Kickstart_2\arm\examples\Atmel\HOLT\_Holt HI-6130-31     #
#                    Demo 1_3\ewp\..\..\..\at91lib\" -I "C:\Program           #
#                    Files\IAR Systems\Embedded Workbench 6.0                 #
#                    Kickstart_2\arm\examples\Atmel\HOLT\_Holt HI-6130-31     #
#                    Demo 1_3\ewp\..\..\..\external_libs\" -I "C:\Program     #
#                    Files\IAR Systems\Embedded Workbench 6.0                 #
#                    Kickstart_2\arm\examples\Atmel\HOLT\_Holt HI-6130-31     #
#                    Demo 1_3\ewp\..\..\..\at91lib/boards/at91sam3u-ek\"      #
#                    --cpu_mode thumb -On --use_c++_inline                    #
#    List file    =  C:\Program Files\IAR Systems\Embedded Workbench 6.0      #
#                    Kickstart_2\arm\examples\Atmel\HOLT\_Holt HI-6130-31     #
#                    Demo 1_3\ewp\SMT_ONLY\List\613x_bc.lst                   #
#    Object file  =  C:\Program Files\IAR Systems\Embedded Workbench 6.0      #
#                    Kickstart_2\arm\examples\Atmel\HOLT\_Holt HI-6130-31     #
#                    Demo 1_3\ewp\SMT_ONLY\Obj\613x_bc.o                      #
#                                                                             #
#                                                                             #
###############################################################################

C:\Program Files\IAR Systems\Embedded Workbench 6.0 Kickstart_2\arm\examples\Atmel\HOLT\_Holt HI-6130-31 Demo 1_3\613x_bc.c
      1          /* ----------------------------------------------------------------------------
      2           *                            HOLT Integrated Circuits 
      3           * ----------------------------------------------------------------------------
      4           *
      5           *    file	613x_bc.c
      6           *    brief     This file contains initialization functions and arrays for 
      7           *		initializing BC register and RAM tables inside the Holt  
      8           *		HI-6130 or HI-6131 device. 
      9           *
     10           *		IMPORTANT: Edit file 613x_initialization.h to define either:
     11           *
     12           *		HOST_BUS_INTERFACE  YES  sets compilation for HI-6130 (bus)
     13           *		 		    NO   sets compilation for HI-6131 (SPI)
     14           *
     15           *		Most functional procedures in this project are written for
     16           *		both parallel bus or SPI host interface schemes, this runtime 
     17           *		switch determines which are procedures are compiled.
     18           * 
     19           *
     20           *	   	HOLT DISCLAIMER
     21           *      	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY 
     22           *      	KIND, EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE 
     23           *      	WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
     24           *      	PURPOSE AND NONINFRINGEMENT. 
     25           *      	IN NO EVENT SHALL HOLT, INC BE LIABLE FOR ANY CLAIM, DAMAGES
     26           *      	OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
     27           *      	OTHERWISE,ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
     28           *      	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
     29           *
     30           *              Copyright (C) 2009-2011 by  HOLT, Inc.
     31           *              All Rights Reserved
     32           */
     33          
     34          
     35          //------------------------------------------------------------------------------
     36          //         Headers
     37          //------------------------------------------------------------------------------
     38          
     39          // standard Atmel/IAR headers
     40          #include <pio/pio.h>
     41          #include <intrinsics.h>
     42          #include <spi/spi.h>
     43          
     44          // Holt project headers
     45          #include "613x_initialization.h"
     46          #include "613x_regs.h"
     47          #include "613x_bc.h"
     48          #include "board_613x.h"
     49          
     50          #if (HOST_BUS_INTERFACE)
     51          #include "board_6130.h"
     52          #include "device_6130.h"
     53          extern const H6130 pH6130;
     54          extern GPQ pGPQ;
     55          extern const BCil pBCil;
     56          extern const BCstack pBCstack; 
     57          extern const BCstack2RT pBCstack2RT; 
     58          
     59          #else // HOST SPI INTERFACE 
     60          #include "board_6131.h"
     61          #include "device_6131.h"
     62          
     63          // HI-6131 SPI slave select pin
     64          static const Pin pinNss[]  = {BOARD_6131_NPCS_PIN};
     65          
     66          #endif // HOST SPI INTERFACE 
     67          
     68          
     69          //------------------------------------------------------------------------------
     70          //         Functions
     71          //------------------------------------------------------------------------------
     72          
     73          #if (HOST_BUS_INTERFACE)    
     74          
     75          // IMPORTANT: NEXT FUNCTION'S EXAMPLES ONLY APPLY TO HI-6130 NOT TO HI-6131!
     76          

   \                                 In section .text, align 2, keep-with-next
     77          void BC_bus_addressing_examples(void) {
     78            
     79              unsigned short j,k;  
     80            
     81              // -----------------------------------------------------
     82              // 64-word BC General Purpose Queue addressing examples
     83              // -----------------------------------------------------
     84              // using array pointer declared in 613x_bc.h
     85              // queue base address declared/initialized as global const
     86                  
     87              (*pGPQ)[0] = 0x0123;         // write general purpose queue word 0
   \                     BC_bus_addressing_examples:
   \   00000000   ........           LDR.W    R2,??DataTable10
   \   00000004   1268               LDR      R2,[R2, #+0]
   \   00000006   40F22313           MOVW     R3,#+291
   \   0000000A   1380               STRH     R3,[R2, #+0]
     88              (*pGPQ)[1] = 0x4567;         // write general purpose queue word 1
   \   0000000C   ........           LDR.W    R2,??DataTable10
   \   00000010   1268               LDR      R2,[R2, #+0]
   \   00000012   44F26753           MOVW     R3,#+17767
   \   00000016   5380               STRH     R3,[R2, #+2]
     89              (*pGPQ)[2] = 0x89AB;         // write general purpose queue word 2
   \   00000018   ........           LDR.W    R2,??DataTable10
   \   0000001C   1268               LDR      R2,[R2, #+0]
   \   0000001E   48F6AB13           MOVW     R3,#+35243
   \   00000022   9380               STRH     R3,[R2, #+4]
     90              k = (*pGPQ)[2];              // read general purpose queue word 2
   \   00000024   ........           LDR.W    R2,??DataTable10
   \   00000028   1268               LDR      R2,[R2, #+0]
   \   0000002A   9288               LDRH     R2,[R2, #+4]
   \   0000002C   1100               MOVS     R1,R2
     91                
     92              // or, using a macro, GPQ(n) defined as (*pGPQ)[n] where n = 0 to 63
     93              k = GPQ(25);                  // read general purpose queue word 25
   \   0000002E   ........           LDR.W    R2,??DataTable10
   \   00000032   1268               LDR      R2,[R2, #+0]
   \   00000034   528E               LDRH     R2,[R2, #+50]
   \   00000036   1100               MOVS     R1,R2
     94              GPQ(2) = 0xAB89;              // write general purpose queue word 2
   \   00000038   ........           LDR.W    R2,??DataTable10
   \   0000003C   1268               LDR      R2,[R2, #+0]
   \   0000003E   4AF68933           MOVW     R3,#+43913
   \   00000042   9380               STRH     R3,[R2, #+4]
     95                
     96              // ----------------------------------------
     97              // BC Instruction List addressing examples
     98              // ----------------------------------------
     99              // using pointer to array of 2-word structs (declared in 613x_bc.h)
    100              // instruction list base address is declared in file 613x_bc.h
    101                
    102              (*pBCil)[0].opCode = 0xD14F;     // write op code word for operation 0 in BC instruction list
   \   00000044   ........           LDR.W    R2,??DataTable10_1
   \   00000048   1268               LDR      R2,[R2, #+0]
   \   0000004A   4DF24F13           MOVW     R3,#+53583
   \   0000004E   1380               STRH     R3,[R2, #+0]
    103              (*pBCil)[0].param = 0x6789;      // write parameter word for operation 0 in BC instruction list
   \   00000050   ........           LDR.W    R2,??DataTable10_1
   \   00000054   1268               LDR      R2,[R2, #+0]
   \   00000056   46F28973           MOVW     R3,#+26505
   \   0000005A   5380               STRH     R3,[R2, #+2]
    104              j = (*pBCil)[1].opCode;          // read op code word for operation 1 in BC instruction list
   \   0000005C   ........           LDR.W    R2,??DataTable10_1
   \   00000060   1268               LDR      R2,[R2, #+0]
   \   00000062   9288               LDRH     R2,[R2, #+4]
   \   00000064   1000               MOVS     R0,R2
    105              k = (*pBCil)[1].param;           // write parameter word for operation 1 in BC instruction list
   \   00000066   ........           LDR.W    R2,??DataTable10_1
   \   0000006A   1268               LDR      R2,[R2, #+0]
   \   0000006C   D288               LDRH     R2,[R2, #+6]
   \   0000006E   1100               MOVS     R1,R2
    106          
    107              // or, using a macro, ILIST(n) defined as (*pBCil)[n]
    108              ILIST(0).param = 0x0000;         // write parameter word for operation 0 in BC instruction list
   \   00000070   ........           LDR.W    R2,??DataTable10_1
   \   00000074   1268               LDR      R2,[R2, #+0]
   \   00000076   0023               MOVS     R3,#+0
   \   00000078   5380               STRH     R3,[R2, #+2]
    109              j = ILIST(1).opCode;             // read op code word for operation 1 in BC instruction list
   \   0000007A   ........           LDR.W    R2,??DataTable10_1
   \   0000007E   1268               LDR      R2,[R2, #+0]
   \   00000080   9288               LDRH     R2,[R2, #+4]
   \   00000082   1000               MOVS     R0,R2
    110          
    111              
    112              // ------------------------------------------------------------
    113              // BC Message Stack for non-RT-RT messages, addressing examples 
    114              // ------------------------------------------------------------
    115              // BC Message Stack for non-RT-RT messages is comprised of 8-word message blocks. 
    116              // The index, for example [0], is the message number in the stack. Message order of
    117              // execution is determined by the BC instruction list (not index number) and jumps
    118              // between this non-RT-RT message stack and the RT-RT stack...
    119              // The message stack base address is declared in file 613x_bc.h
    120                
    121              k = (*pBCstack)[0].ctrlWord;      // read nonRTRT msg 0 control word
   \   00000084   ........           LDR.W    R2,??DataTable10_2
   \   00000088   1268               LDR      R2,[R2, #+0]
   \   0000008A   1288               LDRH     R2,[R2, #+0]
   \   0000008C   1100               MOVS     R1,R2
    122              j = (*pBCstack)[0].cmdWord;       // read nonRTRT msg 0 command word
   \   0000008E   ........           LDR.W    R2,??DataTable10_2
   \   00000092   1268               LDR      R2,[R2, #+0]
   \   00000094   5288               LDRH     R2,[R2, #+2]
   \   00000096   1000               MOVS     R0,R2
    123              k = (*pBCstack)[1].dataPtr;       // read data pointer for nonRTRT msg 1
   \   00000098   ........           LDR.W    R2,??DataTable10_2
   \   0000009C   1268               LDR      R2,[R2, #+0]
   \   0000009E   928A               LDRH     R2,[R2, #+20]
   \   000000A0   1100               MOVS     R1,R2
    124              (*pBCstack)[3].timeNextMsg = 500; // write nonRTRT msg 3 time-to-next-msg = 500us
   \   000000A2   ........           LDR.W    R2,??DataTable10_2
   \   000000A6   1268               LDR      R2,[R2, #+0]
   \   000000A8   4FF4FA73           MOV      R3,#+500
   \   000000AC   D386               STRH     R3,[R2, #+54]
    125              j = (*pBCstack)[1].blockStatus;   // read nonRTRT msg 1 block status word
   \   000000AE   ........           LDR.W    R2,??DataTable10_2
   \   000000B2   1268               LDR      R2,[R2, #+0]
   \   000000B4   528B               LDRH     R2,[R2, #+26]
   \   000000B6   1000               MOVS     R0,R2
    126              j = (*pBCstack)[1].RTstatus;      // read nonRTRT msg 1 RT status word
   \   000000B8   ........           LDR.W    R2,??DataTable10_2
   \   000000BC   1268               LDR      R2,[R2, #+0]
   \   000000BE   D28B               LDRH     R2,[R2, #+30]
   \   000000C0   1000               MOVS     R0,R2
    127                
    128              #ifndef BC_TTAG_HI_RES            // BC IS USING 16-BIT TIME BASE
    129              k = (*pBCstack)[0].timetag;       // read nonRTRT msg 0 16-bit time tag (16-bit timebase)
    130              k = (*pBCstack)[3].loopbackWord;  // read nonRTRT msg 3 block loopback word (16-bit timebase)
    131                
    132              #else // ifdef BC_TTAG_HI_RES     // BC IS USING 32-BIT TIME BASE
    133              j = (*pBCstack)[0].ttagLow;       // read nonRTRT msg 0 32-bit time tag count LOW 1 bits
   \   000000C2   ........           LDR.W    R2,??DataTable10_2
   \   000000C6   1268               LDR      R2,[R2, #+0]
   \   000000C8   1289               LDRH     R2,[R2, #+8]
   \   000000CA   1000               MOVS     R0,R2
    134              k = (*pBCstack)[0].ttagHigh;      // read nonRTRT msg 0 32-bit time tag count HIGH 16 bits
   \   000000CC   ........           LDR.W    R2,??DataTable10_2
   \   000000D0   1268               LDR      R2,[R2, #+0]
   \   000000D2   9289               LDRH     R2,[R2, #+12]
   \   000000D4   1100               MOVS     R1,R2
    135              #endif // ifdef BC_TTAG_HI_RES 
    136          
    137              // or, using a macro, MSTAK(n) defined as (*pBCstack)[n]
    138              MSTAK(3).timeNextMsg = 500;       // write nonRTRT msg 3 time-to-next-msg = 500us
   \   000000D6   ........           LDR.W    R2,??DataTable10_2
   \   000000DA   1268               LDR      R2,[R2, #+0]
   \   000000DC   4FF4FA73           MOV      R3,#+500
   \   000000E0   D386               STRH     R3,[R2, #+54]
    139              j = MSTAK(1).blockStatus;         // read nonRTRT msg 1 block status word
   \   000000E2   ........           LDR.W    R2,??DataTable10_2
   \   000000E6   1268               LDR      R2,[R2, #+0]
   \   000000E8   528B               LDRH     R2,[R2, #+26]
   \   000000EA   1000               MOVS     R0,R2
    140                
    141              // --------------------------------------------------------
    142              // BC Message Stack for RT-RT messages, addressing examples
    143              // --------------------------------------------------------
    144              // BC Message Stack for RT-RT messages is comprised of 16-word message blocks (6 dummy words). 
    145              // The index, for example [0], is the message number in the stack. Message order of
    146              // execution is determined by the BC instruction list (not index number) and jumps
    147              // between this RT-RT message stack and the non-RT-RT stack...
    148              // The message stack base address is declared in file 613x_bc.h
    149                
    150              k = (*pBCstack2RT)[0].ctrlWord;      // read RT-RT msg 0 control word
   \   000000EC   ........           LDR.W    R2,??DataTable10_3
   \   000000F0   1268               LDR      R2,[R2, #+0]
   \   000000F2   1288               LDRH     R2,[R2, #+0]
   \   000000F4   1100               MOVS     R1,R2
    151              j = (*pBCstack2RT)[1].RxCmdWord;     // read RT-RT msg 1 Rx command word (1)
   \   000000F6   ........           LDR.W    R2,??DataTable10_3
   \   000000FA   1268               LDR      R2,[R2, #+0]
   \   000000FC   528C               LDRH     R2,[R2, #+34]
   \   000000FE   1000               MOVS     R0,R2
    152              k = (*pBCstack2RT)[1].TxCmdWord;     // read RT-RT msg 1 Tx command word (2)
   \   00000100   ........           LDR.W    R2,??DataTable10_3
   \   00000104   1268               LDR      R2,[R2, #+0]
   \   00000106   128E               LDRH     R2,[R2, #+48]
   \   00000108   1100               MOVS     R1,R2
    153              j = (*pBCstack2RT)[1].dataPtr;       // read data pointer for RT-RT msg 1
   \   0000010A   ........           LDR.W    R2,??DataTable10_3
   \   0000010E   1268               LDR      R2,[R2, #+0]
   \   00000110   928C               LDRH     R2,[R2, #+36]
   \   00000112   1000               MOVS     R0,R2
    154              (*pBCstack2RT)[1].timeNextMsg = 500; // write RT-RT msg 1 time-to-next-msg = 500us
   \   00000114   ........           LDR.W    R2,??DataTable10_3
   \   00000118   1268               LDR      R2,[R2, #+0]
   \   0000011A   4FF4FA73           MOV      R3,#+500
   \   0000011E   D384               STRH     R3,[R2, #+38]
    155              j = (*pBCstack2RT)[1].blockStatus;   // read RT-RT msg 1 block status word
   \   00000120   ........           LDR.W    R2,??DataTable10_3
   \   00000124   1268               LDR      R2,[R2, #+0]
   \   00000126   528D               LDRH     R2,[R2, #+42]
   \   00000128   1000               MOVS     R0,R2
    156              k = (*pBCstack2RT)[1].TxRTstatus;    // read RT-RT msg 1 transmit RT status word
   \   0000012A   ........           LDR.W    R2,??DataTable10_3
   \   0000012E   1268               LDR      R2,[R2, #+0]
   \   00000130   D28D               LDRH     R2,[R2, #+46]
   \   00000132   1100               MOVS     R1,R2
    157              j = (*pBCstack2RT)[1].RxRTstatus;    // read RT-RT msg 1 receiving RT status word
   \   00000134   ........           LDR.W    R2,??DataTable10_3
   \   00000138   1268               LDR      R2,[R2, #+0]
   \   0000013A   528E               LDRH     R2,[R2, #+50]
   \   0000013C   1000               MOVS     R0,R2
    158                
    159              #ifndef BC_TTAG_HI_RES               // BC IS USING 16-BIT TIME BASE
    160              k = (*pBCstack2RT)[1].timetag;       // read RT-RT msg 0 16-bit time tag (16-bit timebase)
    161              k = (*pBCstack2RT)[1].loopbackWord;  // read RT-RT msg 3 block loopback word (16-bit timebase)
    162                
    163              #else // ifdef BC_TTAG_HI_RES        // BC IS USING 32-BIT TIME BASE
    164              j = (*pBCstack2RT)[0].ttagLow;       // read RT-RT msg 0 32-bit time tag count LOW 16 bits
   \   0000013E   ........           LDR.W    R2,??DataTable10_3
   \   00000142   1268               LDR      R2,[R2, #+0]
   \   00000144   1289               LDRH     R2,[R2, #+8]
   \   00000146   1000               MOVS     R0,R2
    165              k = (*pBCstack2RT)[0].ttagHigh;      // read RT-RT msg 0 32-bit time tag count HIGH 16 bits
   \   00000148   ........           LDR.W    R2,??DataTable10_3
   \   0000014C   1268               LDR      R2,[R2, #+0]
   \   0000014E   9289               LDRH     R2,[R2, #+12]
   \   00000150   1100               MOVS     R1,R2
    166              #endif // ifdef BC_TTAG_HI_RES 
    167          
    168              // or, using a macro, MSTAK2RT(n) defined as (*pBCstack2RT)[n]
    169              j = MSTAK2RT(1).dataPtr;             // read data pointer for RT-RT msg 1
   \   00000152   ........           LDR.W    R2,??DataTable10_3
   \   00000156   1268               LDR      R2,[R2, #+0]
   \   00000158   928C               LDRH     R2,[R2, #+36]
   \   0000015A   1000               MOVS     R0,R2
    170              MSTAK2RT(1).timeNextMsg = 500;       // write RT-RT msg 1 time-to-next-msg = 500us
   \   0000015C   ........           LDR.W    R2,??DataTable10_3
   \   00000160   1268               LDR      R2,[R2, #+0]
   \   00000162   4FF4FA73           MOV      R3,#+500
   \   00000166   D384               STRH     R3,[R2, #+38]
    171              
    172              // preempt warnings: variable was set but never used
    173              j=j;
    174              k=k;    
    175              
    176          }   // end BC_bus_addressing_examples(void) 
   \   00000168   7047               BX       LR               ;; return
    177          
    178          
    179          #endif // (HOST_BUS_INTERFACE)    
    180          
    181          
    182          // the initialization functions below do not use the addressing methods shown above.
    183          // instead, they demonstrate alternative addressing methods...
    184          
    185          

   \                                 In section .text, align 2, keep-with-next
    186          void initialize_bc_instruction_list(void) {
   \                     initialize_bc_instruction_list:
   \   00000000   2DE9F041           PUSH     {R4-R8,LR}
   \   00000004   97B0               SUB      SP,SP,#+92
    187            
    188          	unsigned short i, j, len;
    189                  
    190                  #if (HOST_BUS_INTERFACE)                    
    191                  const unsigned int base_6130 = 0x60000000;
   \   00000006   5FF0C047           MOVS     R7,#+1610612736
    192                  unsigned int addr;
    193                  
    194                  #else // HOST SPI INTERFACE
    195                  AT91S_SPI *spi = BOARD_6131_SPI_BASE;
    196                  unsigned short dummy, k;
    197                  volatile unsigned char bufferTX[4];
    198                  #endif
    199          
    200          	unsigned short inst_list[46] = {
    201          	// test op codes WTG,XEQ,JMP, verify various msg block setups
    202          	WTG|ALWAYS, 0x0000,			// wait for ext trigger, addr = BC_ILIST_BASE_ADDR = 0x1B70 
    203          	XEQ|ALWAYS, MSG_BLK1_ADDR,		// 1
    204          	WTG|ALWAYS, 0x0000,			// wait for ext trigger
    205          	XEQ|ALWAYS, MSG_BLK2_ADDR,		// 2
    206          	WTG|ALWAYS, 0x0000,			// wait for ext trigger
    207          	XEQ|ALWAYS, MSG_BLK3_ADDR,		// 3
    208          	WTG|ALWAYS, 0x0000,			// wait for ext trigger
    209          	XEQ|ALWAYS, MSG_BLK4_ADDR,		// 4
    210          	WTG|ALWAYS, 0x0000,			// wait for ext trigger
    211          	XEQ|ALWAYS, MSG_BLK5_ADDR,		// 5
    212          	WTG|ALWAYS, 0x0000,			// wait for ext trigger
    213          	XEQ|ALWAYS, MSG_BLK6_ADDR,		// 6
    214          	WTG|ALWAYS, 0x0000,			// wait for ext trigger
    215          	XEQ|ALWAYS, MSG_BLK7_ADDR,		// 7
    216          	WTG|ALWAYS, 0x0000,			// wait for ext trigger
    217          	XEQ|ALWAYS, MSG_BLK8_ADDR,		// 8 
    218          	WTG|ALWAYS, 0x0000,			// wait for ext trigger
    219          	XEQ|ALWAYS, RTRT_MSG_BLK1_ADDR,		// RT-RT 1
    220          	WTG|ALWAYS, 0x0000,			// wait for ext trigger
    221          	XEQ|ALWAYS, RTRT_MSG_BLK2_ADDR,		// RT-RT 2
    222          	WTG|ALWAYS, 0x0000,			// wait for ext trigger
    223          	XEQ|ALWAYS, MSG_BLK2_ADDR,		// 2
    224          	JMP|ALWAYS, BC_ILIST_BASE_ADDR };	// loop to top 
   \   0000000A   00A8               ADD      R0,SP,#+0
   \   0000000C   ........           LDR.W    R1,??DataTable10_4
   \   00000010   5C22               MOVS     R2,#+92
   \   00000012   ........           BL       __aeabi_memcpy4
    225          
    226                  
    227                  // copy BC Instruction List (above) to RAM...
    228                  
    229          	#if (HOST_BUS_INTERFACE)                    
    230          
    231                      // instruction list array size, 16-bit words
    232                      len = sizeof(inst_list) / sizeof(short int);
   \   00000016   2E20               MOVS     R0,#+46
   \   00000018   0600               MOVS     R6,R0
    233                      
    234                      // set the instruction list start address.
    235                      // BC_ILIST_BASE_ADDR is defined in file 613x_bc.h 
    236                      pH6130->BC_INST_LIST_BASE_ADDR_REG = BC_ILIST_BASE_ADDR;
   \   0000001A   ........           LDR.W    R0,??DataTable10_5
   \   0000001E   0068               LDR      R0,[R0, #+0]
   \   00000020   41F67031           MOVW     R1,#+7024
   \   00000024   A0F86610           STRH     R1,[R0, #+102]
    237              
    238                      // using the address just written into the base address register,
    239                      // copy the BC Instruction List (declared above) into the HI-6130 RAM. 
    240                         
    241                      //  set up the address pointer, left-shift the list start address
    242                      addr = base_6130 + (BC_ILIST_BASE_ADDR << 1);	
   \   00000028   07F55850           ADD      R0,R7,#+13824
   \   0000002C   E030               ADDS     R0,R0,#+224
   \   0000002E   8046               MOV      R8,R0
    243                         
    244                      // write instruction list
    245                      for ( i = 0; i < len; i += 2) {
   \   00000030   0020               MOVS     R0,#+0
   \   00000032   0400               MOVS     R4,R0
   \                     ??initialize_bc_instruction_list_0:
   \   00000034   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000036   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000038   B442               CMP      R4,R6
   \   0000003A   32D2               BCS.N    ??initialize_bc_instruction_list_1
    246              
    247                          // add the validation field and odd parity bit,
    248                          // and write the adjusted op code word. 
    249                          j = inst_list[i];
   \   0000003C   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000003E   00A8               ADD      R0,SP,#+0
   \   00000040   30F81400           LDRH     R0,[R0, R4, LSL #+1]
   \   00000044   0500               MOVS     R5,R0
    250                          // the next 4 lines determine odd parity 			
    251                          j ^= j>>8;
   \   00000046   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000048   95EA1525           EORS     R5,R5,R5, LSR #+8
    252                          j ^= j>>4;
   \   0000004C   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004E   95EA1515           EORS     R5,R5,R5, LSR #+4
    253                          j &= 0xF;
   \   00000052   15F00F05           ANDS     R5,R5,#0xF
    254                          if (!((0x6996 >> j) & 1))  { 
   \   00000056   46F69610           MOVW     R0,#+27030
   \   0000005A   2841               ASRS     R0,R0,R5
   \   0000005C   C007               LSLS     R0,R0,#+31
   \   0000005E   0AD4               BMI.N    ??initialize_bc_instruction_list_2
    255                              // write the op code word with parity bit 15 = 1
    256                              j = inst_list[i] + VP1;
   \   00000060   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000062   00A8               ADD      R0,SP,#+0
   \   00000064   30F81400           LDRH     R0,[R0, R4, LSL #+1]
   \   00000068   47F6C061           MOVW     R1,#+32448
   \   0000006C   401A               SUBS     R0,R0,R1
   \   0000006E   0500               MOVS     R5,R0
    257                              *((volatile unsigned short *)(addr)) = j;
   \   00000070   A8F80050           STRH     R5,[R8, #+0]
   \   00000074   08E0               B.N      ??initialize_bc_instruction_list_3
    258                          }
    259                          else {
    260                              // write the op code word with parity bit 15 = 0
    261                              j = inst_list[i] + VP0;
   \                     ??initialize_bc_instruction_list_2:
   \   00000076   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000078   00A8               ADD      R0,SP,#+0
   \   0000007A   30F81400           LDRH     R0,[R0, R4, LSL #+1]
   \   0000007E   00F24010           ADDW     R0,R0,#+320
   \   00000082   0500               MOVS     R5,R0
    262                              *((volatile unsigned short *)(addr)) = j;
   \   00000084   A8F80050           STRH     R5,[R8, #+0]
    263                          }
    264              
    265                          addr += 2;
   \                     ??initialize_bc_instruction_list_3:
   \   00000088   18F10208           ADDS     R8,R8,#+2
    266                          // write parameter word that goes with just-written op code 
    267                          *((volatile unsigned short *)(addr)) = inst_list[i+1];
   \   0000008C   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000008E   00A8               ADD      R0,SP,#+0
   \   00000090   10EB4400           ADDS     R0,R0,R4, LSL #+1
   \   00000094   4088               LDRH     R0,[R0, #+2]
   \   00000096   A8F80000           STRH     R0,[R8, #+0]
    268                          addr += 2;
   \   0000009A   18F10208           ADDS     R8,R8,#+2
    269                      }
   \   0000009E   A41C               ADDS     R4,R4,#+2
   \   000000A0   C8E7               B.N      ??initialize_bc_instruction_list_0
    270          
    271                  #else // HOST SPI INTERFACE
    272                  
    273                      // fast-access write BC_ILIST_BASE_ADDR (defined in file 613x_bc.h) 
    274                      // into the BC Instruction List Base Address register 
    275                      Write_6131LowReg(BC_INST_LIST_BASE_ADDR_REG, BC_ILIST_BASE_ADDR, 1);
    276                      
    277                      // copy the BC Instruction List (declared above) into the HI-6130 RAM,
    278                      // starting at the address just written into the base address register
    279                      
    280                      // enable Memory Address Pointer 1
    281                      enaMAP(1);
    282                         
    283                      //  initialize the list start address into MAP1
    284                      Write_6131LowReg(MAP_1, BC_ILIST_BASE_ADDR, 1);
    285              
    286                      // instruction list array size, 16-bit words
    287                      len = sizeof(inst_list) / sizeof(short int);
    288              
    289                      __disable_interrupt();
    290                      // Assert SPI chip select
    291                      PIO_Clear(pinNss); 
    292                      // Wait for TDR and shifter = empty
    293                      while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
    294                      // Send SPI write op code 0xC0 
    295                      spi->SPI_TDR = 0xC0 | SPI_PCS(BOARD_6131_NPCS);
    296                      // Wait for TDRE flag (Tx Data Register Empty)
    297                      while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
    298                      // Wait for RDRF flag (Rx Data Register Full)
    299                      while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
    300                      // Read and discard received data char in Rx buffer
    301                      dummy = spi->SPI_RDR & 0xFFFF;
    302                      // prevent warning: variable dummy was set but never used
    303                      dummy = dummy;
    304                      
    305                      // write instruction list
    306                      for ( i = 0; i < len; i += 2) {
    307              
    308                          // add the validation field and odd parity bit,
    309                          // and write the adjusted op code word. 
    310                          j = inst_list[i];
    311                          // the next 4 lines determine odd parity 			
    312                          j ^= j>>8;
    313                          j ^= j>>4;
    314                          j &= 0xF;
    315                          if (!((0x6996 >> j) & 1))  { 
    316                              // add validation field and parity bit 15 = 1
    317                              j = inst_list[i] + VP1;
    318                          }
    319                          else {
    320                              // add validation field and parity bit 15 = 0
    321                              j = inst_list[i] + VP0;
    322                          }
    323                          // upper and lower op code word bytes
    324                          bufferTX[0] = (char)(j >> 8);          
    325                          bufferTX[1] = (char)j;               
    326                          // upper and lower parameter word bytes
    327                          bufferTX[2] = (char)(inst_list[i+1] >> 8);          
    328                          bufferTX[3] = (char)(inst_list[i+1]); 
    329              
    330                          // transmit the 4 bytes
    331                          for (k = 0; k < 4; k++) {
    332                              // Wait for TDR and shifter = empty
    333                              while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
    334                              // transmit next byte
    335                              spi->SPI_TDR = bufferTX[k] | SPI_PCS(BOARD_6131_NPCS);
    336                              // Wait for TDRE flag (Tx Data Register Empty)
    337                              while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
    338                              // Wait for RDRF flag (Rx Data Register Full)
    339                              while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
    340                              // Read and discard received data char in Rx buffer
    341                              dummy = spi->SPI_RDR & 0xFFFF;
    342                          }  
    343                      }
    344                      // negate slave chip select
    345                      PIO_Set(pinNss);
    346                      __enable_interrupt();	        
    347                      
    348                  #endif // HOST SPI INTERFACE
    349                  
    350          }	// end initialize_bc_instruction_list()
   \                     ??initialize_bc_instruction_list_1:
   \   000000A2   17B0               ADD      SP,SP,#+92
   \   000000A4   BDE8F081           POP      {R4-R8,PC}       ;; return
    351          
    352          
    353          
    354          // 	Next function initializes ten HI-613x Bus Controller Control/Status Blocks 
    355          //      for test purposes, and initializes BC transmit data buffers used with RT receive commands. 
    356          //
    357          //	Msg Block 1  = Subaddress Tx  Command 03-1-30-00 (loopback subaddress) Bus A
    358          //	Msg Block 2  = Subaddress Tx  Command 03-1-30-00 (loopback subaddress) Bus B
    359          //	Msg Block 3  = Subaddress Rx  Command 03-0-30-00 (loopback subaddress) Bus A
    360          //	Msg Block 4  = Subaddress BRx Command 31-0-05-11                       Bus B
    361          //	Msg Block 5  = Subaddress BRx Command 31-0-30-00 (loopback subaddress) Bus A
    362          //	Msg Block 6  = Mode Code  Tx  Command 03-1-31-02 (tx mode code 2)      Bus B
    363          //	Msg Block 7  = Mode Code  Tx  Command 03-1-31-18 (tx mode code 18)     Bus A
    364          //	Msg Block 8  = Mode Code  Rx  Command 03-0-31-21 (rx mode code 21)     Bus B
    365          //      RT-RT Msg Block 1 = RT-RT msg Commands 04-0-30-02 03-1-05-02           Bus A
    366          //      RT-RT Msg Block 2 = BRT-RT msg Commands 31-0-30-11 04-1-05-11          Bus B
    367          // 
    368           

   \                                 In section .text, align 2, keep-with-next
    369          void initialize_bc_msg_blocks(void) {
   \                     initialize_bc_msg_blocks:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   C0B0               SUB      SP,SP,#+256
    370          	
    371                  #if (HOST_BUS_INTERFACE)
    372                  const unsigned int base_6130 = 0x60000000;
   \   00000004   5FF0C044           MOVS     R4,#+1610612736
    373                  unsigned int addr;
    374                  #endif
    375                  
    376          	unsigned short i;
    377          	unsigned short data[32] = {0x0101,0x0202,0x0303,0x0404,0x0505,0x0606,0x0707,0x0808,
    378          			      0x0909,0x1010,0x1111,0x1212,0x1313,0x1414,0x1515,0x1616,
    379          			      0x1717,0x1818,0x1919,0x2020,0x2121,0x2222,0x2323,0x2424,
    380          			      0x2525,0x2626,0x2727,0x2828,0x2929,0x3030,0x3131,0x3232};
   \   00000008   30A8               ADD      R0,SP,#+192
   \   0000000A   ........           LDR.W    R1,??DataTable10_6
   \   0000000E   4022               MOVS     R2,#+64
   \   00000010   ........           BL       __aeabi_memcpy4
    381          	//unsigned short data[32] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    382          
    383          
    384                  // ********************************************************************************
    385                  // Msg Block 1  = Subaddress Tx  Command 03-1-30-00 (loopback subaddress) Bus A
    386                  
    387          	unsigned short msg_block1[8] = {
    388          	//  Contro1 Word Options = TXTTMC17|MEMASK|SRQMASK|BSYMASK|SSFMASK|TFMASK|RSVMASK
    389          	//			   |RTRYENA|USEBUSA|USEBUSB|SFTEST|MSKBCR|EOMINT|MCODE|BCST|RT_RT 
    390          	//  Contro1 Word          
    391          	    RTRYENA|MEMASK|USEBUSA,
    392          
    393          	//  Command Word (Transmit Command, RT --> BC )
    394          	//  RT Addr Tx/Rx  SubAdd  WordCt 
    395          	    3<<11  | TX  | 30<<5 | 0,
    396          
    397          	//  Data     Time to   TimeTag  Block    LoopBack RT
    398          	//  Addr     NextMsg   Word     Status   Word     Status 
    399          	    0x5308,  0x0200,  0xABCD,  0xABCD,  0xABCD,  0xABCD };    
   \   00000014   1CA8               ADD      R0,SP,#+112
   \   00000016   ........           LDR.W    R1,??DataTable10_7
   \   0000001A   1022               MOVS     R2,#+16
   \   0000001C   ........           BL       __aeabi_memcpy4
    400          
    401          	// ********************************************************************************
    402                  // Msg Block 2  = Subaddress Tx  Command 03-1-30-00 (loopback subaddress) Bus B
    403          
    404          	unsigned short msg_block2[8] = {
    405          	//  Contro1 Word Options = TXTTMC17|MEMASK|SRQMASK|BSYMASK|SSFMASK|TFMASK|RSVMASK
    406          	//			   |RTRYENA|USEBUSA|USEBUSB|SFTEST|MSKBCR|EOMINT|MCODE|BCST|RT_RT 
    407          	//  Contro1 Word          
    408          	    RTRYENA|MEMASK|USEBUSB,
    409          
    410          	//  Command Word (Transmit Command, RT --> BC )
    411          	//  RT Addr Tx/Rx  SubAdd  WordCt 
    412          	    3<<11  | TX  | 30<<5 | 0,
    413          
    414          	//  Data     Time to   TimeTag  Block    LoopBack RT
    415          	//  Addr     NextMsg   Word     Status   Word     Status 
    416          	    0x5308,  0x0200,  0xABCD,  0xABCD,  0xABCD,  0xABCD };    
   \   00000020   18A8               ADD      R0,SP,#+96
   \   00000022   ........           LDR.W    R1,??DataTable10_8
   \   00000026   1022               MOVS     R2,#+16
   \   00000028   ........           BL       __aeabi_memcpy4
    417          
    418          	// ********************************************************************************
    419                  // Msg Block 3  = Subaddress Rx  Command 03-0-30-00 (loopback subaddress) Bus A
    420          
    421          	unsigned short msg_block3[8] = {
    422          	//  Contro1 Word Options = TXTTMC17|MEMASK|SRQMASK|BSYMASK|SSFMASK|TFMASK|RSVMASK
    423          	//                         |RTRYENA|USEBUSA|USEBUSB|SFTEST|MSKBCR|EOMINT|MCODE|BCST|RT_RT 
    424          	//  Contro1 Word          
    425          	    MEMASK|MSKBCR|USEBUSA,
    426          
    427          	//  Command Word (Receive Command, BC --> RT )
    428          	//  RT Addr Tx/Rx  SubAdd  WordCt 
    429          	    3<<11  | RX  | 30<<5 | 0,
    430          
    431          	//  Data     Time to   TimeTag  Block    LoopBack RT
    432          	//  Addr     NextMsg   Word     Status   Word     Status 
    433          	    0x5328,  700,      0xABCD,  0xABCD,  0xABCD,  0xABCD };   
   \   0000002C   08A8               ADD      R0,SP,#+32
   \   0000002E   ........           LDR.W    R1,??DataTable10_9
   \   00000032   1022               MOVS     R2,#+16
   \   00000034   ........           BL       __aeabi_memcpy4
    434          
    435          	// ********************************************************************************
    436                  // Msg Block 4  = Subaddress BRx Command 31-0-05-11 Bus B
    437          
    438          	unsigned short msg_block4[8] = {
    439          	//  Contro1 Word Options = TXTTMC17|MEMASK|SRQMASK|BSYMASK|SSFMASK|TFMASK|RSVMASK
    440          	//                         |RTRYENA|USEBUSA|USEBUSB|SFTEST|MSKBCR|EOMINT|MCODE|BCST|RT_RT 
    441          	//  Contro1 Word
    442          	    MEMASK|MSKBCR|BCST|USEBUSB,
    443          
    444          	//  Command Word (Broadcast Receive Command, BC --> RTs )
    445          	//  RT Addr  Tx/Rx  SubAdd  WordCt 
    446          	    31<<11 |  RX   | 1<<5 | 11,
    447          
    448          	//  Data     Time to   TimeTag  Block    LoopBack RT
    449          	//  Addr     NextMsg   Word     Status   Word     Status 
    450          	    0x5348,  0x333,    0xABCD,  0xABCD,  0xABCD,  0xABCD };   
   \   00000038   04A8               ADD      R0,SP,#+16
   \   0000003A   ........           LDR.W    R1,??DataTable10_10
   \   0000003E   1022               MOVS     R2,#+16
   \   00000040   ........           BL       __aeabi_memcpy4
    451          
    452          	// ********************************************************************************
    453                  // Msg Block 5  = Subaddress BRx Command 31-0-30-00 (loopback subaddress) Bus A
    454          
    455          	unsigned short msg_block5[8] = {
    456          	//  Contro1 Word Options = TXTTMC17|MEMASK|SRQMASK|BSYMASK|SSFMASK|TFMASK|RSVMASK
    457          	//			   |RTRYENA|USEBUSA|USEBUSB|SFTEST|MSKBCR|EOMINT|MCODE|BCST|RT_RT 
    458          	//  Contro1 Word
    459          	    MEMASK|MSKBCR|BCST|USEBUSA,
    460          
    461          	//  Command Word (Broadcast Receive Command, BC --> RTs )
    462          	//  RT Addr  Tx/Rx  SubAdd  WordCt 
    463          	    31<<11 |  RX   |30<<5 | 0,
    464          
    465          	//  Data     Time to   TimeTag  Block    LoopBack RT
    466          	//  Addr     NextMsg   Word     Status   Word     Status 
    467          	    0x5368,  0,        0xABCD,  0xABCD,  0xABCD,  0xABCD };    
   \   00000044   00A8               ADD      R0,SP,#+0
   \   00000046   ........           LDR.W    R1,??DataTable10_11
   \   0000004A   1022               MOVS     R2,#+16
   \   0000004C   ........           BL       __aeabi_memcpy4
    468          
    469          	// ********************************************************************************
    470                  // Msg Block 6  = Mode Code  Tx  Command 03-1-31-02 (tx mode code 2) Bus B
    471          
    472          
    473          	unsigned short msg_block6[8] = {
    474          	//  Contro1 Word Options = TXTTMC17|MEMASK|SRQMASK|BSYMASK|SSFMASK|TFMASK|RSVMASK
    475          	//			   |RTRYENA|USEBUSA|USEBUSB|SFTEST|MSKBCR|EOMINT|MCODE|BCST|RT_RT 
    476          	//  Contro1 Word
    477          	    MEMASK|MSKBCR|MCODE|USEBUSB,
    478          
    479          	//  Command Word (Transmit Mode Command, MC0-MC15 ONLY )
    480          	//  RT Addr  Tx/Rx  SubAdd  MCode 
    481          	    3<<11 |  TX   | 31<<5 | 2,
    482          
    483          	//  Data     Time to   TimeTag  Block    LoopBack RT
    484          	//  Addr     NextMsg   Word     Status   Word     Status 
    485          	    0xDEAD,  0,        0xABCD,  0xABCD,  0xABCD,  0xABCD };   
   \   00000050   14A8               ADD      R0,SP,#+80
   \   00000052   ........           LDR.W    R1,??DataTable10_12
   \   00000056   1022               MOVS     R2,#+16
   \   00000058   ........           BL       __aeabi_memcpy4
    486          
    487          	// ********************************************************************************
    488                  // Msg Block 7  = Mode Code  Tx  Command 03-1-31-18 (tx mode code 18)     Bus A
    489          
    490          	unsigned short msg_block7[8] = {
    491          	//  Contro1 Word Options = TXTTMC17|MEMASK|SRQMASK|BSYMASK|SSFMASK|TFMASK|RSVMASK
    492          	//			   |RTRYENA|USEBUSA|USEBUSB|SFTEST|MSKBCR|EOMINT|MCODE|BCST|RT_RT 
    493          	//  Contro1 Word
    494          	    MEMASK|MSKBCR|MCODE|USEBUSA,
    495           
    496          	//  Command Word (Transmit Mode Command, MC16-MC31 ONLY )
    497          	//  RT Addr  Tx/Rx  SubAdd  MCode 
    498          	    3<<11  |  TX  | 31<<5 | 18,
    499          
    500          	//  Data     Time to   TimeTag  Block    LoopBack RT
    501          	//  Addr     NextMsg   Word     Status   Word     Status 
    502          	    0x1B62,  0,        0xABCD,  0xABCD,  0xABCD,  0xABCD };    
   \   0000005C   10A8               ADD      R0,SP,#+64
   \   0000005E   ........           LDR.W    R1,??DataTable10_13
   \   00000062   1022               MOVS     R2,#+16
   \   00000064   ........           BL       __aeabi_memcpy4
    503          
    504          	// ********************************************************************************
    505                  // Msg Block 8  = Mode Code  Rx  Command 03-0-31-21 (rx mode code 21)     Bus B
    506          
    507          	unsigned short msg_block8[8] = {
    508          	//  Contro1 Word Options = TXTTMC17|MEMASK|SRQMASK|BSYMASK|SSFMASK|TFMASK|RSVMASK
    509          	//			   |RTRYENA|USEBUSA|USEBUSB|SFTEST|MSKBCR|EOMINT|MCODE|BCST|RT_RT 
    510          	//  Contro1 Word
    511          	    MEMASK|MSKBCR|MCODE|TXTTMC17|USEBUSB,
    512          
    513          	//  Command Word (Receive Mode Command, MC16-MC31 ONLY )
    514          	//  RT Addr  Tx/Rx  SubAdd  MCode 
    515          	    3<<11  |  RX   | 31<<5 | 21,
    516          
    517          	//  Data     Time to   TimeTag  Block    LoopBack RT
    518          	//  Addr     NextMsg   Word     Status   Word     Status 
    519          	    0x1B55,  0,        0xABCD,  0xABCD,  0xABCD,  0xABCD };   
   \   00000068   0CA8               ADD      R0,SP,#+48
   \   0000006A   ........           LDR.W    R1,??DataTable10_14
   \   0000006E   1022               MOVS     R2,#+16
   \   00000070   ........           BL       __aeabi_memcpy4
    520          
    521          	// ********************************************************************************
    522                  // RT-RT Msg Block 1   to RxRT4 from TxRT3   04-0-30-02 03-1-05-02  Bus A
    523          
    524          	unsigned short rtrt_msg_block1[16] = {
    525          	// This format is only used for RT-to-RT messages
    526          
    527          	//  Contro1 Word Options = TXTTMC17|MEMASK|SRQMASK|BSYMASK|SSFMASK|TFMASK|RSVMASK
    528          	//			   |RTRYENA|USEBUSA|USEBUSB|SFTEST|MSKBCR|EOMINT|MCODE|BCST|RT_RT 
    529          	//  Contro1 Word
    530          	    MEMASK|MSKBCR|RT_RT|USEBUSA,
    531          
    532          	//  Rx Command Word 
    533          	//  RT Addr  Tx/Rx  SubAdd  WordCt 
    534          	    4<<11  |  RX  |  30<<5 | 2,
    535          
    536          	//  Data     Time to   TimeTag  Block    LoopBack RT
    537          	//  Addr     NextMsg   Word     Status   Word     Status 
    538          	    0x5388,  0,        0xABCD,  0xABCD,  0xABCD,  0xABCD,  
    539          
    540          	//  Tx Command Word 
    541          	//  RT Addr  Tx/Rx  SubAdd  WordCt 
    542          	    3<<11  |  TX   | 1<<5 | 2,
    543          
    544          	//  Rx RT
    545          	//  Status   6 unused addresses for RT-to-RT only       
    546          	    0x0000,  0xDEAD, 0xDEAD, 0xDEAD, 0xDEAD, 0xDEAD, 0xDEAD };
   \   00000074   28A8               ADD      R0,SP,#+160
   \   00000076   ........           LDR.W    R1,??DataTable10_15
   \   0000007A   2022               MOVS     R2,#+32
   \   0000007C   ........           BL       __aeabi_memcpy4
    547          
    548          	// ********************************************************************************
    549                  // RT-RT Msg Block 2   broadcast to RxRT31 from TxRT3    31-0-30-11 04-1-05-11   Bus B
    550          
    551          	unsigned short rtrt_msg_block2[16] = {
    552          	// This format is only used for RT-to-RT messages 
    553          
    554          	//  Contro1 Word Options = TXTTMC17|MEMASK|SRQMASK|BSYMASK|SSFMASK|TFMASK|RSVMASK
    555          	//			   |RTRYENA|USEBUSA|USEBUSB|SFTEST|MSKBCR|EOMINT|MCODE|BCST|RT_RT 
    556          	//  Contro1 Word
    557          	    MEMASK|MSKBCR|BCST|RT_RT|USEBUSB,
    558          
    559          	//  Rx Command Word 
    560          	//  RT Addr  Tx/Rx  SubAdd  WordCt 
    561          	    31<<11 |  RX   |30<<5 | 11,
    562          
    563          	//  Data     Time to   TimeTag  Block    LoopBack RT
    564          	//  Addr     NextMsg   Word     Status   Word     Status 
    565          	    0x53A8,  0,        0xABCD,  0xABCD,  0xABCD,  0xABCD,
    566          
    567          	//  Tx Command Word 
    568          	//  RT Addr  Tx/Rx  SubAdd  WordCt 
    569          	    4<<11  |  TX   | 1<<5 | 11,
    570          
    571          	//  Rx RT
    572          	//  Status   6 unused addresses for RT-to-RT only       
    573          	    0x0000,  0xDEAD, 0xDEAD, 0xDEAD, 0xDEAD, 0xDEAD, 0xDEAD };
   \   00000080   20A8               ADD      R0,SP,#+128
   \   00000082   ........           LDR.W    R1,??DataTable10_16
   \   00000086   2022               MOVS     R2,#+32
   \   00000088   ........           BL       __aeabi_memcpy4
    574          
    575          	// ********************************************************************************
    576          
    577          	#if (HOST_BUS_INTERFACE) 
    578          
    579          		// Initialize BC Message Control / Status Blocks  
    580          
    581                  	//  set up the address pointer, left-shift the start address/offset 
    582          		// these message blocks will be contiguous, stored back-to-back 
    583          		addr = base_6130 + (MSG_BLK1_ADDR << 1);	
   \   0000008C   14F5F840           ADDS     R0,R4,#+31744
   \   00000090   0500               MOVS     R5,R0
    584          
    585          		// these non-RT-RT blocks need 8 words, must start with low nibble = 0x0 or 0x8 
    586          
    587          		for ( i = 0; i < 8; i++) {
   \   00000092   0020               MOVS     R0,#+0
   \   00000094   0600               MOVS     R6,R0
   \                     ??initialize_bc_msg_blocks_0:
   \   00000096   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000098   082E               CMP      R6,#+8
   \   0000009A   07D2               BCS.N    ??initialize_bc_msg_blocks_1
    588                                  *((volatile unsigned short *)(addr)) = msg_block1[i]; // 0x3E00 - 0x3E07
   \   0000009C   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000009E   1CA8               ADD      R0,SP,#+112
   \   000000A0   30F81600           LDRH     R0,[R0, R6, LSL #+1]
   \   000000A4   2880               STRH     R0,[R5, #+0]
    589          			addr += 2;
   \   000000A6   AD1C               ADDS     R5,R5,#+2
    590          		}
   \   000000A8   761C               ADDS     R6,R6,#+1
   \   000000AA   F4E7               B.N      ??initialize_bc_msg_blocks_0
    591          
    592          		for ( i = 0; i < 8; i++) {
   \                     ??initialize_bc_msg_blocks_1:
   \   000000AC   0020               MOVS     R0,#+0
   \   000000AE   0600               MOVS     R6,R0
   \                     ??initialize_bc_msg_blocks_2:
   \   000000B0   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000B2   082E               CMP      R6,#+8
   \   000000B4   07D2               BCS.N    ??initialize_bc_msg_blocks_3
    593          			*((volatile unsigned short *)(addr)) = msg_block2[i]; // 0x3E08 - 0x3E0F
   \   000000B6   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000B8   18A8               ADD      R0,SP,#+96
   \   000000BA   30F81600           LDRH     R0,[R0, R6, LSL #+1]
   \   000000BE   2880               STRH     R0,[R5, #+0]
    594          			addr += 2;
   \   000000C0   AD1C               ADDS     R5,R5,#+2
    595          		}
   \   000000C2   761C               ADDS     R6,R6,#+1
   \   000000C4   F4E7               B.N      ??initialize_bc_msg_blocks_2
    596          
    597          		for ( i = 0; i < 8; i++) {
   \                     ??initialize_bc_msg_blocks_3:
   \   000000C6   0020               MOVS     R0,#+0
   \   000000C8   0600               MOVS     R6,R0
   \                     ??initialize_bc_msg_blocks_4:
   \   000000CA   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000CC   082E               CMP      R6,#+8
   \   000000CE   07D2               BCS.N    ??initialize_bc_msg_blocks_5
    598          			*((volatile unsigned short *)(addr)) = msg_block3[i]; // 0x3E10 - 0x3E17
   \   000000D0   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000D2   08A8               ADD      R0,SP,#+32
   \   000000D4   30F81600           LDRH     R0,[R0, R6, LSL #+1]
   \   000000D8   2880               STRH     R0,[R5, #+0]
    599          			addr += 2;
   \   000000DA   AD1C               ADDS     R5,R5,#+2
    600          		}
   \   000000DC   761C               ADDS     R6,R6,#+1
   \   000000DE   F4E7               B.N      ??initialize_bc_msg_blocks_4
    601          
    602          		for ( i = 0; i < 8; i++) {
   \                     ??initialize_bc_msg_blocks_5:
   \   000000E0   0020               MOVS     R0,#+0
   \   000000E2   0600               MOVS     R6,R0
   \                     ??initialize_bc_msg_blocks_6:
   \   000000E4   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000E6   082E               CMP      R6,#+8
   \   000000E8   07D2               BCS.N    ??initialize_bc_msg_blocks_7
    603          			*((volatile unsigned short *)(addr)) = msg_block4[i]; // 0x3E18 - 0x3E1F
   \   000000EA   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000EC   04A8               ADD      R0,SP,#+16
   \   000000EE   30F81600           LDRH     R0,[R0, R6, LSL #+1]
   \   000000F2   2880               STRH     R0,[R5, #+0]
    604          			addr += 2;
   \   000000F4   AD1C               ADDS     R5,R5,#+2
    605          		}
   \   000000F6   761C               ADDS     R6,R6,#+1
   \   000000F8   F4E7               B.N      ??initialize_bc_msg_blocks_6
    606          
    607          
    608          		for ( i = 0; i < 8; i++) {
   \                     ??initialize_bc_msg_blocks_7:
   \   000000FA   0020               MOVS     R0,#+0
   \   000000FC   0600               MOVS     R6,R0
   \                     ??initialize_bc_msg_blocks_8:
   \   000000FE   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000100   082E               CMP      R6,#+8
   \   00000102   07D2               BCS.N    ??initialize_bc_msg_blocks_9
    609          			*((volatile unsigned short *)(addr)) = msg_block5[i]; // 0x3E20 - 0x3E27
   \   00000104   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000106   00A8               ADD      R0,SP,#+0
   \   00000108   30F81600           LDRH     R0,[R0, R6, LSL #+1]
   \   0000010C   2880               STRH     R0,[R5, #+0]
    610          			addr += 2;
   \   0000010E   AD1C               ADDS     R5,R5,#+2
    611          		}
   \   00000110   761C               ADDS     R6,R6,#+1
   \   00000112   F4E7               B.N      ??initialize_bc_msg_blocks_8
    612          
    613          		for ( i = 0; i < 8; i++) {
   \                     ??initialize_bc_msg_blocks_9:
   \   00000114   0020               MOVS     R0,#+0
   \   00000116   0600               MOVS     R6,R0
   \                     ??initialize_bc_msg_blocks_10:
   \   00000118   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000011A   082E               CMP      R6,#+8
   \   0000011C   07D2               BCS.N    ??initialize_bc_msg_blocks_11
    614          			*((volatile unsigned short *)(addr)) = msg_block6[i]; // 0x3E28 - 0x3E2F
   \   0000011E   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000120   14A8               ADD      R0,SP,#+80
   \   00000122   30F81600           LDRH     R0,[R0, R6, LSL #+1]
   \   00000126   2880               STRH     R0,[R5, #+0]
    615          			addr += 2;
   \   00000128   AD1C               ADDS     R5,R5,#+2
    616          		}
   \   0000012A   761C               ADDS     R6,R6,#+1
   \   0000012C   F4E7               B.N      ??initialize_bc_msg_blocks_10
    617          
    618          		for ( i = 0; i < 8; i++) {
   \                     ??initialize_bc_msg_blocks_11:
   \   0000012E   0020               MOVS     R0,#+0
   \   00000130   0600               MOVS     R6,R0
   \                     ??initialize_bc_msg_blocks_12:
   \   00000132   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000134   082E               CMP      R6,#+8
   \   00000136   07D2               BCS.N    ??initialize_bc_msg_blocks_13
    619          			*((volatile unsigned short *)(addr)) = msg_block7[i]; // 0x3E30 - 0x3E37
   \   00000138   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000013A   10A8               ADD      R0,SP,#+64
   \   0000013C   30F81600           LDRH     R0,[R0, R6, LSL #+1]
   \   00000140   2880               STRH     R0,[R5, #+0]
    620          			addr += 2;
   \   00000142   AD1C               ADDS     R5,R5,#+2
    621          		}
   \   00000144   761C               ADDS     R6,R6,#+1
   \   00000146   F4E7               B.N      ??initialize_bc_msg_blocks_12
    622          
    623          		for ( i = 0; i < 8; i++) {
   \                     ??initialize_bc_msg_blocks_13:
   \   00000148   0020               MOVS     R0,#+0
   \   0000014A   0600               MOVS     R6,R0
   \                     ??initialize_bc_msg_blocks_14:
   \   0000014C   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000014E   082E               CMP      R6,#+8
   \   00000150   07D2               BCS.N    ??initialize_bc_msg_blocks_15
    624          			*((volatile unsigned short *)(addr)) = msg_block8[i]; // 0x3E38 - 0x3E3F
   \   00000152   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000154   0CA8               ADD      R0,SP,#+48
   \   00000156   30F81600           LDRH     R0,[R0, R6, LSL #+1]
   \   0000015A   2880               STRH     R0,[R5, #+0]
    625          			addr += 2;
   \   0000015C   AD1C               ADDS     R5,R5,#+2
    626          		}
   \   0000015E   761C               ADDS     R6,R6,#+1
   \   00000160   F4E7               B.N      ??initialize_bc_msg_blocks_14
    627          		
    628          		// these next RT-RT blocks need 16 words, MUST start with low nibble = 0x0 
    629          
    630          		for ( i = 0; i < 16; i++) {
   \                     ??initialize_bc_msg_blocks_15:
   \   00000162   0020               MOVS     R0,#+0
   \   00000164   0600               MOVS     R6,R0
   \                     ??initialize_bc_msg_blocks_16:
   \   00000166   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000168   102E               CMP      R6,#+16
   \   0000016A   07D2               BCS.N    ??initialize_bc_msg_blocks_17
    631          			*((volatile unsigned short *)(addr)) = rtrt_msg_block1[i]; // 0x3E40 - 0x3E4F
   \   0000016C   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000016E   28A8               ADD      R0,SP,#+160
   \   00000170   30F81600           LDRH     R0,[R0, R6, LSL #+1]
   \   00000174   2880               STRH     R0,[R5, #+0]
    632          			addr += 2;
   \   00000176   AD1C               ADDS     R5,R5,#+2
    633          		}
   \   00000178   761C               ADDS     R6,R6,#+1
   \   0000017A   F4E7               B.N      ??initialize_bc_msg_blocks_16
    634          
    635          		for ( i = 0; i < 16; i++) {
   \                     ??initialize_bc_msg_blocks_17:
   \   0000017C   0020               MOVS     R0,#+0
   \   0000017E   0600               MOVS     R6,R0
   \                     ??initialize_bc_msg_blocks_18:
   \   00000180   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000182   102E               CMP      R6,#+16
   \   00000184   07D2               BCS.N    ??initialize_bc_msg_blocks_19
    636          			*((volatile unsigned short *)(addr)) = rtrt_msg_block2[i]; // 0x3E50 - 0x3E5F
   \   00000186   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000188   20A8               ADD      R0,SP,#+128
   \   0000018A   30F81600           LDRH     R0,[R0, R6, LSL #+1]
   \   0000018E   2880               STRH     R0,[R5, #+0]
    637          			addr += 2;
   \   00000190   AD1C               ADDS     R5,R5,#+2
    638          		}
   \   00000192   761C               ADDS     R6,R6,#+1
   \   00000194   F4E7               B.N      ??initialize_bc_msg_blocks_18
    639          
    640          
    641          		// write dummy data into the transmit data buffers for the 3 receive subaddress commands 
    642                          // REMEMBER: For Receive commands (that is RT receives), the BC IS TRANSMITTING...
    643          
    644          		// a 32-word buffer for rx msg block 3
    645          		addr = msg_block3[2] << 1;
   \                     ??initialize_bc_msg_blocks_19:
   \   00000196   BDF82400           LDRH     R0,[SP, #+36]
   \   0000019A   4000               LSLS     R0,R0,#+1
   \   0000019C   0500               MOVS     R5,R0
    646                          addr += base_6130;
   \   0000019E   6519               ADDS     R5,R4,R5
    647          		// write the 32 data words...
    648          		for ( i = 0; i < 32; i++) {	
   \   000001A0   0020               MOVS     R0,#+0
   \   000001A2   0600               MOVS     R6,R0
   \                     ??initialize_bc_msg_blocks_20:
   \   000001A4   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000001A6   202E               CMP      R6,#+32
   \   000001A8   07D2               BCS.N    ??initialize_bc_msg_blocks_21
    649          			*((volatile unsigned short *)(addr)) = data[i];
   \   000001AA   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000001AC   30A8               ADD      R0,SP,#+192
   \   000001AE   30F81600           LDRH     R0,[R0, R6, LSL #+1]
   \   000001B2   2880               STRH     R0,[R5, #+0]
    650          			addr += 2;
   \   000001B4   AD1C               ADDS     R5,R5,#+2
    651          		}
   \   000001B6   761C               ADDS     R6,R6,#+1
   \   000001B8   F4E7               B.N      ??initialize_bc_msg_blocks_20
    652          
    653          		// a 32-word buffer for rx msg block 4
    654          		addr = msg_block4[2] << 1;
   \                     ??initialize_bc_msg_blocks_21:
   \   000001BA   BDF81400           LDRH     R0,[SP, #+20]
   \   000001BE   4000               LSLS     R0,R0,#+1
   \   000001C0   0500               MOVS     R5,R0
    655                          addr += base_6130;
   \   000001C2   6519               ADDS     R5,R4,R5
    656          		// write the 32 data words...
    657          		for ( i = 0; i < 32; i++) {	
   \   000001C4   0020               MOVS     R0,#+0
   \   000001C6   0600               MOVS     R6,R0
   \                     ??initialize_bc_msg_blocks_22:
   \   000001C8   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000001CA   202E               CMP      R6,#+32
   \   000001CC   07D2               BCS.N    ??initialize_bc_msg_blocks_23
    658          			*((volatile unsigned short *)(addr)) = data[i];
   \   000001CE   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000001D0   30A8               ADD      R0,SP,#+192
   \   000001D2   30F81600           LDRH     R0,[R0, R6, LSL #+1]
   \   000001D6   2880               STRH     R0,[R5, #+0]
    659          			addr += 2;
   \   000001D8   AD1C               ADDS     R5,R5,#+2
    660          		}
   \   000001DA   761C               ADDS     R6,R6,#+1
   \   000001DC   F4E7               B.N      ??initialize_bc_msg_blocks_22
    661          
    662          		// a 32-word buffer for rx msg block 5
    663          		addr = msg_block5[2] << 1;
   \                     ??initialize_bc_msg_blocks_23:
   \   000001DE   BDF80400           LDRH     R0,[SP, #+4]
   \   000001E2   4000               LSLS     R0,R0,#+1
   \   000001E4   0500               MOVS     R5,R0
    664                          addr += base_6130;
   \   000001E6   6519               ADDS     R5,R4,R5
    665          		// write the 32 data words...
    666          		for ( i = 0; i < 32; i++) {	
   \   000001E8   0020               MOVS     R0,#+0
   \   000001EA   0600               MOVS     R6,R0
   \                     ??initialize_bc_msg_blocks_24:
   \   000001EC   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000001EE   202E               CMP      R6,#+32
   \   000001F0   07D2               BCS.N    ??initialize_bc_msg_blocks_25
    667          			*((volatile unsigned short *)(addr)) = data[i];
   \   000001F2   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000001F4   30A8               ADD      R0,SP,#+192
   \   000001F6   30F81600           LDRH     R0,[R0, R6, LSL #+1]
   \   000001FA   2880               STRH     R0,[R5, #+0]
    668          			addr += 2;
   \   000001FC   AD1C               ADDS     R5,R5,#+2
    669          		}
   \   000001FE   761C               ADDS     R6,R6,#+1
   \   00000200   F4E7               B.N      ??initialize_bc_msg_blocks_24
    670          
    671          		// 16 mode data words for Rx MC16-MC31 
    672          		addr = 0x1B50 << 1;
   \                     ??initialize_bc_msg_blocks_25:
   \   00000202   43F2A060           MOVW     R0,#+13984
   \   00000206   0500               MOVS     R5,R0
    673                          addr += base_6130;
   \   00000208   6519               ADDS     R5,R4,R5
    674          		for ( i = 0; i < 16; i++) {	
   \   0000020A   0020               MOVS     R0,#+0
   \   0000020C   0600               MOVS     R6,R0
   \                     ??initialize_bc_msg_blocks_26:
   \   0000020E   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000210   102E               CMP      R6,#+16
   \   00000212   08D2               BCS.N    ??initialize_bc_msg_blocks_27
    675          			// writes 0x1616 for Rx MC16 thru 0x3131 for Rx MC31
    676          			*((volatile unsigned short *)(addr)) = data[i+15];
   \   00000214   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000216   30A8               ADD      R0,SP,#+192
   \   00000218   10EB4600           ADDS     R0,R0,R6, LSL #+1
   \   0000021C   C08B               LDRH     R0,[R0, #+30]
   \   0000021E   2880               STRH     R0,[R5, #+0]
    677          			addr += 2;
   \   00000220   AD1C               ADDS     R5,R5,#+2
    678          		}
   \   00000222   761C               ADDS     R6,R6,#+1
   \   00000224   F3E7               B.N      ??initialize_bc_msg_blocks_26
    679          
    680          	// ********************************************************************************
    681          
    682          
    683          	#else // not (HOST_BUS_INTERFACE) = SPI INTERFACE
    684                          
    685          		// copy the BC Message Control / Status Blocks (declared above) into HI-6131 RAM
    686                          
    687                          // enable Memory Address Pointer 1
    688                          enaMAP(1);
    689                     
    690                  	//  initialize the list start address into MAP1
    691          	        Write_6131LowReg(MAP_1, MSG_BLK1_ADDR, 1);	
    692          
    693          		// these message blocks are contiguous, stored back-to-back.
    694          		// take advantage of Mem Addr Pointer auto-increment after each write 
    695          
    696          
    697          		// these non-RT-RT blocks need 8 words, must start with low nibble = 0x0 or 0x8 
    698          		for ( i = 0; i < 8; i++) {
    699          			Write_6131_1word(msg_block1[i],0); // starts at 0x3E00
    700          		}
    701          
    702          		for ( i = 0; i < 8; i++) {
    703          			Write_6131_1word(msg_block2[i],0); // starts at 0x3E08
    704          		}
    705          
    706          		for ( i = 0; i < 8; i++) {
    707          			Write_6131_1word(msg_block3[i],0); // starts at 0x3E10
    708          		}
    709          
    710          		for ( i = 0; i < 8; i++) {
    711          			Write_6131_1word(msg_block4[i],0); // starts at 0x3E18
    712          		}
    713          
    714          		for ( i = 0; i < 8; i++) {
    715          			Write_6131_1word(msg_block5[i],0); // starts at 0x3E20
    716          		}
    717          
    718          		for ( i = 0; i < 8; i++) {
    719          			Write_6131_1word(msg_block6[i],0); // starts at 0x3E28
    720          		}
    721          
    722          		for ( i = 0; i < 8; i++) {
    723          			Write_6131_1word(msg_block7[i],0); // starts at 0x3E30
    724          		}
    725          
    726          		for ( i = 0; i < 8; i++) {
    727          			Write_6131_1word(msg_block8[i],0); // starts at 0x3E38
    728          		}
    729          
    730          		// these RT-RT blocks need 16 words, must start with low nibble = 0x0 
    731          		for ( i = 0; i < 16; i++) {
    732          			Write_6131_1word(rtrt_msg_block1[i],0); // starts at 0x3E40
    733          		}
    734          
    735          		for ( i = 0; i < 16; i++) {
    736          			Write_6131_1word(rtrt_msg_block2[i],0); // starts at 0x3E50
    737          		}
    738          
    739          		// write dummy data into the transmit data buffers for the 3 receive subaddress commands 
    740                          // REMEMBER: For Receive commands (that is RT receives), the BC IS TRANSMITTING...
    741          
    742          		// a 32-word buffer for rx msg block 3
    743          		Write_6131LowReg(MAP_1, msg_block3[2], 0);	
    744          		for ( i = 0; i < 32; i++) {	
    745          			Write_6131_1word(data[i], 1);
    746          		}
    747          
    748          		// a 32-word buffer for rx msg block 4 
    749          		Write_6131LowReg(MAP_1, msg_block4[2], 0);	
    750          		for ( i = 0; i < 32; i++) {	
    751          			Write_6131_1word(data[i], 1);
    752          		}
    753          
    754          		// a 32-word buffer for rx msg block 5
    755          		Write_6131LowReg(MAP_1, msg_block5[2], 0);	
    756          		for ( i = 0; i < 32; i++) {	
    757          			Write_6131_1word(data[31-i], 1);
    758          		}
    759          
    760          		// 16 mode data words for Rx MC16-MC31 starting at offset = 0x1B50 
    761          		Write_6131LowReg(MAP_1, 0x1B50, 1);	
    762          		for ( i = 1; i < 17; i++) {	
    763          			// writes 0x1616 for Rx MC16 thru 0x3131 for Rx MC31
    764          			Write_6131_1word(data[i+15],1);
    765          		}
    766                          
    767          	#endif	// end SPI 
    768          
    769          }	// end initialize_bc_msg_blocks(void)
   \                     ??initialize_bc_msg_blocks_27:
   \   00000226   40B0               ADD      SP,SP,#+256
   \   00000228   70BD               POP      {R4-R6,PC}       ;; return
    770          
    771          
    772          
    773          
    774          //	This function disables the Holt HI-613x BC by writing 
    775          //	the Master Configuration Register to reset the BCENA bit.
    776          //

   \                                 In section .text, align 2, keep-with-next
    777          void bc_disable(void) {
    778          	
    779                  // read-modify-write Master Config register
    780                    
    781                  #if (HOST_BUS_INTERFACE)
    782          	unsigned short j = (pH6130->MASTER_CONFIG_REG) & ~BCENA;
   \                     bc_disable:
   \   00000000   ....               LDR.N    R0,??DataTable10_5
   \   00000002   0068               LDR      R0,[R0, #+0]
   \   00000004   0088               LDRH     R0,[R0, #+0]
   \   00000006   10F46040           ANDS     R0,R0,#0xE000
    783          	pH6130->MASTER_CONFIG_REG = j;
   \   0000000A   ....               LDR.N    R1,??DataTable10_5
   \   0000000C   0968               LDR      R1,[R1, #+0]
   \   0000000E   0880               STRH     R0,[R1, #+0]
    784                      
    785                  #else // HOST SPI INTERFACE
    786                  unsigned short j = Read_6131LowReg(MASTER_CONFIG_REG, 1) & ~BCENA;
    787                  Write_6131LowReg(MASTER_CONFIG_REG, j, 1);
    788                  #endif
    789          
    790          }
   \   00000010   7047               BX       LR               ;; return
    791          
    792          
    793          
    794          // 	If the BCENA pin is high, this function enables the Holt 
    795          //	HI-613x BC by writing the Master Configuration Register 
    796          //	to set the BCENA bit. Then BC operation only begins after
    797          //	the BCSTART bit or BCTRIG pin gets a rising edge.
    798          //

   \                                 In section .text, align 2, keep-with-next
    799          void bc_enable(void) {
   \                     bc_enable:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   89B0               SUB      SP,SP,#+36
    800          		        
    801                  const Pin pinBCENA = PIN_BCENA;
   \   00000004   00A8               ADD      R0,SP,#+0
   \   00000006   ....               LDR.N    R1,??DataTable10_17
   \   00000008   2022               MOVS     R2,#+32
   \   0000000A   ........           BL       __aeabi_memcpy4
    802          
    803          	if(PIO_Get(&pinBCENA)) {
   \   0000000E   00A8               ADD      R0,SP,#+0
   \   00000010   ........           BL       PIO_Get
   \   00000014   0028               CMP      R0,#+0
   \   00000016   07D0               BEQ.N    ??bc_enable_0
    804                    
    805                      // read-modify-write Master Config register
    806                    
    807                      #if (HOST_BUS_INTERFACE)
    808          	    unsigned short j = (pH6130->MASTER_CONFIG_REG) | BCENA;
   \   00000018   ....               LDR.N    R0,??DataTable10_5
   \   0000001A   0068               LDR      R0,[R0, #+0]
   \   0000001C   0088               LDRH     R0,[R0, #+0]
   \   0000001E   50F48050           ORRS     R0,R0,#0x1000
    809          	    pH6130->MASTER_CONFIG_REG = j;
   \   00000022   ....               LDR.N    R1,??DataTable10_5
   \   00000024   0968               LDR      R1,[R1, #+0]
   \   00000026   0880               STRH     R0,[R1, #+0]
    810                      
    811                      #else // HOST SPI INTERFACE
    812                      unsigned short j = Read_6131LowReg(MASTER_CONFIG_REG, 1) | BCENA;
    813                      Write_6131LowReg(MASTER_CONFIG_REG, j, 1);
    814                      #endif
    815          	}
    816          }	// return enabled but not started 
   \                     ??bc_enable_0:
   \   00000028   09B0               ADD      SP,SP,#+36
   \   0000002A   00BD               POP      {PC}             ;; return
    817          
    818          
    819          
    820          // 	If the BCENA pin is high, this function enables and starts 
    821          //	the Holt HI-613x BC by writing the Master Configuration 
    822          //	Register to set the BCENA and BCSTART bits.
    823          //

   \                                 In section .text, align 2, keep-with-next
    824          void bc_start(void) {
   \                     bc_start:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   89B0               SUB      SP,SP,#+36
    825          	
    826                  const Pin pinBCENA = PIN_BCENA;
   \   00000004   00A8               ADD      R0,SP,#+0
   \   00000006   ....               LDR.N    R1,??DataTable10_18
   \   00000008   2022               MOVS     R2,#+32
   \   0000000A   ........           BL       __aeabi_memcpy4
    827          
    828          	if(PIO_Get(&pinBCENA)) {
   \   0000000E   00A8               ADD      R0,SP,#+0
   \   00000010   ........           BL       PIO_Get
   \   00000014   0028               CMP      R0,#+0
   \   00000016   07D0               BEQ.N    ??bc_start_0
    829                    
    830                      // read-modify-write Master Config register
    831                    
    832                      #if (HOST_BUS_INTERFACE)
    833                      unsigned short j = (pH6130->MASTER_CONFIG_REG) | BCENA | BCSTRT ;
   \   00000018   ....               LDR.N    R0,??DataTable10_5
   \   0000001A   0068               LDR      R0,[R0, #+0]
   \   0000001C   0088               LDRH     R0,[R0, #+0]
   \   0000001E   50F44050           ORRS     R0,R0,#0x3000
    834          	    pH6130->MASTER_CONFIG_REG = j;
   \   00000022   ....               LDR.N    R1,??DataTable10_5
   \   00000024   0968               LDR      R1,[R1, #+0]
   \   00000026   0880               STRH     R0,[R1, #+0]
    835                      
    836                      #else // HOST SPI INTERFACE
    837                      unsigned short j = Read_6131LowReg(MASTER_CONFIG_REG, 1) | BCENA | BCSTRT ;
    838                      Write_6131LowReg(MASTER_CONFIG_REG, j, 1);
    839                      #endif
    840          	}
    841          }	// return enabled and started 
   \                     ??bc_start_0:
   \   00000028   09B0               ADD      SP,SP,#+36
   \   0000002A   00BD               POP      {PC}             ;; return
    842          
    843          
    844          // This function generates a BC Trigger pulse for the HI-613x.
    845          //

   \                                 In section .text, align 2, keep-with-next
    846          void bc_trigger(void) {
   \                     bc_trigger:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   88B0               SUB      SP,SP,#+32
    847          	
    848              const Pin pinBCTRIG = PIN_BCTRIG;
   \   00000004   00A8               ADD      R0,SP,#+0
   \   00000006   ....               LDR.N    R1,??DataTable10_19
   \   00000008   2022               MOVS     R2,#+32
   \   0000000A   ........           BL       __aeabi_memcpy4
    849              char i = 2;
   \   0000000E   0224               MOVS     R4,#+2
    850              
    851              PIO_Set(&pinBCTRIG);        
   \   00000010   00A8               ADD      R0,SP,#+0
   \   00000012   ........           BL       PIO_Set
    852              while (i--);       
   \                     ??bc_trigger_0:
   \   00000016   2000               MOVS     R0,R4
   \   00000018   441E               SUBS     R4,R0,#+1
   \   0000001A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0028               CMP      R0,#+0
   \   0000001E   FAD1               BNE.N    ??bc_trigger_0
    853              PIO_Clear(&pinBCTRIG);
   \   00000020   00A8               ADD      R0,SP,#+0
   \   00000022   ........           BL       PIO_Clear
    854          }
   \   00000026   08B0               ADD      SP,SP,#+32
   \   00000028   10BD               POP      {R4,PC}          ;; return
    855          
    856          
    857          // part of infinite standby loop when CONSOLE_IO is disabled.
    858          // this function is used for demonstration for BC mode only...
    859          //

   \                                 In section .text, align 2, keep-with-next
    860          void bc_switch_tests(void) {
   \                     bc_switch_tests:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   89B0               SUB      SP,SP,#+36
    861          
    862              const Pin pinNSW1 = PIN_NSW1;
   \   00000004   00A8               ADD      R0,SP,#+0
   \   00000006   ....               LDR.N    R1,??DataTable10_20
   \   00000008   2022               MOVS     R2,#+32
   \   0000000A   ........           BL       __aeabi_memcpy4
    863              //const Pin pinNSW2 = PIN_NSW2;
    864          
    865              // eval board button SW1 generates BC Trigger pulse
    866              if(!PIO_Get(&pinNSW1))  SW1_BC_Trigger();
   \   0000000E   00A8               ADD      R0,SP,#+0
   \   00000010   ........           BL       PIO_Get
   \   00000014   0028               CMP      R0,#+0
   \   00000016   01D1               BNE.N    ??bc_switch_tests_0
   \   00000018   ........           BL       SW1_BC_Trigger
    867              
    868              // eval board button SW2 modifies BC Condition Code and GP Flag Register
    869              // NEXT STATEMENT IS DISABLED TO AVOID CONFLICT WITH USER BC PROGRAM
    870              /*  
    871              if(!PIO_Get(&pinNSW2))  SW2_BCtest();
    872              */
    873              
    874          }   // end bc_switch_tests()
   \                     ??bc_switch_tests_0:
   \   0000001C   09B0               ADD      SP,SP,#+36
   \   0000001E   00BD               POP      {PC}             ;; return
    875          
    876          
    877          
    878          // This function generates a BC Trigger pulse for the HI-613x
    879          // if button SW1 is pressed. Demo program uses this call in main()
    880          // if Console I/O is disabled. This triggers BC when a "wait for
    881          // trigger" op code has executed. Demo program interleaves 1553 
    882          // WTG op codes strictly for demonstration purposes).
    883          //

   \                                 In section .text, align 2, keep-with-next
    884          char SW1_BC_Trigger(void){
   \                     SW1_BC_Trigger:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   88B0               SUB      SP,SP,#+32
    885            
    886              const Pin pinNSW1 = PIN_NSW1;
   \   00000004   00A8               ADD      R0,SP,#+0
   \   00000006   ....               LDR.N    R1,??DataTable10_21
   \   00000008   2022               MOVS     R2,#+32
   \   0000000A   ........           BL       __aeabi_memcpy4
    887              unsigned short i=2000;
   \   0000000E   4FF4FA64           MOV      R4,#+2000
    888          
    889              if(!PIO_Get(&pinNSW1)) { 
   \   00000012   00A8               ADD      R0,SP,#+0
   \   00000014   ........           BL       PIO_Get
   \   00000018   0028               CMP      R0,#+0
   \   0000001A   1DD1               BNE.N    ??SW1_BC_Trigger_0
    890                   // button press
    891                   while(i){
   \                     ??SW1_BC_Trigger_1:
   \   0000001C   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000001E   002C               CMP      R4,#+0
   \   00000020   0FD0               BEQ.N    ??SW1_BC_Trigger_2
    892                      // wait for release
    893                      while(!PIO_Get(&pinNSW1));
   \                     ??SW1_BC_Trigger_3:
   \   00000022   00A8               ADD      R0,SP,#+0
   \   00000024   ........           BL       PIO_Get
   \   00000028   0028               CMP      R0,#+0
   \   0000002A   FAD0               BEQ.N    ??SW1_BC_Trigger_3
    894          
    895                      // if switch bounce, reload
    896                      if(!PIO_Get(&pinNSW1)) i=2000;
   \   0000002C   00A8               ADD      R0,SP,#+0
   \   0000002E   ........           BL       PIO_Get
   \   00000032   0028               CMP      R0,#+0
   \   00000034   03D1               BNE.N    ??SW1_BC_Trigger_4
   \   00000036   4FF4FA60           MOV      R0,#+2000
   \   0000003A   0400               MOVS     R4,R0
   \   0000003C   EEE7               B.N      ??SW1_BC_Trigger_1
    897                      // otherwise dec debounce delay
    898                      else i--;         
   \                     ??SW1_BC_Trigger_4:
   \   0000003E   641E               SUBS     R4,R4,#+1
   \   00000040   ECE7               B.N      ??SW1_BC_Trigger_1
    899                   }
    900                   // trigger BC after debounce, minimize switch bounce retrigger
    901                   bc_trigger();
   \                     ??SW1_BC_Trigger_2:
   \   00000042   ........           BL       bc_trigger
    902                   
    903                   // read STATUS_AND_RESET_REG to verfy "BC msg in progress" bit, 0x0200. 
    904                   // To see BCMIP state, set a breakpoint at "return 1" line below.
    905                   #if (HOST_BUS_INTERFACE)         
    906                       i = pH6130->STATUS_AND_RESET_REG;              
   \   00000046   ....               LDR.N    R0,??DataTable10_5
   \   00000048   0068               LDR      R0,[R0, #+0]
   \   0000004A   4088               LDRH     R0,[R0, #+2]
   \   0000004C   0400               MOVS     R4,R0
    907                   #else // HOST SPI INTERFACE
    908                       i = Read_6131LowReg(STATUS_AND_RESET_REG, 1);
    909                   #endif
    910          
    911                  i &= BCMIP;
   \   0000004E   4FF40070           MOV      R0,#+512
   \   00000052   0440               ANDS     R4,R0,R4
    912                         
    913                   return 1;
   \   00000054   0120               MOVS     R0,#+1
   \   00000056   00E0               B.N      ??SW1_BC_Trigger_5
    914              }
    915              else return 0;
   \                     ??SW1_BC_Trigger_0:
   \   00000058   0020               MOVS     R0,#+0
   \                     ??SW1_BC_Trigger_5:
   \   0000005A   08B0               ADD      SP,SP,#+32
   \   0000005C   10BD               POP      {R4,PC}          ;; return
    916          }
    917                  
    918          
    919          //
    920          // brief  For some BC tests, this function is called from main() standby loop 
    921          //	  when user presses button SW2.	First press after reset, the BC Cond
    922          //        Code and GP Flag Register is written so GP Flag bits 7-0 = 0x01.
    923          //        On subsequent presses, the set bit rotates left, i.e.,0x02, 0x04,
    924          //	  0x08, 0x10, 0x20, 0x40, 0x80 then next press starts over at 0x01.
    925          // 		  
    926          //	  primary purpose: testing the condition codes GP0-GP7 and nGP0-nGP7
    927           

   \                                 In section .text, align 2, keep-with-next
    928          void SW2_BCtest(void) {
   \                     SW2_BCtest:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   89B0               SUB      SP,SP,#+36
    929          
    930                  const Pin pinNSW2 = PIN_NSW2;
   \   00000004   00A8               ADD      R0,SP,#+0
   \   00000006   ....               LDR.N    R1,??DataTable10_22
   \   00000008   2022               MOVS     R2,#+32
   \   0000000A   ........           BL       __aeabi_memcpy4
    931          	static unsigned short press = 128;
    932          
    933          	// SW2 was pressed before this function call 
    934          	// turn on green LED 
    935                  AT91C_BASE_PIOA->PIO_CODR = nLEDG;
   \   0000000E   ....               LDR.N    R0,??DataTable10_23  ;; 0x400e0c34
   \   00000010   5FF00051           MOVS     R1,#+536870912
   \   00000014   0160               STR      R1,[R0, #+0]
    936          
    937          	// wait for button release
    938                  while(PIO_Get(&pinNSW2)) ;
   \                     ??SW2_BCtest_0:
   \   00000016   00A8               ADD      R0,SP,#+0
   \   00000018   ........           BL       PIO_Get
   \   0000001C   0028               CMP      R0,#+0
   \   0000001E   FAD1               BNE.N    ??SW2_BCtest_0
    939          
    940          	press = press << 1;
   \   00000020   ....               LDR.N    R0,??DataTable10_24
   \   00000022   0088               LDRH     R0,[R0, #+0]
   \   00000024   4000               LSLS     R0,R0,#+1
   \   00000026   ....               LDR.N    R1,??DataTable10_24
   \   00000028   0880               STRH     R0,[R1, #+0]
    941          	if(press == 256) press = 1;
   \   0000002A   ....               LDR.N    R0,??DataTable10_24
   \   0000002C   0088               LDRH     R0,[R0, #+0]
   \   0000002E   4FF48071           MOV      R1,#+256
   \   00000032   8842               CMP      R0,R1
   \   00000034   02D1               BNE.N    ??SW2_BCtest_1
   \   00000036   ....               LDR.N    R0,??DataTable10_24
   \   00000038   0121               MOVS     R1,#+1
   \   0000003A   0180               STRH     R1,[R0, #+0]
    942                  
    943                  #if (HOST_BUS_INTERFACE)
    944                      // reset all GP Flag bits by writing the 8 clear bits
    945                      pH6130->BC_CCODE_AND_GPF_REG = 0xFF00;
   \                     ??SW2_BCtest_1:
   \   0000003C   ....               LDR.N    R0,??DataTable10_5
   \   0000003E   0068               LDR      R0,[R0, #+0]
   \   00000040   4FF47F41           MOV      R1,#+65280
   \   00000044   A0F86E10           STRH     R1,[R0, #+110]
    946                      // set the GP Flag bits to match variable "press" by writing set bits
    947                      pH6130->BC_CCODE_AND_GPF_REG = press;            
   \   00000048   ....               LDR.N    R0,??DataTable10_5
   \   0000004A   0068               LDR      R0,[R0, #+0]
   \   0000004C   ....               LDR.N    R1,??DataTable10_24
   \   0000004E   0988               LDRH     R1,[R1, #+0]
   \   00000050   A0F86E10           STRH     R1,[R0, #+110]
    948                  #else // HOST SPI INTERFACE
    949          	    // no fast access reads for this register (must use MAP), 
    950                      // but the fast access register writes below are okay...
    951                      // reset all GP Flag bits by writing the 8 clear bits
    952                      Write_6131LowReg(BC_CCODE_AND_GPF_REG, 0xFF00, 1);
    953                      // set the GP Flag bits to match variable "press" by writing set bits
    954          	    Write_6131LowReg(BC_CCODE_AND_GPF_REG, press, 1);
    955                  #endif 
    956          
    957          	// debounce delay then turn off green LED
    958          	Delay_x100ms(4);
   \   00000054   0420               MOVS     R0,#+4
   \   00000056   ........           BL       Delay_x100ms
    959                  AT91C_BASE_PIOA->PIO_SODR = nLEDG;
   \   0000005A   ....               LDR.N    R0,??DataTable10_25  ;; 0x400e0c30
   \   0000005C   5FF00051           MOVS     R1,#+536870912
   \   00000060   0160               STR      R1,[R0, #+0]
    960                  
    961          }   // end SW2_BCtest()
   \   00000062   09B0               ADD      SP,SP,#+36
   \   00000064   00BD               POP      {PC}             ;; return

   \                                 In section .data, align 2
   \                     ??press:
   \   00000000   8000               DC16 128
    962          
    963          
    964          
    965          // This function initializes the Holt HI-613x BC by writing configuration registers in the device. 
    966          // Only BC mode option bits are affected. The program has already initialized the common parameters
    967          // shared by the BC, RT1, RT2 and/or Bus Monitor.
    968           

   \                                 In section .text, align 2, keep-with-next
    969          void initialize_613x_BC(void) {
    970          	
    971          	#if (HOST_BUS_INTERFACE) 
    972                  
    973                          // HI-6130 uses host bus interface to initialize HI-6130 registers and RAM tables
    974                  
    975              	        pH6130->BC_CONFIG_REG = BCTO_138U|BCGTE|ETTSYN|TTSYNEN|BCRME|BCRE;//|BSYNDV|MENDV|RESBS|CHKCWFMT|BCGCE|BC2RE|BCR1A|BCR2A;
   \                     initialize_613x_BC:
   \   00000000   ....               LDR.N    R0,??DataTable10_5
   \   00000002   0068               LDR      R0,[R0, #+0]
   \   00000004   4DF22D01           MOVW     R1,#+53293
   \   00000008   A0F86410           STRH     R1,[R0, #+100]
    976          		//pH6130->BC_INST_LIST_BASE_ADDR_REG = OP_START_ADDR;
    977          		//pH6130->BC_GP_QUEUE_POINTER = 0x00C0;  // default (64 locations)
    978          		pH6130->BC_INT_ENABLE_REG = BCWDT|SELMSG|BCGPQ|BCRETRY|CSTKERR|BCTRAP|STATSET|BCIRQMASK|BCMERR|BCEOM;
   \   0000000C   ....               LDR.N    R0,??DataTable10_5
   \   0000000E   0068               LDR      R0,[R0, #+0]
   \   00000010   4FF6F871           MOVW     R1,#+65528
   \   00000014   0184               STRH     R1,[R0, #+32]
    979          		pH6130->BC_INT_OUTPUT_ENABLE_REG = BCWDT|SELMSG|BCGPQ|BCRETRY|CSTKERR|STATSET|BCIRQMASK|BCMERR|BCEOM; //|BCTRAP
   \   00000016   ....               LDR.N    R0,??DataTable10_5
   \   00000018   0068               LDR      R0,[R0, #+0]
   \   0000001A   4FF6F831           MOVW     R1,#+64504
   \   0000001E   0185               STRH     R1,[R0, #+40]
    980                          
    981                  #else // (!HOST_BUS_INTERFACE) = HOST_SPI_INTERFACE
    982          
    983          		// HI-6131 uses host SPI interface to initialize registers and RAM.
    984          		// The SPI can directly read registers 0-15 decimal, without using the mem address pointer.
    985          		// The SPI can directly write registers 0-63 decimal, without using the mem address pointer.
    986          		// For addresses > 63, all read/write accesses must use a memory address pointer. 
    987          
    988          		unsigned short j = BCTO_138U|BCGTE|ETTSYN|TTSYNEN|BCRME|BCRE;//|BSYNDV|MENDV|RESBS|CHKCWFMT|BCGCE|BC2RE|BCR1A|BCR2A;
    989                          Write_6131LowReg(BC_CONFIG_REG, j, 0);
    990          		//Write_6131LowReg(BC_INST_LIST_BASE_ADDR_REG,OP_START_ADDR,0); 
    991          		//Write_6131LowReg(BC_GP_QUEUE_POINTER, 0x00C0, 0);  // default (64 locations)
    992                          j = BCWDT|SELMSG|BCGPQ|BCRETRY|CSTKERR|BCTRAP|STATSET|BCIRQMASK|BCMERR|BCEOM;
    993          		Write_6131LowReg(BC_INT_ENABLE_REG, j, 0);
    994                          j = BCWDT|SELMSG|BCGPQ|BCRETRY|CSTKERR|STATSET|BCIRQMASK|BCMERR|BCEOM; //|BCTRAP
    995          		Write_6131LowReg(BC_INT_OUTPUT_ENABLE_REG, j, 0);
    996          	#endif
    997          
    998          }	// end initialize_613x_BC()
   \   00000020   7047               BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   ........           DC32     pGPQ

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   ........           DC32     pBCil

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   ........           DC32     pBCstack

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   ........           DC32     pBCstack2RT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   ........           DC32     `?<Constant {20495, 0, 1039, 15872, 20495, 0, 1`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   ........           DC32     pH6130

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   ........           DC32     `?<Constant {257, 514, 771, 1028, 1285, 1542, 1`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   ........           DC32     `?<Constant {16768, 8128, 21256, 512, 43981, 43`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   ........           DC32     `?<Constant {16640, 8128, 21256, 512, 43981, 43`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   ........           DC32     `?<Constant {16544, 7104, 21288, 700, 43981, 43`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   ........           DC32     `?<Constant {16418, 63531, 21320, 819, 43981, 4`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \   00000000   ........           DC32     `?<Constant {16546, 64448, 21352, 0, 43981, 439`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_12:
   \   00000000   ........           DC32     `?<Constant {16420, 8162, 57005, 0, 43981, 4398`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_13:
   \   00000000   ........           DC32     `?<Constant {16548, 8178, 7010, 0, 43981, 43981`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_14:
   \   00000000   ........           DC32     `?<Constant {49188, 7157, 6997, 0, 43981, 43981`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_15:
   \   00000000   ........           DC32     `?<Constant {16545, 9154, 21384, 0, 43981, 4398`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_16:
   \   00000000   ........           DC32     `?<Constant {16419, 64459, 21416, 0, 43981, 439`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_17:
   \   00000000   ........           DC32     `?<Constant {268435456, (AT91S_PIO *)1074663424`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_18:
   \   00000000   ........           DC32     `?<Constant {268435456, (AT91S_PIO *)1074663424_1`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_19:
   \   00000000   ........           DC32     `?<Constant {536870912, (AT91S_PIO *)1074663424`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_20:
   \   00000000   ........           DC32     `?<Constant {131072, (AT91S_PIO *)1074662912, 1`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_21:
   \   00000000   ........           DC32     `?<Constant {131072, (AT91S_PIO *)1074662912, 1_1`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_22:
   \   00000000   ........           DC32     `?<Constant {262144, (AT91S_PIO *)1074662912, 1`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_23:
   \   00000000   340C0E40           DC32     0x400e0c34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_24:
   \   00000000   ........           DC32     ??press

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_25:
   \   00000000   300C0E40           DC32     0x400e0c30

   \                                 In section .rodata, align 4
   \                     `?<Constant {20495, 0, 1039, 15872, 20495, 0, 1`:
   \   00000000   0F5000000F04       DC16 20495, 0, 1039, 15872, 20495, 0, 1039, 15880, 20495, 0, 1039
   \              003E0F500000
   \              0F04083E0F50
   \              00000F04    
   \   00000016   103E0F500000       DC16 15888, 20495, 0, 1039, 15896, 20495, 0, 1039, 15904, 20495, 0
   \              0F04183E0F50
   \              00000F04203E
   \              0F500000    
   \   0000002C   0F04283E0F50       DC16 1039, 15912, 20495, 0, 1039, 15920, 20495, 0, 1039, 15928, 20495
   \              00000F04303E
   \              0F5000000F04
   \              383E0F50    
   \   00000042   00000F04403E       DC16 0, 1039, 15936, 20495, 0, 1039, 15952, 20495, 0, 1039, 15880, 2063
   \              0F5000000F04
   \              503E0F500000
   \              0F04083E0F08
   \   0000005A   701B               DC16 7024

   \                                 In section .rodata, align 4
   \                     `?<Constant {257, 514, 771, 1028, 1285, 1542, 1`:
   \   00000000   010102020303       DC16 257, 514, 771, 1028, 1285, 1542, 1799, 2056, 2313, 4112, 4369
   \              040405050606
   \              070708080909
   \              10101111    
   \   00000016   121213131414       DC16 4626, 4883, 5140, 5397, 5654, 5911, 6168, 6425, 8224, 8481, 8738
   \              151516161717
   \              181819192020
   \              21212222    
   \   0000002C   232324242525       DC16 8995, 9252, 9509, 9766, 10023, 10280, 10537, 12336, 12593, 12850
   \              262627272828
   \              292930303131
   \              3232        

   \                                 In section .rodata, align 4
   \                     `?<Constant {16768, 8128, 21256, 512, 43981, 43`:
   \   00000000   8041C01F0853       DC16 16768, 8128, 21256, 512, 43981, 43981, 43981, 43981
   \              0002CDABCDAB
   \              CDABCDAB    

   \                                 In section .rodata, align 4
   \                     `?<Constant {16640, 8128, 21256, 512, 43981, 43`:
   \   00000000   0041C01F0853       DC16 16640, 8128, 21256, 512, 43981, 43981, 43981, 43981
   \              0002CDABCDAB
   \              CDABCDAB    

   \                                 In section .rodata, align 4
   \                     `?<Constant {16544, 7104, 21288, 700, 43981, 43`:
   \   00000000   A040C01B2853       DC16 16544, 7104, 21288, 700, 43981, 43981, 43981, 43981
   \              BC02CDABCDAB
   \              CDABCDAB    

   \                                 In section .rodata, align 4
   \                     `?<Constant {16418, 63531, 21320, 819, 43981, 4`:
   \   00000000   22402BF84853       DC16 16418, 63531, 21320, 819, 43981, 43981, 43981, 43981
   \              3303CDABCDAB
   \              CDABCDAB    

   \                                 In section .rodata, align 4
   \                     `?<Constant {16546, 64448, 21352, 0, 43981, 439`:
   \   00000000   A240C0FB6853       DC16 16546, 64448, 21352, 0, 43981, 43981, 43981, 43981
   \              0000CDABCDAB
   \              CDABCDAB    

   \                                 In section .rodata, align 4
   \                     `?<Constant {16420, 8162, 57005, 0, 43981, 4398`:
   \   00000000   2440E21FADDE       DC16 16420, 8162, 57005, 0, 43981, 43981, 43981, 43981
   \              0000CDABCDAB
   \              CDABCDAB    

   \                                 In section .rodata, align 4
   \                     `?<Constant {16548, 8178, 7010, 0, 43981, 43981`:
   \   00000000   A440F21F621B       DC16 16548, 8178, 7010, 0, 43981, 43981, 43981, 43981
   \              0000CDABCDAB
   \              CDABCDAB    

   \                                 In section .rodata, align 4
   \                     `?<Constant {49188, 7157, 6997, 0, 43981, 43981`:
   \   00000000   24C0F51B551B       DC16 49188, 7157, 6997, 0, 43981, 43981, 43981, 43981
   \              0000CDABCDAB
   \              CDABCDAB    

   \                                 In section .rodata, align 4
   \                     `?<Constant {16545, 9154, 21384, 0, 43981, 4398`:
   \   00000000   A140C2238853       DC16 16545, 9154, 21384, 0, 43981, 43981, 43981, 43981, 7202, 0, 57005
   \              0000CDABCDAB
   \              CDABCDAB221C
   \              0000ADDE    
   \   00000016   ADDEADDEADDE       DC16 57005, 57005, 57005, 57005, 57005
   \              ADDEADDE    

   \                                 In section .rodata, align 4
   \                     `?<Constant {16419, 64459, 21416, 0, 43981, 439`:
   \   00000000   2340CBFBA853       DC16 16419, 64459, 21416, 0, 43981, 43981, 43981, 43981, 9259, 0, 57005
   \              0000CDABCDAB
   \              CDABCDAB2B24
   \              0000ADDE    
   \   00000016   ADDEADDEADDE       DC16 57005, 57005, 57005, 57005, 57005
   \              ADDEADDE    

   \                                 In section .rodata, align 4
   \                     `?<Constant {268435456, (AT91S_PIO *)1074663424`:
   \   00000000   000000100010       DC32 268435456, 400E1000H
   \              0E40        
   \   00000008   0C0200000000       DC8 12, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \   0000001A   000000000000       DC8 0, 0, 0, 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant {268435456, (AT91S_PIO *)1074663424_1`:
   \   00000000   000000100010       DC32 268435456, 400E1000H
   \              0E40        
   \   00000008   0C0200000000       DC8 12, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \   0000001A   000000000000       DC8 0, 0, 0, 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant {536870912, (AT91S_PIO *)1074663424`:
   \   00000000   000000200010       DC32 536870912, 400E1000H
   \              0E40        
   \   00000008   0C0300000000       DC8 12, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   0000001B   0000000000         DC8 0, 0, 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant {131072, (AT91S_PIO *)1074662912, 1`:
   \   00000000   00000200000E       DC32 131072, 400E0E00H
   \              0E40        
   \   00000008   0B0202000000       DC8 11, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   0000001B   0000000000         DC8 0, 0, 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant {131072, (AT91S_PIO *)1074662912, 1_1`:
   \   00000000   00000200000E       DC32 131072, 400E0E00H
   \              0E40        
   \   00000008   0B0202000000       DC8 11, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   0000001B   0000000000         DC8 0, 0, 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant {262144, (AT91S_PIO *)1074662912, 1`:
   \   00000000   00000400000E       DC32 262144, 400E0E00H
   \              0E40        
   \   00000008   0B0202000000       DC8 11, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   0000001B   0000000000         DC8 0, 0, 0, 0, 0
    999          
   1000          
   1001          
   1002          
   1003          // end of file 
   1004          

   Maximum stack usage in bytes:

     Function                       .cstack
     --------                       -------
     BC_bus_addressing_examples          0
     SW1_BC_Trigger                     40
     SW2_BCtest                         40
     bc_disable                          0
     bc_enable                          40
     bc_start                           40
     bc_switch_tests                    40
     bc_trigger                         40
     initialize_613x_BC                  0
     initialize_bc_instruction_list    116
     initialize_bc_msg_blocks          272


   Section sizes:

     Function/Label                                   Bytes
     --------------                                   -----
     BC_bus_addressing_examples                        362
     initialize_bc_instruction_list                    168
     initialize_bc_msg_blocks                          554
     bc_disable                                         18
     bc_enable                                          44
     bc_start                                           44
     bc_trigger                                         42
     bc_switch_tests                                    32
     SW1_BC_Trigger                                     94
     SW2_BCtest                                        102
     press                                               2
     initialize_613x_BC                                 34
     ??DataTable10                                       4
     ??DataTable10_1                                     4
     ??DataTable10_2                                     4
     ??DataTable10_3                                     4
     ??DataTable10_4                                     4
     ??DataTable10_5                                     4
     ??DataTable10_6                                     4
     ??DataTable10_7                                     4
     ??DataTable10_8                                     4
     ??DataTable10_9                                     4
     ??DataTable10_10                                    4
     ??DataTable10_11                                    4
     ??DataTable10_12                                    4
     ??DataTable10_13                                    4
     ??DataTable10_14                                    4
     ??DataTable10_15                                    4
     ??DataTable10_16                                    4
     ??DataTable10_17                                    4
     ??DataTable10_18                                    4
     ??DataTable10_19                                    4
     ??DataTable10_20                                    4
     ??DataTable10_21                                    4
     ??DataTable10_22                                    4
     ??DataTable10_23                                    4
     ??DataTable10_24                                    4
     ??DataTable10_25                                    4
     ?<Constant {20495, 0, 1039, 15872, 20495, 0, 1     92
     ?<Constant {257, 514, 771, 1028, 1285, 1542, 1     64
     ?<Constant {16768, 8128, 21256, 512, 43981, 43     16
     ?<Constant {16640, 8128, 21256, 512, 43981, 43     16
     ?<Constant {16544, 7104, 21288, 700, 43981, 43     16
     ?<Constant {16418, 63531, 21320, 819, 43981, 4     16
     ?<Constant {16546, 64448, 21352, 0, 43981, 439     16
     ?<Constant {16420, 8162, 57005, 0, 43981, 4398     16
     ?<Constant {16548, 8178, 7010, 0, 43981, 43981     16
     ?<Constant {49188, 7157, 6997, 0, 43981, 43981     16
     ?<Constant {16545, 9154, 21384, 0, 43981, 4398     32
     ?<Constant {16419, 64459, 21416, 0, 43981, 439     32
     ?<Constant {268435456, (AT91S_PIO *)1074663424     32
     ?<Constant {268435456, (AT91S_PIO *)1074663424_1   32
     ?<Constant {536870912, (AT91S_PIO *)1074663424     32
     ?<Constant {131072, (AT91S_PIO *)1074662912, 1     32
     ?<Constant {131072, (AT91S_PIO *)1074662912, 1_1   32
     ?<Constant {262144, (AT91S_PIO *)1074662912, 1     32

 
     2 bytes in section .data
   540 bytes in section .rodata
 1 598 bytes in section .text
 
 1 598 bytes of CODE  memory
   540 bytes of CONST memory
     2 bytes of DATA  memory

Errors: none
Warnings: none
