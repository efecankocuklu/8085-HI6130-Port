###############################################################################
#                                                                             #
#                                                       18/Jun/2012  10:27:50 #
# IAR ANSI C/C++ Compiler V6.21.1.32794/W32 KICKSTART for ARM                 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Program Files\IAR Systems\Embedded Workbench 6.0      #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\board_613x.c                     #
#    Command line =  "C:\Program Files\IAR Systems\Embedded Workbench 6.0     #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\board_613x.c" -D at91sam3u4 -D   #
#                    flash -D TRACE_LEVEL=4 -D BC_ena=0 -D RT2_ena=0 -D       #
#                    RT1_ena=0 -D SMT_ena=1 -D IMT_ena=0 -lC "C:\Program      #
#                    Files\IAR Systems\Embedded Workbench 6.0                 #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\ewp\SMT_ONLY\List\" --remarks    #
#                    --diag_suppress Pe826,Pe1375,Pe068 -o "C:\Program        #
#                    Files\IAR Systems\Embedded Workbench 6.0                 #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\ewp\SMT_ONLY\Obj\" --no_cse      #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench 6.0                 #
#                    Kickstart_2\arm\INC\c\DLib_Config_Full.h" -I             #
#                    "C:\Program Files\IAR Systems\Embedded Workbench 6.0     #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\ewp\..\..\..\at91lib/peripherals #
#                    \" -I "C:\Program Files\IAR Systems\Embedded Workbench   #
#                    6.0 Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt    #
#                    HI-6130-40 EBI Demo 2_0\ewp\..\..\..\at91lib/components\ #
#                    " -I "C:\Program Files\IAR Systems\Embedded Workbench    #
#                    6.0 Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt    #
#                    HI-6130-40 EBI Demo 2_0\ewp\..\..\..\at91lib\" -I        #
#                    "C:\Program Files\IAR Systems\Embedded Workbench 6.0     #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\ewp\..\..\..\external_libs\" -I  #
#                    "C:\Program Files\IAR Systems\Embedded Workbench 6.0     #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\ewp\..\..\..\at91lib/boards/at91 #
#                    sam3u-ek\" --cpu_mode thumb -On --use_c++_inline         #
#    List file    =  C:\Program Files\IAR Systems\Embedded Workbench 6.0      #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\ewp\SMT_ONLY\List\board_613x.lst #
#    Object file  =  C:\Program Files\IAR Systems\Embedded Workbench 6.0      #
#                    Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt        #
#                    HI-6130-40 EBI Demo 2_0\ewp\SMT_ONLY\Obj\board_613x.o    #
#                                                                             #
#                                                                             #
###############################################################################

C:\Program Files\IAR Systems\Embedded Workbench 6.0 Kickstart_2\arm\examples\Atmel\at91sam3u-ek\_Holt HI-6130-40 EBI Demo 2_0\board_613x.c
      1          /* ----------------------------------------------------------------------------
      2           *                            HOLT Integrated Circuits 
      3           * ----------------------------------------------------------------------------
      4           *
      5           *    file	board_613x.c
      6           *    brief     This file contains functions applicable to all terminal modes
      7           *              (BC, RT, SMT, IMT) in both Holt HI-6130 and HI-6131 projects.  
      8           *
      9           *		IMPORTANT: Edit file 613x_initialization.h to define either:
     10           *
     11           *		HOST_BUS_INTERFACE  YES  sets compilation for HI-6130 (bus)
     12           *		 		    NO   sets compilation for HI-6131 (SPI)
     13           *
     14           *		Most functional procedures in this project are written for
     15           *		both parallel bus or SPI host interface schemes, this runtime 
     16           *		switch determines which are procedures are compiled.
     17           *
     18           *              IMPORTANT: Because register addressing differs for Bus and 
     19           *              SPI interface, files "device_6130.h" and "device_6131.h" 
     20           *              contain the definitions needed for register addressing.
     21           *
     22           *	   	HOLT DISCLAIMER
     23           *      	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY 
     24           *      	KIND, EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE 
     25           *      	WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
     26           *      	PURPOSE AND NONINFRINGEMENT. 
     27           *      	IN NO EVENT SHALL HOLT, INC BE LIABLE FOR ANY CLAIM, DAMAGES
     28           *      	OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
     29           *      	OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
     30           *      	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
     31           *
     32           *              Copyright (C) 2009-2011 by  HOLT, Inc.
     33           *              All Rights Reserved
     34           */
     35          
     36          
     37          // standard Atmel/IAR headers
     38          #include <pio/pio.h>
     39          #include <pmc/pmc.h>
     40          #include <intrinsics.h>
     41          
     42          // Holt project headers
     43          #include "board_613x.h"
     44          #include "613x_regs.h"
     45          #include "613x_initialization.h"
     46                             
     47          #include "device_6130.h"
     48          #include "board_6130.h"
     49          extern const H6130 pH6130;
     50          
     51          #if(CONSOLE_IO)
     52          #include <stdio.h>
     53          #include "console.h"
     54          #endif
     55          
     56          
     57          //------------------------------------------------------------------------------
     58          /// Configure the PIO pins not used by ARM on-chip peripherals (USART, EBI, SPI).
     59          /// This configures output pins used for HI-6130 control, LEDs, etc. and input
     60          /// pins used for HI-6130 status, interrupts, DIP switches, pushbuttons, etc.
     61          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     62          void ConfigureGpio(void)
     63          {
   \                     ConfigureGpio:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   ADF5717D           SUB      SP,SP,#+964
     64                 const Pin pins[] = {
     65                 PINS_BUTTON, 
     66                 PINS_DIPSW,
     67                 PINS_6130STATUS,
     68                 PINS_LED,
     69                 PINS_6130CONTROL 
     70               };
   \   00000006   00A8               ADD      R0,SP,#+0
   \   00000008   ....               LDR.N    R1,??DataTable11
   \   0000000A   4FF47072           MOV      R2,#+960
   \   0000000E   ........           BL       __aeabi_memcpy4
     71               
     72              PIO_Configure(pins, PIO_LISTSIZE(pins));
   \   00000012   1E21               MOVS     R1,#+30
   \   00000014   00A8               ADD      R0,SP,#+0
   \   00000016   ........           BL       PIO_Configure
     73          }
   \   0000001A   0DF5717D           ADD      SP,SP,#+964
   \   0000001E   00BD               POP      {PC}             ;; return
     74          
     75          //------------------------------------------------------------------------------
     76          // This function generates an active low reset pulse for the HI-613x 
     77          //------------------------------------------------------------------------------
     78          // Return occurs when HI-613x READY output is asserted. If AUTOEN = 0, this 
     79          // occurs after chip init and RAM test. If AUTOEN = 1, auto-initialization from
     80          // the serial EEPROM adds additional time before READY assertion...

   \                                 In section .text, align 2, keep-with-next
     81          void reset_613x(void) {
   \                     reset_613x:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   88B0               SUB      SP,SP,#+32
     82            
     83              const Pin pinREADY = PIN_READY;  
   \   00000004   00A8               ADD      R0,SP,#+0
   \   00000006   ....               LDR.N    R1,??DataTable11_1
   \   00000008   2022               MOVS     R2,#+32
   \   0000000A   ........           BL       __aeabi_memcpy4
     84              char i = 1;
   \   0000000E   0124               MOVS     R4,#+1
     85              
     86              // active low pulse
     87              AT91C_BASE_PIOC->PIO_CODR = nMR;  
   \   00000010   ....               LDR.N    R0,??DataTable11_2  ;; 0x400e1034
   \   00000012   5FF00071           MOVS     R1,#+33554432
   \   00000016   0160               STR      R1,[R0, #+0]
     88              while (i--);       
   \                     ??reset_613x_0:
   \   00000018   2000               MOVS     R0,R4
   \   0000001A   441E               SUBS     R4,R0,#+1
   \   0000001C   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0028               CMP      R0,#+0
   \   00000020   FAD1               BNE.N    ??reset_613x_0
     89              AT91C_BASE_PIOC->PIO_SODR = nMR;  
   \   00000022   ....               LDR.N    R0,??DataTable11_3  ;; 0x400e1030
   \   00000024   5FF00071           MOVS     R1,#+33554432
   \   00000028   0160               STR      R1,[R0, #+0]
     90              
     91              // wait for HI-613x READY assertion, then return
     92              while (!PIO_Get(&pinREADY));		
   \                     ??reset_613x_1:
   \   0000002A   00A8               ADD      R0,SP,#+0
   \   0000002C   ........           BL       PIO_Get
   \   00000030   0028               CMP      R0,#+0
   \   00000032   FAD0               BEQ.N    ??reset_613x_1
     93          }
   \   00000034   08B0               ADD      SP,SP,#+32
   \   00000036   10BD               POP      {R4,PC}          ;; return
     94          
     95          //------------------------------------------------------------------------------
     96          // This function determines whether auto-initialization occurred to load the
     97          // HI-613x registers and RAM from serial EEPROM after Master Reset.
     98          //------------------------------------------------------------------------------
     99          //   *  If YES (auto-init occurred after reset) several error checks are performed. 
    100          //      If errors are found, no return to the calling function (local error trapping). 
    101          //      If error-free, function returns "0" to calling function.
    102          //   *  If NO (auto-init was not performed) function returns "1" to calling function.
    103          //
    104          //   no return (error trap) if auto-init was performed with errors
    105          //   otherwise returns a character:
    106          //	1 (no auto-init occurred after /MR) 
    107          //	0 (error-free auto-init was performed)
    108          //

   \                                 In section .text, align 2, keep-with-next
    109          char autoinit_check(void) {
   \                     autoinit_check:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   88B0               SUB      SP,SP,#+32
    110          
    111              const Pin pinAUTOEN = PIN_AUTOEN;
   \   00000004   00A8               ADD      R0,SP,#+0
   \   00000006   ....               LDR.N    R1,??DataTable11_4
   \   00000008   2022               MOVS     R2,#+32
   \   0000000A   ........           BL       __aeabi_memcpy4
    112              unsigned short int read_value;
    113          
    114              // did we auto-initialize after master reset? (check for AUTOEN pin assertion)
    115              if (!PIO_Get(&pinAUTOEN)) {
   \   0000000E   00A8               ADD      R0,SP,#+0
   \   00000010   ........           BL       PIO_Get
   \   00000014   0028               CMP      R0,#+0
   \   00000016   01D1               BNE.N    ??autoinit_check_0
    116                  // NO, auto-initialize DID NOT occur after master reset
    117          	return 1;
   \   00000018   0120               MOVS     R0,#+1
   \   0000001A   18E0               B.N      ??autoinit_check_1
    118              }
    119          
    120              else {
    121          	// YES, auto-initialize DID occur after master reset
    122          	// check the Hardware Pending Int register for auto-initialization errors
    123          
    124          	read_value = pH6130->HDW_PENDING_INT_REG;
   \                     ??autoinit_check_0:
   \   0000001C   ....               LDR.N    R0,??DataTable11_5
   \   0000001E   0068               LDR      R0,[R0, #+0]
   \   00000020   8089               LDRH     R0,[R0, #+12]
   \   00000022   0400               MOVS     R4,R0
    125          
    126                      
    127          	// EEPROM checksum error? (EECKE bit high)
    128          	if (read_value & EECKE_INT) {
   \   00000024   6004               LSLS     R0,R4,#+17
   \   00000026   07D5               BPL.N    ??autoinit_check_2
    129          
    130          	    // yes, read EEPROM checksum (2's comp + 1) from register address 0x004E, which
    131                      // is also used for the serial EEPROM unlock function.
    132          	    // The value fetched is not used by this program, simply fetched for convenience.
    133          			 
    134          	    read_value = pH6130->EEPROM_UNLOCK_REG;
   \   00000028   ....               LDR.N    R0,??DataTable11_5
   \   0000002A   0068               LDR      R0,[R0, #+0]
   \   0000002C   B0F89C00           LDRH     R0,[R0, #+156]
   \   00000030   0400               MOVS     R4,R0
    135          
    136          
    137                      // error trap during development: 
    138          	    // a repeating 4-blink red LED means EEPROM Checksum Mismatch
    139                      error_trap(4);
   \   00000032   0420               MOVS     R0,#+4
   \   00000034   ........           BL       error_trap
    140                  }   // end: EEPROM checksum error
    141          
    142          	// data mismatch error? (data written to device reads back differently)
    143          	if (read_value & RAMIF_INT) {
   \                     ??autoinit_check_2:
   \   00000038   A004               LSLS     R0,R4,#+18
   \   0000003A   07D5               BPL.N    ??autoinit_check_3
    144          
    145          	    // yes, fetch address of first-occurring EEPROM reg/RAM mismatch from reg 0x0024.
    146                      // The primary funcion of this register is the RT2 Message Info Word Address.
    147          	    // The value fetched is not used by this program, simply fetched for convenience.
    148          
    149          
    150          		read_value = pH6130->RT2_MSG_INFO_WD_ADDR_REG;
   \   0000003C   ....               LDR.N    R0,??DataTable11_5
   \   0000003E   0068               LDR      R0,[R0, #+0]
   \   00000040   B0F84800           LDRH     R0,[R0, #+72]
   \   00000044   0400               MOVS     R4,R0
    151          
    152                      // error trap during development: repeating 3-blink red LED 
    153                      // indicates data mismatch error 
    154                      error_trap(3);
   \   00000046   0320               MOVS     R0,#+3
   \   00000048   ........           BL       error_trap
    155                  }   // end: data mismatch error
    156          
    157                  #if(RT1_ena || RT2_ena)
    158                      // RT address parity error for either RT1 or RT2 Pending
    159                      // interrupt is only generated if RT is enabled, i.e., pin RTxENA = 1
    160          	    if (read_value & (RT1APF|RT2APF)) {
    161                          // delay 800ms
    162          		Delay_x100ms(8);
    163          		// error trap during development: repeating 2-blink red LED
    164          		// indicates RT address parity error
    165          		error_trap(2);
    166                      }   // end: RT1 or RT2 address parity error
    167          	
    168                    #endif
    169          
    170          	  return 0;
   \                     ??autoinit_check_3:
   \   0000004C   0020               MOVS     R0,#+0
   \                     ??autoinit_check_1:
   \   0000004E   08B0               ADD      SP,SP,#+32
   \   00000050   10BD               POP      {R4,PC}          ;; return
    171                  
    172              }	// end: auto-initialization DID occur after master reset
    173          }	// end: autoinit_check()
    174          
    175          
    176          //----------------------------------------------------------------------------------------
    177          // This function initializes parameters	shared by HI-613x BC, RT1, RT2 and/or Bus Monitor.
    178          //----------------------------------------------------------------------------------------
    179          // the initialized parameters are time tag setup, hardware interrupts, etc
    180          //     THIS FUNCTION SHOULD BE CALLED BEFORE CALLING 
    181          //     THE BC, RT1, RT2 AND/OR BUS MONITOR INIT FUNCTIONS
    182          

   \                                 In section .text, align 2, keep-with-next
    183          void initialize_613x_shared(void) {
    184          
    185          		// Select common configuration options that apply to all
    186          		// BC,MT,RT1,RT2. Terminal-specific options are initialized 
    187          		// elsewhere. The following options may be selected here:
    188                          //   TXINHA = Tx inhibit bus A
    189                          //   TXINHB = Tx inhibit bus B
    190                          //   SSR8 = single strobe read if 8-bit wide bus 
    191                          //   (PULSE_INT or LEVEL_INT) select interrupt type
    192            
    193                          pH6130->MASTER_CONFIG_REG |= PULSE_INT; // |TXINHA|TXINHB;
   \                     initialize_613x_shared:
   \   00000000   ....               LDR.N    R0,??DataTable11_5
   \   00000002   0068               LDR      R0,[R0, #+0]
   \   00000004   ....               LDR.N    R1,??DataTable11_5
   \   00000006   0968               LDR      R1,[R1, #+0]
   \   00000008   0988               LDRH     R1,[R1, #+0]
   \   0000000A   0180               STRH     R1,[R0, #+0]
    194          
    195          		// enable these hardware interrupts: 
    196                          // EEPROM checksum error
    197                          // auto-init RAM init fail (mismatches EEPROM)
    198                          // bus A and bus B loopback failures
    199          	        pH6130->HDW_INT_ENABLE_REG = EECKE_INT|RAMIF_INT|LBFA|LBFB;           
   \   0000000C   ....               LDR.N    R0,??DataTable11_5
   \   0000000E   0068               LDR      R0,[R0, #+0]
   \   00000010   4FF4F041           MOV      R1,#+30720
   \   00000014   C183               STRH     R1,[R0, #+30]
    200          }	// end: initialize_613x_shared()
   \   00000016   7047               BX       LR               ;; return
    201          
    202          
    203          //------------------------------------------------------------------------------
    204          // This function initializes Timer Counter 0 (TC0) for use in delay calls.
    205          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    206          void init_timer(void) {
   \                     init_timer:
   \   00000000   10B5               PUSH     {R4,LR}
    207              
    208              unsigned int i;
    209              
    210              // Enable TC0 peripheral clock
    211              PMC_EnablePeripheral(AT91C_ID_TC0);
   \   00000002   1620               MOVS     R0,#+22
   \   00000004   ........           BL       PMC_EnablePeripheral
    212          
    213              // INITIALIZE TIMER-COUNTER 0 FOR POLLED RC COMPARE OPERATION
    214              // ----------------------------------------------------------
    215              // Disable timer-counter clock and interrupts
    216              AT91C_BASE_TC0->TC_CCR = AT91C_TC_CLKDIS;
   \   00000008   ....               LDR.N    R0,??DataTable11_6  ;; 0x40080000
   \   0000000A   0221               MOVS     R1,#+2
   \   0000000C   0160               STR      R1,[R0, #+0]
    217              AT91C_BASE_TC0->TC_IDR = 0xFFFFFFFF;
   \   0000000E   ....               LDR.N    R0,??DataTable11_7  ;; 0x40080028
   \   00000010   5FF0FF31           MOVS     R1,#-1
   \   00000014   0160               STR      R1,[R0, #+0]
    218              
    219              // Clear timer0 status register by reading it
    220              i = AT91C_BASE_TC0->TC_SR;
   \   00000016   ....               LDR.N    R0,??DataTable11_8  ;; 0x40080020
   \   00000018   0068               LDR      R0,[R0, #+0]
   \   0000001A   0400               MOVS     R4,R0
    221              // suppress compiler warning: variable "i" was set, never used
    222              i = i;
    223              
    224              // Set Timer Counter mode. In TC_CMR, set the WAVE bit for waveform
    225              // operating mode and set the CPCSTOP bit so Register C match stops the
    226              // timer clock. The AT91C_TC_CLKS_TIMER_DIVx_CLOCK field selects clock 
    227              // prescaler (MCLK div-by-N).  Other bits are reset...
    228              AT91C_BASE_TC0->TC_CMR = AT91C_TC_WAVE | AT91C_TC_CPCSTOP 
    229                                                     | AT91C_TC_CLKS_TIMER_DIV1_CLOCK; // for MCLK/2
   \   0000001C   ....               LDR.N    R0,??DataTable11_9  ;; 0x40080004
   \   0000001E   48F24001           MOVW     R1,#+32832
   \   00000022   0160               STR      R1,[R0, #+0]
    230              //                                     | AT91C_TC_CLKS_TIMER_DIV2_CLOCK; // for MCLK/8
    231              //                                     | AT91C_TC_CLKS_TIMER_DIV3_CLOCK; // for MCLK/32
    232              //                                     | AT91C_TC_CLKS_TIMER_DIV4_CLOCK; // for MCLK/128
    233              
    234              // Enable TC clock. Timer-counter will not start counting until triggered
    235              // outside this function
    236              AT91C_BASE_TC0->TC_CCR = AT91C_TC_CLKEN;
   \   00000024   ....               LDR.N    R0,??DataTable11_6  ;; 0x40080000
   \   00000026   0121               MOVS     R1,#+1
   \   00000028   0160               STR      R1,[R0, #+0]
    237              
    238              // No AIC interrupt initialization used for timer0, its status reg is polled.
    239              //
    240              // To modify to use a timer0 "RC compare" interrupt, add these steps:
    241              //IRQ_ConfigureIT(AT91C_ID_TC0, 0, TC0_IrqHandler); // identify int svc function
    242              //AT91C_BASE_TC0->TC_IER = AT91C_TC_CPCS;
    243              //IRQ_EnableIT(AT91C_ID_TC0);
    244          
    245          }   // end init_timer()
   \   0000002A   10BD               POP      {R4,PC}          ;; return
    246          
    247          /*
    248          //----------------------------------------------------------------------------
    249          //  Function Name       : start_timer0(delay_count)
    250          //  Object              : load register C with compare value then start timer0 
    251          //  Input Parameters    : delay_count
    252          //  Output Parameters   : none
    253          // ----------------------------------------------------------------------------
    254          // 
    255          //  This function clears and starts timer0, then returns to calling program. Once
    256          //  started, timer0 will stop counting and set the timer0 CPCS status flag when
    257          //  count = <Register C>. Because the CPCS flag is polled by the calling program,
    258          //  the timer0 interrrupt is not used.
    259          // 
    260          //  IMPORTANT valid range for delay_count: delay_count < 65,536 (decimal), 0x10000
    261          //  See function "Delay_us()" below, for example using start_timer0()  
    262          
    263          void start_timer0(unsigned short int delay_count) {
    264              
    265              unsigned short int i;
    266              // Operating mode already loaded for timer0
    267              // timer0 status is polled so we do not use interrupt
    268              
    269              // Load delay_count into the TC_RC register
    270              AT91C_BASE_TC0->TC_RC = delay_count;
    271              // Read timer0 status register to reset its CPCS flag
    272              i = AT91C_BASE_TC0->TC_SR;
    273              // Suppress warning: variable "i" was set, never used
    274              i = i;    
    275              // Start timer0: Clock Enable and software trigger, which clears the timer 
    276              // and up-count begins. Counting stops when Register C match occurs.
    277              AT91C_BASE_TC0->TC_CCR = AT91C_TC_CLKEN | AT91C_TC_SWTRG;
    278          } 
    279          */
    280          
    281          // --------------------------------------------------------------------------------------
    282          //  Function Name       : Delay_us()
    283          //  Object              : in-line delay
    284          //  Input Parameters    : num_us = integer number of microseconds <  2731 
    285          //  Output Parameters   : none
    286          // ---------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    287          void Delay_us(unsigned short int num_us) {
   \                     Delay_us:
   \   00000000   30B5               PUSH     {R4,R5,LR}
   \   00000002   89B0               SUB      SP,SP,#+36
   \   00000004   0400               MOVS     R4,R0
    288          
    289              const Pin pinLEDY = PIN_LEDY;
   \   00000006   00A8               ADD      R0,SP,#+0
   \   00000008   ....               LDR.N    R1,??DataTable11_10
   \   0000000A   2022               MOVS     R2,#+32
   \   0000000C   ........           BL       __aeabi_memcpy4
    290              unsigned short i;
    291              
    292          //  Previous call for function "init_timer()" is assumed.
    293          //  Use timer0 to generate an n_uS in-line delay. Can verify delay by pulse on LED4.
    294          //  In this function, timer0 status is polled, okay for in-line delays.
    295          //  While less overhead than using a vectored-interrupt delay, the pulse
    296          //  generated is slightly longer than the set value because we poll timer0 status...
    297          //    
    298          //  TC0 Channel Mode Register prescaler selected, 48MHz    Load #     Max t (int)
    299          //  ----------------------------------------------------   -------    -----------
    300          //  AT91C_TC_CLKS_TIMER_DIV1_CLOCK for MCLK/2     48/2     24/1us     2,730us     <--- used
    301          //  AT91C_TC_CLKS_TIMER_DIV2_CLOCK for MCLK/8     48/8     6/1us      10,922us
    302          //  AT91C_TC_CLKS_TIMER_DIV3_CLOCK for MCLK/32    48K/32   1500/1ms   43ms
    303          //  AT91C_TC_CLKS_TIMER_DIV4_CLOCK for MCLK/128   48K/128  375/1ms    174ms
    304             
    305              // using 48MHz MCLK and div-by-2 prescaler...
    306              AT91C_BASE_TC0->TC_CMR = AT91C_TC_WAVE | AT91C_TC_CPCSTOP 
    307                                                     | AT91C_TC_CLKS_TIMER_DIV1_CLOCK; // for MCLK/2
   \   00000010   ....               LDR.N    R0,??DataTable11_9  ;; 0x40080004
   \   00000012   48F24001           MOVW     R1,#+32832
   \   00000016   0160               STR      R1,[R0, #+0]
    308          
    309              // Load delay_count into the TC_RC register
    310              AT91C_BASE_TC0->TC_RC = num_us * (BOARD_MCK / 2000000);
   \   00000018   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000001A   1820               MOVS     R0,#+24
   \   0000001C   00FB04F0           MUL      R0,R0,R4
   \   00000020   ....               LDR.N    R1,??DataTable11_11  ;; 0x4008001c
   \   00000022   0860               STR      R0,[R1, #+0]
    311              
    312              // Read timer0 status register to reset its CPCS flag
    313              i = AT91C_BASE_TC0->TC_SR;
   \   00000024   ....               LDR.N    R0,??DataTable11_8  ;; 0x40080020
   \   00000026   0068               LDR      R0,[R0, #+0]
   \   00000028   0500               MOVS     R5,R0
    314              // Suppress warning: variable "i" was set, never used
    315              i = i;    
    316              // Start timer0: Clock Enable and software trigger, which clears the timer 
    317              // and up-count begins. Counting stops when Register C match occurs.
    318              AT91C_BASE_TC0->TC_CCR = AT91C_TC_CLKEN | AT91C_TC_SWTRG;
   \   0000002A   ....               LDR.N    R0,??DataTable11_6  ;; 0x40080000
   \   0000002C   0521               MOVS     R1,#+5
   \   0000002E   0160               STR      R1,[R0, #+0]
    319              
    320             // Turn ON LED, logic-0 
    321              PIO_Clear(&pinLEDY);
   \   00000030   00A8               ADD      R0,SP,#+0
   \   00000032   ........           BL       PIO_Clear
    322              
    323              // poll timer0 register C compare status until 0 -> 1 transition
    324              while (!(AT91C_BASE_TC0->TC_SR & AT91C_TC_CPCS)) ;
   \                     ??Delay_us_0:
   \   00000036   ....               LDR.N    R0,??DataTable11_8  ;; 0x40080020
   \   00000038   0068               LDR      R0,[R0, #+0]
   \   0000003A   C006               LSLS     R0,R0,#+27
   \   0000003C   FBD5               BPL.N    ??Delay_us_0
    325              
    326              // time-out occurred, turn OFF LED, logic-01
    327              PIO_Set(&pinLEDY);
   \   0000003E   00A8               ADD      R0,SP,#+0
   \   00000040   ........           BL       PIO_Set
    328          
    329          }
   \   00000044   09B0               ADD      SP,SP,#+36
   \   00000046   30BD               POP      {R4,R5,PC}       ;; return
    330          
    331          
    332          // --------------------------------------------------------------------------------------
    333          //  Function Name       : Delay_ms()
    334          //  Object              : in-line delay
    335          //  Input Parameters    : num_us = integer number of milliseconds < 175
    336          //  Output Parameters   : none
    337          // ---------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    338          void Delay_ms(unsigned short int num_ms) {
    339          
    340              unsigned short i;
    341              
    342          //  Use timer0 to generate an n_uS in-line delay. Can verify delay by pulse on LED4.
    343          //  In this example timer0 status is polled, okay for in-line delays.
    344          //  While less overhead than using a vectored-interrupt delay (below), the pulse
    345          //  generated is slightly longer than the set value because we poll timer0 status...
    346          //    
    347          //  TC0 Channel Mode Register prescaler selected, 48MHz    Load #     Max t (int)
    348          //  ----------------------------------------------------   -------    -----------
    349          //  AT91C_TC_CLKS_TIMER_DIV1_CLOCK for MCLK/2     48/2     24/1us     2,730us
    350          //  AT91C_TC_CLKS_TIMER_DIV2_CLOCK for MCLK/8     48/8     6/1us      10,922us
    351          //  AT91C_TC_CLKS_TIMER_DIV3_CLOCK for MCLK/32    48K/32   1500/1ms   43ms
    352          //  AT91C_TC_CLKS_TIMER_DIV4_CLOCK for MCLK/128   48K/128  375/1ms    174ms     <--- used
    353             
    354              // using 48MHz MCLK and div-by-2 prescaler...
    355              AT91C_BASE_TC0->TC_CMR = AT91C_TC_WAVE | AT91C_TC_CPCSTOP 
    356                                                     | AT91C_TC_CLKS_TIMER_DIV4_CLOCK; // for MCLK/128
   \                     Delay_ms:
   \   00000000   ....               LDR.N    R2,??DataTable11_9  ;; 0x40080004
   \   00000002   48F24303           MOVW     R3,#+32835
   \   00000006   1360               STR      R3,[R2, #+0]
    357          
    358              // Load delay_count into the TC_RC register
    359              AT91C_BASE_TC0->TC_RC = num_ms * (BOARD_MCK / 128000);	    
   \   00000008   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000A   40F27712           MOVW     R2,#+375
   \   0000000E   02FB00F2           MUL      R2,R2,R0
   \   00000012   ....               LDR.N    R3,??DataTable11_11  ;; 0x4008001c
   \   00000014   1A60               STR      R2,[R3, #+0]
    360              
    361              // Read timer0 status register to reset its CPCS flag
    362              i = AT91C_BASE_TC0->TC_SR;
   \   00000016   ....               LDR.N    R2,??DataTable11_8  ;; 0x40080020
   \   00000018   1268               LDR      R2,[R2, #+0]
   \   0000001A   1100               MOVS     R1,R2
    363              // Suppress warning: variable "i" was set, never used
    364              i = i;    
    365              // Start timer0: Clock Enable and software trigger, which clears the timer 
    366              // and up-count begins. Counting stops when Register C match occurs.
    367              AT91C_BASE_TC0->TC_CCR = AT91C_TC_CLKEN | AT91C_TC_SWTRG;
   \   0000001C   ....               LDR.N    R2,??DataTable11_6  ;; 0x40080000
   \   0000001E   0523               MOVS     R3,#+5
   \   00000020   1360               STR      R3,[R2, #+0]
    368              
    369             // Turn ON yellow LED, logic-0, measure pulse time to check delay time 
    370             // AT91C_BASE_PIOA->PIO_CODR = nLEDY; 
    371              
    372              // poll timer0 register C compare status until 0 -> 1 transition
    373              while (!(AT91C_BASE_TC0->TC_SR & AT91C_TC_CPCS)) ;
   \                     ??Delay_ms_0:
   \   00000022   ....               LDR.N    R2,??DataTable11_8  ;; 0x40080020
   \   00000024   1268               LDR      R2,[R2, #+0]
   \   00000026   D206               LSLS     R2,R2,#+27
   \   00000028   FBD5               BPL.N    ??Delay_ms_0
    374              
    375              // time-out occurred, turn OFF yellow LED, logic-01
    376              AT91C_BASE_PIOA->PIO_SODR = nLEDY; 
   \   0000002A   ....               LDR.N    R2,??DataTable11_12  ;; 0x400e0c30
   \   0000002C   5FF08043           MOVS     R3,#+1073741824
   \   00000030   1360               STR      R3,[R2, #+0]
    377          
    378          }
   \   00000032   7047               BX       LR               ;; return
    379          
    380          // ---------------------------------------------------------------------------------------
    381          // multiple 100ms in-line delay
    382          // ---------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    383          void Delay_x100ms(char num) {  
   \                     Delay_x100ms:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    384            for(; 0 < num ; num--) {
   \                     ??Delay_x100ms_0:
   \   00000004   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   012C               CMP      R4,#+1
   \   00000008   04D3               BCC.N    ??Delay_x100ms_1
    385                Delay_ms(100);
   \   0000000A   6420               MOVS     R0,#+100
   \   0000000C   ........           BL       Delay_ms
    386            }
   \   00000010   641E               SUBS     R4,R4,#+1
   \   00000012   F7E7               B.N      ??Delay_x100ms_0
    387          }
   \                     ??Delay_x100ms_1:
   \   00000014   10BD               POP      {R4,PC}          ;; return
    388          
    389          // ---------------------------------------------------------------------------------------
    390          // flash red LED for 400ms
    391          // ---------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    392          void Flash_Red_LED(void) {
   \                     Flash_Red_LED:
   \   00000000   80B5               PUSH     {R7,LR}
    393              AT91C_BASE_PIOA->PIO_CODR = nLEDR; 
   \   00000002   ....               LDR.N    R0,??DataTable11_13  ;; 0x400e0c34
   \   00000004   5FF00041           MOVS     R1,#-2147483648
   \   00000008   0160               STR      R1,[R0, #+0]
    394              Delay_x100ms(4);
   \   0000000A   0420               MOVS     R0,#+4
   \   0000000C   ........           BL       Delay_x100ms
    395              AT91C_BASE_PIOA->PIO_SODR = nLEDR; 
   \   00000010   ....               LDR.N    R0,??DataTable11_12  ;; 0x400e0c30
   \   00000012   5FF00041           MOVS     R1,#-2147483648
   \   00000016   0160               STR      R1,[R0, #+0]
    396          }
   \   00000018   01BD               POP      {R0,PC}          ;; return
    397          
    398          
    399          // ---------------------------------------------------------------------------------------
    400          // flash green LED for 400ms
    401          // ---------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    402          void Flash_Green_LED(void) {
   \                     Flash_Green_LED:
   \   00000000   80B5               PUSH     {R7,LR}
    403              AT91C_BASE_PIOA->PIO_CODR = nLEDG; 
   \   00000002   ....               LDR.N    R0,??DataTable11_13  ;; 0x400e0c34
   \   00000004   5FF00051           MOVS     R1,#+536870912
   \   00000008   0160               STR      R1,[R0, #+0]
    404              Delay_x100ms(4);
   \   0000000A   0420               MOVS     R0,#+4
   \   0000000C   ........           BL       Delay_x100ms
    405              AT91C_BASE_PIOA->PIO_SODR = nLEDG; 
   \   00000010   ....               LDR.N    R0,??DataTable11_12  ;; 0x400e0c30
   \   00000012   5FF00051           MOVS     R1,#+536870912
   \   00000016   0160               STR      R1,[R0, #+0]
    406          }
   \   00000018   01BD               POP      {R0,PC}          ;; return
    407          
    408          
    409          
    410          // ---------------------------------------------------------------------------------------
    411          //\ brief	Next function flashes red LED forever:
    412          //		groups of N flashes where N = 2-7, else N = 1 
    413          //		No return to calling function.
    414          //
    415          //		# flashes 	Error type
    416          //		2		Op Status register RT Address parity error
    417          //		3		auto-init data mismatch error
    418          //		4		auto-init EEPROM checksum failure
    419          //		5		Op Status register reads back zero, something broken
    420          //		6		EECOPY failure: for example an invalid unlock code
    421          //              7               Terminal(s) enabled in pgm have negated enable pin(s)
    422          // ---------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    423          void error_trap(char count) {
   \                     error_trap:
   \   00000000   30B5               PUSH     {R4,R5,LR}
   \   00000002   89B0               SUB      SP,SP,#+36
   \   00000004   0400               MOVS     R4,R0
    424          
    425              const Pin pinLEDR = PIN_LEDR;
   \   00000006   00A8               ADD      R0,SP,#+0
   \   00000008   ....               LDR.N    R1,??DataTable11_14
   \   0000000A   2022               MOVS     R2,#+32
   \   0000000C   ........           BL       __aeabi_memcpy4
    426              int i;
    427          
    428              // brief delay to separate from auto-init red LED blink after reset
    429              Delay_x100ms(12);
   \   00000010   0C20               MOVS     R0,#+12
   \   00000012   ........           BL       Delay_x100ms
    430          	
    431              if ((count > 7)||(count < 2)) {
   \   00000016   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   082C               CMP      R4,#+8
   \   0000001A   02D2               BCS.N    ??error_trap_0
   \   0000001C   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   022C               CMP      R4,#+2
   \   00000020   01D2               BCS.N    ??error_trap_1
    432                  count = 1;
   \                     ??error_trap_0:
   \   00000022   0120               MOVS     R0,#+1
   \   00000024   0400               MOVS     R4,R0
    433              }
    434              
    435              while(1) {
    436                  // perpetually blink red LED in groups of N flashes
    437          	for (i = 0; i < count; i++) {
   \                     ??error_trap_1:
   \   00000026   0020               MOVS     R0,#+0
   \   00000028   0500               MOVS     R5,R0
   \                     ??error_trap_2:
   \   0000002A   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002C   A542               CMP      R5,R4
   \   0000002E   0DDA               BGE.N    ??error_trap_3
    438          	    PIO_Set(&pinLEDR);
   \   00000030   00A8               ADD      R0,SP,#+0
   \   00000032   ........           BL       PIO_Set
    439          	    Delay_x100ms(2);  
   \   00000036   0220               MOVS     R0,#+2
   \   00000038   ........           BL       Delay_x100ms
    440          	    PIO_Clear(&pinLEDR);
   \   0000003C   00A8               ADD      R0,SP,#+0
   \   0000003E   ........           BL       PIO_Clear
    441          	    Delay_x100ms(2);
   \   00000042   0220               MOVS     R0,#+2
   \   00000044   ........           BL       Delay_x100ms
    442                  }
   \   00000048   6D1C               ADDS     R5,R5,#+1
   \   0000004A   EEE7               B.N      ??error_trap_2
    443                  // 1.2 sec delay
    444                  Delay_x100ms(12);
   \                     ??error_trap_3:
   \   0000004C   0C20               MOVS     R0,#+12
   \   0000004E   ........           BL       Delay_x100ms
   \   00000052   E8E7               B.N      ??error_trap_1
    445              }
    446          }
    447          
    448          
    449          
    450          //--------------------------------------------------------------------------------
    451          // This function checks states for BC, RT1, RT2, and MT DIP switches. For each 
    452          // DIP switch = 1 (terminal enabled) the function verifies that the corresponding 
    453          // compiler run-time switch is also ON. For example: if BCENA DIP switch = 1 
    454          // then BC_ENA (in file 613x_initialization.h) must be defined ON (non-zero). 
    455          // If one or more switch-enabled terminals has a compiler run-time switch 
    456          // defined OFF (or if all 4 DIP switches = 0) an error trap occurs, perpetually
    457          // flashing the red LED (no return). If error-free, function returns a 16-bit word 
    458          // with two "run bits" set for each enabled DIP switch, except MT has 1 bit.
    459          //---------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    460          unsigned short enable_check(void) {
   \                     enable_check:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   A0B0               SUB      SP,SP,#+128
    461            short int runbits = 0;
   \   00000004   0024               MOVS     R4,#+0
    462              const Pin pinBCENA = PIN_BCENA;
   \   00000006   18A8               ADD      R0,SP,#+96
   \   00000008   ....               LDR.N    R1,??DataTable11_15
   \   0000000A   2022               MOVS     R2,#+32
   \   0000000C   ........           BL       __aeabi_memcpy4
    463              const Pin pinMTRUN = PIN_MTRUN;
   \   00000010   10A8               ADD      R0,SP,#+64
   \   00000012   ....               LDR.N    R1,??DataTable11_16
   \   00000014   2022               MOVS     R2,#+32
   \   00000016   ........           BL       __aeabi_memcpy4
    464              const Pin pinRT1ENA = PIN_RT1ENA;
   \   0000001A   08A8               ADD      R0,SP,#+32
   \   0000001C   ....               LDR.N    R1,??DataTable11_17
   \   0000001E   2022               MOVS     R2,#+32
   \   00000020   ........           BL       __aeabi_memcpy4
    465              const Pin pinRT2ENA = PIN_RT2ENA;
   \   00000024   00A8               ADD      R0,SP,#+0
   \   00000026   ....               LDR.N    R1,??DataTable11_18
   \   00000028   2022               MOVS     R2,#+32
   \   0000002A   ........           BL       __aeabi_memcpy4
    466                  
    467              if(PIO_Get(&pinBCENA)) {
   \   0000002E   18A8               ADD      R0,SP,#+96
   \   00000030   ........           BL       PIO_Get
   \   00000034   0028               CMP      R0,#+0
   \   00000036   07D0               BEQ.N    ??enable_check_0
    468                  // BCENA pin high, trap error if compiler runtime switch BC_ena is FALSE
    469                  #if(!BC_ena) 
    470                      #if(CONSOLE_IO)
    471                          printf("\n\r Error: BCENA pin high, but software BC_ena false.\n\r");
   \   00000038   ....               LDR.N    R0,??DataTable11_19
   \   0000003A   ........           BL       printf
    472                      #endif
    473                      error_trap(3);
   \   0000003E   0320               MOVS     R0,#+3
   \   00000040   ........           BL       error_trap
    474                  #endif
    475                  runbits |= BCENA|BCSTRT;
   \   00000044   54F44054           ORRS     R4,R4,#0x3000
    476              }
    477              else {
    478                  // BCENA pin low, trap error if compiler runtime switch BC_ena is TRUE
    479                  #if(BC_ena) 
    480                      #if(CONSOLE_IO)
    481                          printf("\n\r Error: BCENA pin low, but software BC_ena true.\n\r");
    482                      #endif
    483                      error_trap(3);
    484                  #endif 
    485              }      
    486              if(PIO_Get(&pinRT1ENA)) {
   \                     ??enable_check_0:
   \   00000048   08A8               ADD      R0,SP,#+32
   \   0000004A   ........           BL       PIO_Get
   \   0000004E   0028               CMP      R0,#+0
   \   00000050   07D0               BEQ.N    ??enable_check_1
    487                  // RT1ENA pin high, trap error if compiler runtime switch RT1_ena is FALSE
    488                  #if(!RT1_ena) 
    489                      #if(CONSOLE_IO)
    490                          printf("\n\r Error: RT1ENA pin high, but software RT1_ena false.\n\r");
   \   00000052   ....               LDR.N    R0,??DataTable11_20
   \   00000054   ........           BL       printf
    491                      #endif 
    492                      error_trap(3);
   \   00000058   0320               MOVS     R0,#+3
   \   0000005A   ........           BL       error_trap
    493                  #endif
    494                  runbits |= RT1ENA|RT1STEX;
   \   0000005E   54F05004           ORRS     R4,R4,#0x50
    495              }
    496              else {
    497                  // RT1ENA pin low, trap error if compiler runtime switch RT1_ena is TRUE
    498                  #if(RT1_ena) 
    499                      #if(CONSOLE_IO)
    500                          printf("\n\r Error: RT1ENA pin low, but software RT1_ena true.\n\r");
    501                      #endif 
    502                      error_trap(3);
    503                  #endif 
    504              }      
    505              if(PIO_Get(&pinRT2ENA)) {
   \                     ??enable_check_1:
   \   00000062   00A8               ADD      R0,SP,#+0
   \   00000064   ........           BL       PIO_Get
   \   00000068   0028               CMP      R0,#+0
   \   0000006A   07D0               BEQ.N    ??enable_check_2
    506                  // RT2ENA pin high, trap error if compiler runtime switch RT2_ena is FALSE
    507                  #if(!RT2_ena) 
    508                      #if(CONSOLE_IO)
    509                          printf("\n\r Error: RT2ENA pin high, but software RT2_ena false.\n\r");
   \   0000006C   ....               LDR.N    R0,??DataTable11_21
   \   0000006E   ........           BL       printf
    510                      #endif 
    511                      error_trap(3);
   \   00000072   0320               MOVS     R0,#+3
   \   00000074   ........           BL       error_trap
    512                  #endif
    513                  runbits |= RT2ENA|RT2STEX;
   \   00000078   54F0A004           ORRS     R4,R4,#0xA0
    514              }
    515              else {
    516                  // RT2ENA pin low, trap error if compiler runtime switch RT2_ena is TRUE
    517                  #if(RT2_ena) 
    518                      #if(CONSOLE_IO)
    519                          printf("\n\r Error: RT2ENA pin low, but software RT2_ena true.\n\r");
    520                      #endif 
    521                      error_trap(3);
    522                  #endif 
    523              }      
    524              if(PIO_Get(&pinMTRUN)) {
   \                     ??enable_check_2:
   \   0000007C   10A8               ADD      R0,SP,#+64
   \   0000007E   ........           BL       PIO_Get
   \   00000082   0028               CMP      R0,#+0
   \   00000084   03D0               BEQ.N    ??enable_check_3
    525                  // MTENA pin high, trap error if compiler runtime 
    526                  // switches SMT_ena and IMT_ena are both FALSE
    527                  #if(!SMT_ena && !IMT_ena) 
    528                      #if(CONSOLE_IO)
    529                          printf("\n\r Error: MTRUN pin high, but software SMT_ena & IMT_ena both false.\n\r");
    530                      #endif 
    531                     error_trap(3);
    532                  #endif
    533                  // monitor does not have separate enable and run bits
    534                  runbits |= MTENA;
   \   00000086   4FF48070           MOV      R0,#+256
   \   0000008A   0443               ORRS     R4,R0,R4
   \   0000008C   05E0               B.N      ??enable_check_4
    535              }
    536              else {
    537                  // MTRUN pin low, trap error if either compiler 
    538                  // runtime switch SMT_ena or IMT_ena is TRUE
    539                  #if(SMT_ena || IMT_ena)
    540                      #if(CONSOLE_IO)
    541                          printf("\n\r Error: MTRUN pin low, but software SMT_ena or IMT_ena is true.\n\r");
   \                     ??enable_check_3:
   \   0000008E   ....               LDR.N    R0,??DataTable11_22
   \   00000090   ........           BL       printf
    542                      #endif 
    543                      error_trap(3);
   \   00000094   0320               MOVS     R0,#+3
   \   00000096   ........           BL       error_trap
    544                  #endif 
    545              }      
    546              // trap error if nothing is enabled
    547              if(!runbits) {
   \                     ??enable_check_4:
   \   0000009A   24B2               SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   0000009C   002C               CMP      R4,#+0
   \   0000009E   05D1               BNE.N    ??enable_check_5
    548                  #if(CONSOLE_IO)
    549                      printf("\n\r Error: BC, RT1, RT2, IMT, SMT are all disabled.\n\r");
   \   000000A0   ....               LDR.N    R0,??DataTable11_23
   \   000000A2   ........           BL       printf
    550                  #endif 
    551                  error_trap(2);
   \   000000A6   0220               MOVS     R0,#+2
   \   000000A8   ........           BL       error_trap
    552              }
    553              
    554              // write enable bits into the Master Configuration register
    555              //pH6130->MASTER_CONFIG_REG = runbits[0];
    556              
    557              return runbits;
   \                     ??enable_check_5:
   \   000000AC   2000               MOVS     R0,R4
   \   000000AE   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000B0   20B0               ADD      SP,SP,#+128
   \   000000B2   10BD               POP      {R4,PC}          ;; return
    558          }    
    559          
    560          //----------------------------------------------------------------------
    561          // This function copies registers and RAM to the serial EEPROM
    562          // subsequently used for auto-initialization after master reset. 
    563          //
    564          // IMPORTANT: Make sure interrupts are disabled during execution !!!
    565          //----------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    566          void write_init_eeprom(void) {
   \                     write_init_eeprom:
   \   00000000   30B5               PUSH     {R4,R5,LR}
   \   00000002   99B0               SUB      SP,SP,#+100
    567            
    568                  const Pin pinLEDY = PIN_LEDY;
   \   00000004   10A8               ADD      R0,SP,#+64
   \   00000006   ....               LDR.N    R1,??DataTable11_24
   \   00000008   2022               MOVS     R2,#+32
   \   0000000A   ........           BL       __aeabi_memcpy4
    569                  const Pin pinREADY = PIN_READY;
   \   0000000E   08A8               ADD      R0,SP,#+32
   \   00000010   ....               LDR.N    R1,??DataTable11_25
   \   00000012   2022               MOVS     R2,#+32
   \   00000014   ........           BL       __aeabi_memcpy4
    570                  const Pin pinEECOPY = PIN_EECOPY;
   \   00000018   00A8               ADD      R0,SP,#+0
   \   0000001A   ....               LDR.N    R1,??DataTable11_26
   \   0000001C   2022               MOVS     R2,#+32
   \   0000001E   ........           BL       __aeabi_memcpy4
    571          	short unsigned int code1 = 0xA00A, code2 = 0x5FF5;
   \   00000022   4AF20A04           MOVW     R4,#+40970
   \   00000026   45F6F575           MOVW     R5,#+24565
    572          
    573          	// IMPORTANT: make sure interrupts are disabled !!! 
    574          	
    575          	// The default code1/code2 EEPROM unlock values do not start
    576          	// any of the 4 terminal devices when auto-init is complete, 
    577          	// following future master reset with the AUTOEN pin asserted.
    578          	// To start an enabled terminal, the host must then set BCSTRT, 
    579                  // MTRUN, RT1STEX or RT2STEX in Master Configuration register 0
    580                  // after READY assertion, following auto-initialization.
    581                  //
    582          	// If the EEPROM is written with unlock codes modified below,
    583          	// selected terminal devices can be auto-enabled without host assist.
    584          	// To modify these settings, edit file 613x_initialization.h 
    585          
    586          	if ((BC_ena==1) && (BC_autostart==1)) {	
    587          		// IC automatically asserts BCSTRT bit 13 in reg 0, after 
    588          		// auto-initialization. The copied EEPROM image should already 
    589          		// have BCENA bit 12 asserted in reg 0, but not BCSTRT bit 13.
    590          		code1 ^= 0x0C00;
    591          		code2 ^= 0x0C00;
    592          	} 
    593          	if ((RT1_ena==1) && (RT1_autostart==1)) {	
    594          		// IC automatically asserts RT1STEX bit 4 in reg 0, after 
    595          		// auto-initialization. The copied EEPROM image should already 
    596          		// have RT1ENA bit 6 asserted in reg 0, but not RT1STEX bit 4.
    597          		code1 ^= 0x0030;
    598          		code2 ^= 0x0030;
    599          	} 
    600          	if ((RT2_ena==1) && (RT2_autostart==1)) {	
    601          		// IC automatically asserts RT2STEX bit 5 in reg 0, after 
    602          		// auto-initialization. The copied EEPROM image should already 
    603          		// have RT2ENA bit 7 asserted in reg 0,but not RT2STEX bit 5.
    604          		code1 ^= 0x00C0;
    605          		code2 ^= 0x00C0;
    606          	} 
    607          	if ((SMT_ena|IMT_ena ==1) && (SMT_IMT_autostart==1)) {	
    608          		// IC automatically asserts MTENA bit 8 in reg 0, after
    609          		// auto-initialization. The monitor begins recording bus activity 
    610          		// upon detecting the next Manchester word (or sync+bits) as 
    611          		// set by bits 6-5 in the MT Configuration reg 0x0029 
    612          		code1 ^= 0x0300;
    613          		code2 ^= 0x0300;
    614          	}
    615          
    616          
    617          	    // write unlock code #1 
    618          	    pH6130->EEPROM_UNLOCK_REG = code1;
   \   0000002A   ....               LDR.N    R0,??DataTable11_5
   \   0000002C   0068               LDR      R0,[R0, #+0]
   \   0000002E   A0F89C40           STRH     R4,[R0, #+156]
    619          	    // write unlock code #2 
    620          	    pH6130->EEPROM_UNLOCK_REG = code2;         
   \   00000032   ....               LDR.N    R0,??DataTable11_5
   \   00000034   0068               LDR      R0,[R0, #+0]
   \   00000036   A0F89C50           STRH     R5,[R0, #+156]
    621          	// assert HI-613x EECOPY input for 1 ms minimum,
    622          	// and EEPROM copy will begin after EECOPY falling edge
    623          	PIO_Set(&pinEECOPY);
   \   0000003A   00A8               ADD      R0,SP,#+0
   \   0000003C   ........           BL       PIO_Set
    624                  Delay_x100ms(11);
   \   00000040   0B20               MOVS     R0,#+11
   \   00000042   ........           BL       Delay_x100ms
    625          	PIO_Clear(&pinEECOPY);
   \   00000046   00A8               ADD      R0,SP,#+0
   \   00000048   ........           BL       PIO_Clear
    626          
    627          	// turn on yellow LED while EEPROM programming is underway
    628                  PIO_Clear(&pinLEDY);
   \   0000004C   10A8               ADD      R0,SP,#+64
   \   0000004E   ........           BL       PIO_Clear
    629          
    630          	// READY pin should have dropped to 0 after EECOPY pulse ended
    631                  if(PIO_Get(&pinREADY)) {
   \   00000052   08A8               ADD      R0,SP,#+32
   \   00000054   ........           BL       PIO_Get
   \   00000058   0028               CMP      R0,#+0
   \   0000005A   05D0               BEQ.N    ??write_init_eeprom_0
    632                      #if(CONSOLE_IO)
    633                          printf("\n\r Error: READY pin should have dropped to 0 after EECOPY pulse ended.\n\r");
   \   0000005C   ....               LDR.N    R0,??DataTable11_27
   \   0000005E   ........           BL       printf
    634                      #endif 
    635                      error_trap(6); // flash red LED 6x groups
   \   00000062   0620               MOVS     R0,#+6
   \   00000064   ........           BL       error_trap
    636                  }
    637          
    638          	// wait for READY pin which signifies completion of EEPROM 
    639          	// copy from HI-613X registers and RAM. The device EE1K 
    640          	// input pin determines whether 1K or 32K x 16 gets copied 
    641          	// to EEPROM. The copy process can take up to 3 seconds...
    642          	while(!PIO_Get(&pinREADY)) ;
   \                     ??write_init_eeprom_0:
   \   00000068   08A8               ADD      R0,SP,#+32
   \   0000006A   ........           BL       PIO_Get
   \   0000006E   0028               CMP      R0,#+0
   \   00000070   FAD0               BEQ.N    ??write_init_eeprom_0
    643          
    644          	// turn off the yellow LED
    645                  PIO_Set(&pinLEDY);
   \   00000072   10A8               ADD      R0,SP,#+64
   \   00000074   ........           BL       PIO_Set
    646          
    647          }	// end: write_init_eeprom()
   \   00000078   19B0               ADD      SP,SP,#+100
   \   0000007A   30BD               POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   ........           DC32     `?<Constant {{131072, (AT91S_PIO *)1074662912, `

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   ........           DC32     `?<Constant {32, (AT91S_PIO *)1074662912, 11, 2`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   34100E40           DC32     0x400e1034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   30100E40           DC32     0x400e1030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   ........           DC32     `?<Constant {16, (AT91S_PIO *)1074662912, 11, 2`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   ........           DC32     pH6130

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \   00000000   00000840           DC32     0x40080000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \   00000000   28000840           DC32     0x40080028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \   00000000   20000840           DC32     0x40080020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_9:
   \   00000000   04000840           DC32     0x40080004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_10:
   \   00000000   ........           DC32     `?<Constant {1073741824, (AT91S_PIO *)107466240`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_11:
   \   00000000   1C000840           DC32     0x4008001c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_12:
   \   00000000   300C0E40           DC32     0x400e0c30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_13:
   \   00000000   340C0E40           DC32     0x400e0c34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_14:
   \   00000000   ........           DC32     `?<Constant {2147483648, (AT91S_PIO *)107466240`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_15:
   \   00000000   ........           DC32     `?<Constant {268435456, (AT91S_PIO *)1074663424`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_16:
   \   00000000   ........           DC32     `?<Constant {134217728, (AT91S_PIO *)1074663424`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_17:
   \   00000000   ........           DC32     `?<Constant {65536, (AT91S_PIO *)1074663424, 12`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_18:
   \   00000000   ........           DC32     `?<Constant {67108864, (AT91S_PIO *)1074663424,`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_19:
   \   00000000   ........           DC32     `?<Constant "\\n\\r Error: BCENA pin h...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_20:
   \   00000000   ........           DC32     `?<Constant "\\n\\r Error: RT1ENA pin ...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_21:
   \   00000000   ........           DC32     `?<Constant "\\n\\r Error: RT2ENA pin ...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_22:
   \   00000000   ........           DC32     `?<Constant "\\n\\r Error: MTRUN pin l...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_23:
   \   00000000   ........           DC32     `?<Constant "\\n\\r Error: BC, RT1, RT...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_24:
   \   00000000   ........           DC32     `?<Constant {1073741824, (AT91S_PIO *)107466240_1`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_25:
   \   00000000   ........           DC32     `?<Constant {32, (AT91S_PIO *)1074662912, 11, 2_1`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_26:
   \   00000000   ........           DC32     `?<Constant {16777216, (AT91S_PIO *)1074663424,`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_27:
   \   00000000   ........           DC32     `?<Constant "\\n\\r Error: READY pin s...">`

   \                                 In section .rodata, align 4
   \                     `?<Constant {{131072, (AT91S_PIO *)1074662912, `:
   \   00000000   00000200000E       DC32 131072, 400E0E00H
   \              0E40        
   \   00000008   0B0202000000       DC8 11, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   0000001B   0000000000         DC8 0, 0, 0, 0, 0
   \   00000020   00000400000E       DC32 262144, 400E0E00H
   \              0E40        
   \   00000028   0B0202000000       DC8 11, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   0000003B   0000000000         DC8 0, 0, 0, 0, 0
   \   00000040   04000000000E       DC32 4, 400E0E00H
   \              0E40        
   \   00000048   0B0200000000       DC8 11, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \   0000005A   000000000000       DC8 0, 0, 0, 0, 0, 0
   \   00000060   00000001000E       DC32 16777216, 400E0E00H
   \              0E40        
   \   00000068   0B0200000000       DC8 11, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \   0000007A   000000000000       DC8 0, 0, 0, 0, 0, 0
   \   00000080   08000000000E       DC32 8, 400E0E00H
   \              0E40        
   \   00000088   0B0200000000       DC8 11, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \   0000009A   000000000000       DC8 0, 0, 0, 0, 0, 0
   \   000000A0   10000000000E       DC32 16, 400E0E00H
   \              0E40        
   \   000000A8   0B0200000000       DC8 11, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \   000000BA   000000000000       DC8 0, 0, 0, 0, 0, 0
   \   000000C0   000000080010       DC32 134217728, 400E1000H
   \              0E40        
   \   000000C8   0C0200000000       DC8 12, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \   000000DA   000000000000       DC8 0, 0, 0, 0, 0, 0
   \   000000E0   000000100010       DC32 268435456, 400E1000H
   \              0E40        
   \   000000E8   0C0200000000       DC8 12, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \   000000FA   000000000000       DC8 0, 0, 0, 0, 0, 0
   \   00000100   000001000010       DC32 65536, 400E1000H
   \              0E40        
   \   00000108   0C0200000000       DC8 12, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \   0000011A   000000000000       DC8 0, 0, 0, 0, 0, 0
   \   00000120   000000040010       DC32 67108864, 400E1000H
   \              0E40        
   \   00000128   0C0200000000       DC8 12, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \   0000013A   000000000000       DC8 0, 0, 0, 0, 0, 0
   \   00000140   001000000010       DC32 4096, 400E1000H
   \              0E40        
   \   00000148   0C0200000000       DC8 12, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \   0000015A   000000000000       DC8 0, 0, 0, 0, 0, 0
   \   00000160   002000000010       DC32 8192, 400E1000H
   \              0E40        
   \   00000168   0C0200000000       DC8 12, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \   0000017A   000000000000       DC8 0, 0, 0, 0, 0, 0
   \   00000180   004000000010       DC32 16384, 400E1000H
   \              0E40        
   \   00000188   0C0200000000       DC8 12, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \   0000019A   000000000000       DC8 0, 0, 0, 0, 0, 0
   \   000001A0   008000000010       DC32 32768, 400E1000H
   \              0E40        
   \   000001A8   0C0200000000       DC8 12, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \   000001BA   000000000000       DC8 0, 0, 0, 0, 0, 0
   \   000001C0   01000000000C       DC32 1, 400E0C00H
   \              0E40        
   \   000001C8   0A0200000000       DC8 10, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \   000001DA   000000000000       DC8 0, 0, 0, 0, 0, 0
   \   000001E0   02000000000C       DC32 2, 400E0C00H
   \              0E40        
   \   000001E8   0A0200000000       DC8 10, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \   000001FA   000000000000       DC8 0, 0, 0, 0, 0, 0
   \   00000200   01000000000E       DC32 1, 400E0E00H
   \              0E40        
   \   00000208   0B0200000000       DC8 11, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \   0000021A   000000000000       DC8 0, 0, 0, 0, 0, 0
   \   00000220   02000000000E       DC32 2, 400E0E00H
   \              0E40        
   \   00000228   0B0200000000       DC8 11, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \   0000023A   000000000000       DC8 0, 0, 0, 0, 0, 0
   \   00000240   20000000000E       DC32 32, 400E0E00H
   \              0E40        
   \   00000248   0B0200000000       DC8 11, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \   0000025A   000000000000       DC8 0, 0, 0, 0, 0, 0
   \   00000260   000040000010       DC32 4194304, 400E1000H
   \              0E40        
   \   00000268   0C0200000000       DC8 12, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \   0000027A   000000000000       DC8 0, 0, 0, 0, 0, 0
   \   00000280   000000400010       DC32 1073741824, 400E1000H
   \              0E40        
   \   00000288   0C0400000000       DC8 12, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   0000029B   0000000000         DC8 0, 0, 0, 0, 0
   \   000002A0   000000800010       DC32 2147483648, 400E1000H
   \              0E40        
   \   000002A8   0C0400000000       DC8 12, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   000002BB   0000000000         DC8 0, 0, 0, 0, 0
   \   000002C0   00000020000C       DC32 536870912, 400E0C00H
   \              0E40        
   \   000002C8   0A0400000000       DC8 10, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   000002DB   0000000000         DC8 0, 0, 0, 0, 0
   \   000002E0   00000080000C       DC32 2147483648, 400E0C00H
   \              0E40        
   \   000002E8   0A0400000000       DC8 10, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   000002FB   0000000000         DC8 0, 0, 0, 0, 0
   \   00000300   00000040000C       DC32 1073741824, 400E0C00H
   \              0E40        
   \   00000308   0A0400000000       DC8 10, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   0000031B   0000000000         DC8 0, 0, 0, 0, 0
   \   00000320   000002000010       DC32 131072, 400E1000H
   \              0E40        
   \   00000328   0C0300000000       DC8 12, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   0000033B   0000000000         DC8 0, 0, 0, 0, 0
   \   00000340   000080000010       DC32 8388608, 400E1000H
   \              0E40        
   \   00000348   0C0400000000       DC8 12, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   0000035B   0000000000         DC8 0, 0, 0, 0, 0
   \   00000360   000000010010       DC32 16777216, 400E1000H
   \              0E40        
   \   00000368   0C0300000000       DC8 12, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   0000037B   0000000000         DC8 0, 0, 0, 0, 0
   \   00000380   000000020010       DC32 33554432, 400E1000H
   \              0E40        
   \   00000388   0C0300000000       DC8 12, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   0000039B   0000000000         DC8 0, 0, 0, 0, 0
   \   000003A0   000000200010       DC32 536870912, 400E1000H
   \              0E40        
   \   000003A8   0C0300000000       DC8 12, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   000003BB   0000000000         DC8 0, 0, 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant {32, (AT91S_PIO *)1074662912, 11, 2`:
   \   00000000   20000000000E       DC32 32, 400E0E00H
   \              0E40        
   \   00000008   0B0200000000       DC8 11, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \   0000001A   000000000000       DC8 0, 0, 0, 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant {16, (AT91S_PIO *)1074662912, 11, 2`:
   \   00000000   10000000000E       DC32 16, 400E0E00H
   \              0E40        
   \   00000008   0B0200000000       DC8 11, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \   0000001A   000000000000       DC8 0, 0, 0, 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant {1073741824, (AT91S_PIO *)107466240`:
   \   00000000   00000040000C       DC32 1073741824, 400E0C00H
   \              0E40        
   \   00000008   0A0400000000       DC8 10, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   0000001B   0000000000         DC8 0, 0, 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant {2147483648, (AT91S_PIO *)107466240`:
   \   00000000   00000080000C       DC32 2147483648, 400E0C00H
   \              0E40        
   \   00000008   0A0400000000       DC8 10, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   0000001B   0000000000         DC8 0, 0, 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant {268435456, (AT91S_PIO *)1074663424`:
   \   00000000   000000100010       DC32 268435456, 400E1000H
   \              0E40        
   \   00000008   0C0200000000       DC8 12, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \   0000001A   000000000000       DC8 0, 0, 0, 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant {134217728, (AT91S_PIO *)1074663424`:
   \   00000000   000000080010       DC32 134217728, 400E1000H
   \              0E40        
   \   00000008   0C0200000000       DC8 12, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \   0000001A   000000000000       DC8 0, 0, 0, 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant {65536, (AT91S_PIO *)1074663424, 12`:
   \   00000000   000001000010       DC32 65536, 400E1000H
   \              0E40        
   \   00000008   0C0200000000       DC8 12, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \   0000001A   000000000000       DC8 0, 0, 0, 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant {67108864, (AT91S_PIO *)1074663424,`:
   \   00000000   000000040010       DC32 67108864, 400E1000H
   \              0E40        
   \   00000008   0C0200000000       DC8 12, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \   0000001A   000000000000       DC8 0, 0, 0, 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\r Error: BCENA pin h...">`:
   \   00000000   0A0D20457272       DC8 0AH, 0DH, 20H, 45H, 72H, 72H, 6FH, 72H
   \              6F72        
   \   00000008   3A204243454E       DC8 3AH, 20H, 42H, 43H, 45H, 4EH, 41H, 20H
   \              4120        
   \   00000010   70696E206869       DC8 70H, 69H, 6EH, 20H, 68H, 69H, 67H, 68H
   \              6768        
   \   00000018   2C2062757420       DC8 2CH, 20H, 62H, 75H, 74H, 20H, 73H, 6FH
   \              736F        
   \   00000020   667477617265       DC8 66H, 74H, 77H, 61H, 72H, 65H, 20H, 42H
   \              2042        
   \   00000028   435F656E6120       DC8 43H, 5FH, 65H, 6EH, 61H, 20H, 66H, 61H
   \              6661        
   \   00000030   6C73652E0A0D       DC8 6CH, 73H, 65H, 2EH, 0AH, 0DH, 0
   \              00          
   \   00000037   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\r Error: RT1ENA pin ...">`:
   \   00000000   0A0D20457272       DC8 0AH, 0DH, 20H, 45H, 72H, 72H, 6FH, 72H
   \              6F72        
   \   00000008   3A2052543145       DC8 3AH, 20H, 52H, 54H, 31H, 45H, 4EH, 41H
   \              4E41        
   \   00000010   2070696E2068       DC8 20H, 70H, 69H, 6EH, 20H, 68H, 69H, 67H
   \              6967        
   \   00000018   682C20627574       DC8 68H, 2CH, 20H, 62H, 75H, 74H, 20H, 73H
   \              2073        
   \   00000020   6F6674776172       DC8 6FH, 66H, 74H, 77H, 61H, 72H, 65H, 20H
   \              6520        
   \   00000028   5254315F656E       DC8 52H, 54H, 31H, 5FH, 65H, 6EH, 61H, 20H
   \              6120        
   \   00000030   66616C73652E       DC8 66H, 61H, 6CH, 73H, 65H, 2EH, 0AH, 0DH
   \              0A0D        
   \   00000038   00                 DC8 0
   \   00000039   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\r Error: RT2ENA pin ...">`:
   \   00000000   0A0D20457272       DC8 0AH, 0DH, 20H, 45H, 72H, 72H, 6FH, 72H
   \              6F72        
   \   00000008   3A2052543245       DC8 3AH, 20H, 52H, 54H, 32H, 45H, 4EH, 41H
   \              4E41        
   \   00000010   2070696E2068       DC8 20H, 70H, 69H, 6EH, 20H, 68H, 69H, 67H
   \              6967        
   \   00000018   682C20627574       DC8 68H, 2CH, 20H, 62H, 75H, 74H, 20H, 73H
   \              2073        
   \   00000020   6F6674776172       DC8 6FH, 66H, 74H, 77H, 61H, 72H, 65H, 20H
   \              6520        
   \   00000028   5254325F656E       DC8 52H, 54H, 32H, 5FH, 65H, 6EH, 61H, 20H
   \              6120        
   \   00000030   66616C73652E       DC8 66H, 61H, 6CH, 73H, 65H, 2EH, 0AH, 0DH
   \              0A0D        
   \   00000038   00                 DC8 0
   \   00000039   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\r Error: MTRUN pin l...">`:
   \   00000000   0A0D20457272       DC8 0AH, 0DH, 20H, 45H, 72H, 72H, 6FH, 72H
   \              6F72        
   \   00000008   3A204D545255       DC8 3AH, 20H, 4DH, 54H, 52H, 55H, 4EH, 20H
   \              4E20        
   \   00000010   70696E206C6F       DC8 70H, 69H, 6EH, 20H, 6CH, 6FH, 77H, 2CH
   \              772C        
   \   00000018   206275742073       DC8 20H, 62H, 75H, 74H, 20H, 73H, 6FH, 66H
   \              6F66        
   \   00000020   747761726520       DC8 74H, 77H, 61H, 72H, 65H, 20H, 53H, 4DH
   \              534D        
   \   00000028   545F656E6120       DC8 54H, 5FH, 65H, 6EH, 61H, 20H, 6FH, 72H
   \              6F72        
   \   00000030   20494D545F65       DC8 20H, 49H, 4DH, 54H, 5FH, 65H, 6EH, 61H
   \              6E61        
   \   00000038   206973207472       DC8 20H, 69H, 73H, 20H, 74H, 72H, 75H, 65H
   \              7565        
   \   00000040   2E0A0D00           DC8 2EH, 0AH, 0DH, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\r Error: BC, RT1, RT...">`:
   \   00000000   0A0D20457272       DC8 0AH, 0DH, 20H, 45H, 72H, 72H, 6FH, 72H
   \              6F72        
   \   00000008   3A2042432C20       DC8 3AH, 20H, 42H, 43H, 2CH, 20H, 52H, 54H
   \              5254        
   \   00000010   312C20525432       DC8 31H, 2CH, 20H, 52H, 54H, 32H, 2CH, 20H
   \              2C20        
   \   00000018   494D542C2053       DC8 49H, 4DH, 54H, 2CH, 20H, 53H, 4DH, 54H
   \              4D54        
   \   00000020   206172652061       DC8 20H, 61H, 72H, 65H, 20H, 61H, 6CH, 6CH
   \              6C6C        
   \   00000028   206469736162       DC8 20H, 64H, 69H, 73H, 61H, 62H, 6CH, 65H
   \              6C65        
   \   00000030   642E0A0D00         DC8 64H, 2EH, 0AH, 0DH, 0
   \   00000035   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant {1073741824, (AT91S_PIO *)107466240_1`:
   \   00000000   00000040000C       DC32 1073741824, 400E0C00H
   \              0E40        
   \   00000008   0A0400000000       DC8 10, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   0000001B   0000000000         DC8 0, 0, 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant {32, (AT91S_PIO *)1074662912, 11, 2_1`:
   \   00000000   20000000000E       DC32 32, 400E0E00H
   \              0E40        
   \   00000008   0B0200000000       DC8 11, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \   0000001A   000000000000       DC8 0, 0, 0, 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant {16777216, (AT91S_PIO *)1074663424,`:
   \   00000000   000000010010       DC32 16777216, 400E1000H
   \              0E40        
   \   00000008   0C0300000000       DC8 12, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              00          
   \   0000001B   0000000000         DC8 0, 0, 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\r Error: READY pin s...">`:
   \   00000000   0A0D20457272       DC8 0AH, 0DH, 20H, 45H, 72H, 72H, 6FH, 72H
   \              6F72        
   \   00000008   3A2052454144       DC8 3AH, 20H, 52H, 45H, 41H, 44H, 59H, 20H
   \              5920        
   \   00000010   70696E207368       DC8 70H, 69H, 6EH, 20H, 73H, 68H, 6FH, 75H
   \              6F75        
   \   00000018   6C6420686176       DC8 6CH, 64H, 20H, 68H, 61H, 76H, 65H, 20H
   \              6520        
   \   00000020   64726F707065       DC8 64H, 72H, 6FH, 70H, 70H, 65H, 64H, 20H
   \              6420        
   \   00000028   746F20302061       DC8 74H, 6FH, 20H, 30H, 20H, 61H, 66H, 74H
   \              6674        
   \   00000030   657220454543       DC8 65H, 72H, 20H, 45H, 45H, 43H, 4FH, 50H
   \              4F50        
   \   00000038   592070756C73       DC8 59H, 20H, 70H, 75H, 6CH, 73H, 65H, 20H
   \              6520        
   \   00000040   656E6465642E       DC8 65H, 6EH, 64H, 65H, 64H, 2EH, 0AH, 0DH
   \              0A0D        
   \   00000048   00                 DC8 0
   \   00000049   000000             DC8 0, 0, 0
    648          
    649          // end of file
    650          

   Maximum stack usage in bytes:

     Function               .cstack
     --------               -------
     ConfigureGpio             968
     Delay_ms                    0
     Delay_us                   48
     Delay_x100ms                8
     Flash_Green_LED             8
     Flash_Red_LED               8
     autoinit_check             40
     enable_check              136
     error_trap                 48
     init_timer                  8
     initialize_613x_shared      0
     reset_613x                 40
     write_init_eeprom         112


   Section sizes:

     Function/Label                                   Bytes
     --------------                                   -----
     ConfigureGpio                                      32
     reset_613x                                         56
     autoinit_check                                     82
     initialize_613x_shared                             24
     init_timer                                         44
     Delay_us                                           72
     Delay_ms                                           52
     Delay_x100ms                                       22
     Flash_Red_LED                                      26
     Flash_Green_LED                                    26
     error_trap                                         84
     enable_check                                      180
     write_init_eeprom                                 124
     ??DataTable11                                       4
     ??DataTable11_1                                     4
     ??DataTable11_2                                     4
     ??DataTable11_3                                     4
     ??DataTable11_4                                     4
     ??DataTable11_5                                     4
     ??DataTable11_6                                     4
     ??DataTable11_7                                     4
     ??DataTable11_8                                     4
     ??DataTable11_9                                     4
     ??DataTable11_10                                    4
     ??DataTable11_11                                    4
     ??DataTable11_12                                    4
     ??DataTable11_13                                    4
     ??DataTable11_14                                    4
     ??DataTable11_15                                    4
     ??DataTable11_16                                    4
     ??DataTable11_17                                    4
     ??DataTable11_18                                    4
     ??DataTable11_19                                    4
     ??DataTable11_20                                    4
     ??DataTable11_21                                    4
     ??DataTable11_22                                    4
     ??DataTable11_23                                    4
     ??DataTable11_24                                    4
     ??DataTable11_25                                    4
     ??DataTable11_26                                    4
     ??DataTable11_27                                    4
     ?<Constant {{131072, (AT91S_PIO *)1074662912,     960
     ?<Constant {32, (AT91S_PIO *)1074662912, 11, 2     32
     ?<Constant {16, (AT91S_PIO *)1074662912, 11, 2     32
     ?<Constant {1073741824, (AT91S_PIO *)107466240     32
     ?<Constant {2147483648, (AT91S_PIO *)107466240     32
     ?<Constant {268435456, (AT91S_PIO *)1074663424     32
     ?<Constant {134217728, (AT91S_PIO *)1074663424     32
     ?<Constant {65536, (AT91S_PIO *)1074663424, 12     32
     ?<Constant {67108864, (AT91S_PIO *)1074663424,     32
     ?<Constant "\n\r Error: BCENA pin h...">           56
     ?<Constant "\n\r Error: RT1ENA pin ...">           60
     ?<Constant "\n\r Error: RT2ENA pin ...">           60
     ?<Constant "\n\r Error: MTRUN pin l...">           68
     ?<Constant "\n\r Error: BC, RT1, RT...">           56
     ?<Constant {1073741824, (AT91S_PIO *)107466240_1   32
     ?<Constant {32, (AT91S_PIO *)1074662912, 11, 2_1   32
     ?<Constant {16777216, (AT91S_PIO *)1074663424,     32
     ?<Constant "\n\r Error: READY pin s...">           76

 
 1 688 bytes in section .rodata
   936 bytes in section .text
 
   936 bytes of CODE  memory
 1 688 bytes of CONST memory

Errors: none
Warnings: none
